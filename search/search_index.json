{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings \u00a4 Automatic documentation from sources, for MkDocs . Come have a chat or ask questions on our Gitter channel . Features - Python handler - Requirements - Installation - Quick usage Features \u00a4 Language-agnostic: just like MkDocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it with any programming language, as long as there is a handler for it. We currently have handlers for the Crystal and Python languages. Maybe you'd like to add another one to the list? Multiple themes support: each handler can offer multiple themes. Currently, we offer the Material theme as well as basic support for the ReadTheDocs and MkDocs themes for the Python handler. Cross-references across pages: mkdocstrings makes it possible to reference headings in other Markdown files with the classic Markdown linking syntax: [identifier][] or [title][identifier] -- and you don't need to remember which exact page this object was on. This works for any heading that's produced by a mkdocstrings language handler, and you can opt to include any Markdown heading into the global referencing scheme. Note : in versions prior to 0.15 all Markdown headers were included, but now you need to opt in . Cross-references across sites: similarly to Sphinx's intersphinx extension , mkdocstrings can reference API items from other libraries, given they provide an inventory and you load that inventory in your MkDocs configuration. Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by MkDocs when serving the documentation, for auto-reload. Reasonable defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Requirements \u00a4 mkdocstrings requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12 Installation \u00a4 With pip : pip install mkdocstrings With conda : conda install -c conda-forge mkdocstrings Note for Python: you'll need an extra dependency to parse Numpy-style docstrings: pip install pytkdocs[numpy-style] Quick usage \u00a4 # mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference ::: my_library.my_module.my_class See the Usage section of the docs for more examples!","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from sources, for MkDocs . Come have a chat or ask questions on our Gitter channel . Features - Python handler - Requirements - Installation - Quick usage","title":"mkdocstrings"},{"location":"#features","text":"Language-agnostic: just like MkDocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it with any programming language, as long as there is a handler for it. We currently have handlers for the Crystal and Python languages. Maybe you'd like to add another one to the list? Multiple themes support: each handler can offer multiple themes. Currently, we offer the Material theme as well as basic support for the ReadTheDocs and MkDocs themes for the Python handler. Cross-references across pages: mkdocstrings makes it possible to reference headings in other Markdown files with the classic Markdown linking syntax: [identifier][] or [title][identifier] -- and you don't need to remember which exact page this object was on. This works for any heading that's produced by a mkdocstrings language handler, and you can opt to include any Markdown heading into the global referencing scheme. Note : in versions prior to 0.15 all Markdown headers were included, but now you need to opt in . Cross-references across sites: similarly to Sphinx's intersphinx extension , mkdocstrings can reference API items from other libraries, given they provide an inventory and you load that inventory in your MkDocs configuration. Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by MkDocs when serving the documentation, for auto-reload. Reasonable defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs.","title":"Features"},{"location":"#requirements","text":"mkdocstrings requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12","title":"Requirements"},{"location":"#installation","text":"With pip : pip install mkdocstrings With conda : conda install -c conda-forge mkdocstrings Note for Python: you'll need an extra dependency to parse Numpy-style docstrings: pip install pytkdocs[numpy-style]","title":"Installation"},{"location":"#quick-usage","text":"# mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference ::: my_library.my_module.my_class See the Usage section of the docs for more examples!","title":"Quick usage"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.18.0 - 2022-02-06 \u00a4 Compare with 0.17.0 Highlights \u00a4 Python 3.6 support is dropped. We provide a new, experimental Python handler based on Griffe . This new handler brings automatic cross-references for every annotation in your code, including references to third-party libraries' APIs if they provide objects inventories and you explicitely load them in mkdocs.yml . See migration notes in the documentation . The \"legacy\" Python handler now lives in its own repository at https://github.com/mkdocstrings/python-legacy . Packaging / Dependencies \u00a4 Add Crystal extra, update Python extras versions ( b8222b0 by Timoth\u00e9e Mazzucotelli). PR #374 Update autorefs to actually required version ( fc6c7f6 by Timoth\u00e9e Mazzucotelli). Drop Python 3.6 support ( 7205ac6 by Timoth\u00e9e Mazzucotelli). Features \u00a4 Allow unwrapping the <p> tag in convert_markdown filter ( 5351fc8 by Oleh Prypin). PR #369 Support handlers spanning multiple locations ( f42dfc6 by Timoth\u00e9e Mazzucotelli). PR #355 Code Refactoring \u00a4 Prefix logs with the package name only ( 6c2b734 by Timoth\u00e9e Mazzucotelli). PR #375 Extract the Python handler into its own repository ( 74371e4 by Timoth\u00e9e Mazzucotelli). PR #356 Support Jinja2 3.1 ( b377227 by Timoth\u00e9e Mazzucotelli). Issue #360 , PR #361 Find templates in new and deprecated namespaces ( d5d5f18 by Timoth\u00e9e Mazzucotelli). PR #367 Support loading handlers from the mkdocstrings_handlers namespace ( 5c22c6c by Timoth\u00e9e Mazzucotelli). PR #367 0.17.0 - 2021-12-27 \u00a4 Compare with 0.16.2 Features \u00a4 Add show_signature rendering option ( 024ee82 by Will Da Silva). Issue #341 , PR #342 Support Keyword Args and Yields sections ( 1286427 by Timoth\u00e9e Mazzucotelli). Issue #205 and #324 , PR #331 Bug Fixes \u00a4 Do minimum work when falling back to re-collecting an object to get its anchor ( f6cf570 by Timoth\u00e9e Mazzucotelli). Issue #329 , PR #330 Code Refactoring \u00a4 Return multiple identifiers from fallback method ( 78c498c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/autorefs#11 , PR #350 0.16.2 - 2021-10-04 \u00a4 Compare with 0.16.1 Dependencies \u00a4 Support pymdown-extensions v9.x ( 0831343 by Ofek Lev and 38b22ec by Timoth\u00e9e Mazzucotelli). 0.16.1 - 2021-09-23 \u00a4 Compare with 0.16.0 Bug Fixes \u00a4 Fix ReadTheDocs \"return\" template ( 598621b by Timoth\u00e9e Mazzucotelli). 0.16.0 - 2021-09-20 \u00a4 Compare with 0.15.0 Features \u00a4 Add a rendering option to change the sorting of members ( b1fff8b by Joe Rickerby). Issue #114 , PR #274 Add option to show Python base classes ( 436f550 by Brian Koropoff). Issue #269 , PR #297 Support loading external Python inventories in Sphinx format ( a8418cb by Oleh Prypin). PR #287 Support loading external inventories and linking to them ( 8b675f4 by Oleh Prypin). PR #277 Very basic support for MkDocs theme ( 974ca90 by Oleh Prypin). PR #272 Generate objects inventory ( 14ed959 and bbd85a9 by Timoth\u00e9e Mazzucotelli). Issue #251 , PR #253 Bug Fixes \u00a4 Don't render empty code blocks for missing type annotations ( d2e9e1e by Oleh Prypin). Fix custom handler not being used ( 6dcf342 by Timoth\u00e9e Mazzucotelli). Issue #259 , PR #263 Don't hide setup_commands errors ( 92418c4 by Gabriel V\u00eejial\u0103). PR #258 Code Refactoring \u00a4 Move writing extra files to an earlier stage in the build ( 3890ab5 by Oleh Prypin). PR #275 0.15.2 - 2021-06-09 \u00a4 Compare with 0.15.1 Packaging \u00a4 MkDocs default schema needs to be obtained differently now ( b3e122b by Oleh Prypin). PR #273 Compatibility with MkDocs 1.2: livereload isn't guaranteed now ( 36e8024 by Oleh Prypin). PR #294 0.15.1 - 2021-05-16 \u00a4 Compare with 0.15.0 Bug Fixes \u00a4 Prevent error during parallel installations ( fac2c71 by Timoth\u00e9e Mazzucotelli). Packaging \u00a4 Support the upcoming major Jinja and MarkupSafe releases ( bb4f9de by Oleh Prypin). PR #283 Accept a higher version of mkdocs-autorefs ( c8de08e by Oleh Prypin). PR #282 0.15.0 - 2021-02-28 \u00a4 Compare with 0.14.0 Breaking Changes \u00a4 The following items are possible breaking changes: Cross-linking to arbitrary headings now requires to opt-in to the autorefs plugin, which is installed as a dependency of mkdocstrings . See Cross-references to any Markdown heading . mkdocstrings now respects your configured code highlighting method, so if you are using the CodeHilite extension, the .highlight CSS class in the rendered HTML will become .codehilite . So make sure to adapt your extra CSS accordingly. Or just switch to using pymdownx.highlight , it's better supported by mkdocstrings anyway. See Syntax highlighting . Most of the CSS rules that mkdocstrings used to recommend for manual addition, now become mandatory (auto-injected into the site). This shouldn't break any of your styles, but you are welcome to remove the now-redundant lines that you had copied into extra_css , similarly to this diff . Features \u00a4 Nicer-looking error outputs - no tracebacks from mkdocstrings ( 6baf720 by Oleh Prypin). PR #230 Let handlers add CSS to the pages, do so for Python handler ( 05c7a3f by Oleh Prypin). Issue #189 , PR #218 Allow linking to an object heading not only by its canonical identifier, but also by its possible aliases ( 4789950 by Oleh Prypin). PR #217 Bug Fixes \u00a4 Propagate the CSS class to inline highlighting as well ( c7d80e6 by Oleh Prypin). PR #245 Don't double-escape characters in highlighted headings ( 6357144 by Oleh Prypin). Issue #228 , PR #241 Code Refactoring \u00a4 Use the autorefs plugin from its new external location ( e2d74ef by Oleh Prypin). PR #235 Split out Markdown extensions from handlers to handlers.rendering ( 7533852 by Oleh Prypin). PR #233 Theme-agnostic code highlighting, respecting configs ( f9ea009 by Oleh Prypin). PR #202 Split out autorefs plugin, make it optional ( fc67656 by Oleh Prypin). PR #220 Remove the extra wrapper div from the final doc ( 7fe438c by Oleh Prypin). PR #209 Don't re-parse the whole subdoc, expose only headings ( 15f84f9 by Oleh Prypin). PR #209 Actually exclude hidden headings from the doc ( 0fdb082 by Oleh Prypin). PR #209 0.14.0 - 2021-01-06 \u00a4 Compare with 0.13.6 Special thanks to Oleh @oprypin Prypin who did an amazing job (this is a euphemism) at improving mkdocstrings , fixing hard-to-fix bugs with clever solutions, implementing great new features and refactoring the code for better performance and readability! Thanks Oleh! Bug Fixes \u00a4 Fix double code tags ( e84d401 by Timoth\u00e9e Mazzucotelli). Don't mutate the original Markdown config for permalinks ( 8f6b163 by Oleh Prypin). Preserve text immediately before an autodoc ( 07466fa by Oleh Prypin). PR #207 Remove href attributes from headings in templates ( d5602ff by Oleh Prypin). PR #204 Don't let toc extension append its permalink twice ( a154f5c by Oleh Prypin). PR #203 Fix undefined entity for &para; ( 2c29211 by Timoth\u00e9e Mazzucotelli). Make ids of Markdown sub-documents prefixed with the parent item id ( d493d33 by Oleh Prypin). Issue #186 and #193 , PR #199 More lenient regex for data-mkdocstrings-identifier ( dcfec8e by Oleh Prypin). Shift Markdown headings according to the current heading_level ( 13f41ae by Oleh Prypin). Issue #192 , PR #195 Fix footnotes appearing in all following objects ( af24bc2 by Oleh Prypin). Issue #186 , PR #195 Fix cross-references from the root index page ( 9c9f2a0 by Oleh Prypin). Issue #184 , PR #185 Fix incorrect argument name passed to Markdown ( 10ce502 by Timoth\u00e9e Mazzucotelli). Fix error when a digit immediately follows a code tag ( 9b92341 by Oleh Prypin). Issue #169 , PR #175 Detecting paths relative to template directory in logging ( a50046b by Oleh Prypin). Issue #166 Code Refactoring \u00a4 BlockProcessor already receives strings, use them as such ( bcf7da9 by Oleh Prypin). Remove some unused code ( 8504084 by Oleh Prypin). PR #206 Improve XML parsing error handling ( ad86410 by Timoth\u00e9e Mazzucotelli). Explicitly use MarkupSafe ( 6b9ebe7 by Oleh Prypin). Split out the handler cache, expose it through the plugin ( 6453026 by Oleh Prypin). Issue #179 , PR #191 Use ChainMap instead of copying dicts ( c634d2c by Oleh Prypin). PR #171 Rename logging to loggers to avoid confusion ( 7a119cc by Timoth\u00e9e Mazzucotelli). Simplify logging ( 409f93e by Timoth\u00e9e Mazzucotelli). Features \u00a4 Allow specifying heading_level as a Markdown heading ( 10efc28 by Oleh Prypin). PR #170 Allow any characters in identifiers ( 7ede68a by Oleh Prypin). PR #174 Allow namespace packages for handlers ( 39b0465 by Timoth\u00e9e Mazzucotelli). Add template debugging/logging ( 33b32c1 by Timoth\u00e9e Mazzucotelli). Add initial support for the ReadTheDocs theme ( 1028115 by Timoth\u00e9e Mazzucotelli). Issue #107 , PR #159 Add option to show type annotations in signatures ( f94ce9b by Timoth\u00e9e Mazzucotelli). Issue #106 Packaging \u00a4 Accept verions of pytkdocs up to 0.10.x (see changelog ). Performance Improvements \u00a4 Call update_env only once per Markdown instance ( b198c74 by Oleh Prypin). PR #201 Disable Jinja's auto_reload to reduce disk reads ( 3b28c58 by Oleh Prypin). PR #200 Rework autorefs replacement to not re-parse the final HTML ( 22a9e4b by Oleh Prypin). Issue #187 , PR #188 0.13.6 - 2020-09-28 \u00a4 Compare with 0.13.5 Bug Fixes \u00a4 Fix rendering when clicking on hidden toc entries ( 2af4d31 by Timoth\u00e9e Mazzucotelli). Issue #60 . 0.13.5 - 2020-09-28 \u00a4 Compare with 0.13.4 Packaging \u00a4 Accept pytkdocs version up to 0.9.x ( changelog ). 0.13.4 - 2020-09-25 \u00a4 Compare with 0.13.3 Bug Fixes \u00a4 Bring back arbitrary **config to Python handler ( fca7d4c by Florimond Manca). Issue #154 , PR #155 0.13.3 - 2020-09-25 \u00a4 Compare with 0.13.2 Packaging \u00a4 Accept pytkdocs version up to 0.8.x ( changelog ). 0.13.2 - 2020-09-08 \u00a4 Compare with 0.13.1 Bug Fixes \u00a4 Fix relative URLs when use_directory_urls is false ( 421d189 by Timoth\u00e9e Mazzucotelli). References: #149 0.13.1 - 2020-09-03 \u00a4 Compare with 0.13.0 Bug Fixes \u00a4 Use relative links for cross-references ( 9c77f1f by Timoth\u00e9e Mazzucotelli). References: #144 , #147 0.13.0 - 2020-08-21 \u00a4 Compare with 0.12.2 Bug Fixes \u00a4 Accept dashes in module names ( fcf79d0 by Timoth\u00e9e Mazzucotelli). References: #140 Features \u00a4 Add option to show full path of direct members only ( d1b9401 by Aaron Dunmore). References: #134 , #136 Packaging \u00a4 Accept pymdown-extensions versions up to 0.8.x ( see release notes ) ( 178d48d by Hugo van Kemenade). PR #146 0.12.2 - 2020-07-24 \u00a4 Compare with 0.12.1 Packaging \u00a4 Accept pytkdocs version up to 0.7.x ( changelog ). 0.12.1 - 2020-07-07 \u00a4 Compare with 0.12.0 Bug Fixes \u00a4 Fix HTML-escaped sequence parsing as XML ( db297f1 by Timoth\u00e9e Mazzucotelli). Allow running mkdocs from non-default interpreter ( 283dd7b by Jared Khan). 0.12.0 - 2020-06-14 \u00a4 Compare with 0.11.4 Features \u00a4 Support attributes section in Google-style docstrings ( 8300253 by Timoth\u00e9e Mazzucotelli). References: #88 Support examples section in Google-style docstrings ( 650c754 by Iago Gonz\u00e1lez). References: #112 Packaging \u00a4 Accept pytkdocs version up to 0.6.x ( changelog ). 0.11.4 - 2020-06-08 \u00a4 Compare with 0.11.3 Packaging \u00a4 Accept pytkdocs version up to 0.5.x ( changelog ). If it breaks your docs, please open issues on pytkdocs ' bug-tracker , or pin pytkdocs version to while waiting for bug fixes <0.5.0 . 0.11.3 - 2020-06-07 \u00a4 Compare with 0.11.2 Bug Fixes \u00a4 Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121 0.11.2 - 2020-05-20 \u00a4 Compare with 0.11.1 Packaging \u00a4 Increase pytkdocs version range to accept 0.4.0 ( changelog ). 0.11.1 - 2020-05-14 \u00a4 Compare with 0.11.0 Bug Fixes \u00a4 Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103 0.11.0 - 2020-04-23 \u00a4 Compare with 0.10.3 Bug Fixes \u00a4 Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Features \u00a4 Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82 0.10.3 - 2020-04-10 \u00a4 Compare with 0.10.2 Bug Fixes \u00a4 Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77 Packaging \u00a4 This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs 0.10.2 - 2020-04-07 \u00a4 Compare with 0.10.1 Packaging \u00a4 This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 . 0.10.1 - 2020-04-03 \u00a4 Compare with 0.10.0 Bug Fixes \u00a4 Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68 0.10.0 - 2020-03-27 \u00a4 Compare with 0.9.1 Features \u00a4 Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector . 0.9.1 - 2020-03-21 \u00a4 Compare with 0.9.0 Bug fixes \u00a4 Fix cross-references when deploying to GitHub pages ( 36f804b ). 0.9.0 - 2020-03-21 \u00a4 Compare with 0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users. Features \u00a4 Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting. Bug fixes \u00a4 Various fixes and better error handling. 0.8.0 - 2020-03-04 \u00a4 Compare with 0.7.2 Breaking Changes \u00a4 Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2. 0.7.2 - 2020-03-04 \u00a4 Compare with 0.7.1 Bug Fixes \u00a4 Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ). 0.7.1 - 2020-02-18 \u00a4 Compare with 0.7.0 Bug Fixes \u00a4 Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ). 0.7.0 - 2020-01-13 \u00a4 Compare with 0.6.1 Bug Fixes \u00a4 Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ). Code Refactoring \u00a4 Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ). Features \u00a4 Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ). 0.6.1 - 2020-01-02 \u00a4 Compare with 0.6.0 Bug Fixes \u00a4 Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ). Code Refactoring \u00a4 Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ). 0.6.0 - 2019-12-28 \u00a4 Compare with 0.5.0 Bug Fixes \u00a4 Fix GenericMeta import error on Python 3.7+ ( febf2b9 ). Code Refactoring \u00a4 More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ). 0.5.0 - 2019-12-22 \u00a4 Compare with 0.4.0 Features \u00a4 Use divs in HTML contents to ease styling ( 2a36a0e ). 0.4.0 - 2019-12-22 \u00a4 Compare with 0.3.0 Features \u00a4 Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ). 0.3.0 - 2019-12-21 \u00a4 Compare with 0.2.0 Features \u00a4 Allow object referencing in docstrings ( 2dd50c0 ). 0.2.0 - 2019-12-15 \u00a4 Compare with 0.1.0 Misc \u00a4 Refactor, features, etc. ( 111fa85 ). 0.1.0 - 2019-12-12 \u00a4 Compare with first commit Misc \u00a4 Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#0180-2022-02-06","text":"Compare with 0.17.0","title":"0.18.0 - 2022-02-06"},{"location":"changelog/#highlights","text":"Python 3.6 support is dropped. We provide a new, experimental Python handler based on Griffe . This new handler brings automatic cross-references for every annotation in your code, including references to third-party libraries' APIs if they provide objects inventories and you explicitely load them in mkdocs.yml . See migration notes in the documentation . The \"legacy\" Python handler now lives in its own repository at https://github.com/mkdocstrings/python-legacy .","title":"Highlights"},{"location":"changelog/#packaging-dependencies","text":"Add Crystal extra, update Python extras versions ( b8222b0 by Timoth\u00e9e Mazzucotelli). PR #374 Update autorefs to actually required version ( fc6c7f6 by Timoth\u00e9e Mazzucotelli). Drop Python 3.6 support ( 7205ac6 by Timoth\u00e9e Mazzucotelli).","title":"Packaging / Dependencies"},{"location":"changelog/#features","text":"Allow unwrapping the <p> tag in convert_markdown filter ( 5351fc8 by Oleh Prypin). PR #369 Support handlers spanning multiple locations ( f42dfc6 by Timoth\u00e9e Mazzucotelli). PR #355","title":"Features"},{"location":"changelog/#code-refactoring","text":"Prefix logs with the package name only ( 6c2b734 by Timoth\u00e9e Mazzucotelli). PR #375 Extract the Python handler into its own repository ( 74371e4 by Timoth\u00e9e Mazzucotelli). PR #356 Support Jinja2 3.1 ( b377227 by Timoth\u00e9e Mazzucotelli). Issue #360 , PR #361 Find templates in new and deprecated namespaces ( d5d5f18 by Timoth\u00e9e Mazzucotelli). PR #367 Support loading handlers from the mkdocstrings_handlers namespace ( 5c22c6c by Timoth\u00e9e Mazzucotelli). PR #367","title":"Code Refactoring"},{"location":"changelog/#0170-2021-12-27","text":"Compare with 0.16.2","title":"0.17.0 - 2021-12-27"},{"location":"changelog/#features_1","text":"Add show_signature rendering option ( 024ee82 by Will Da Silva). Issue #341 , PR #342 Support Keyword Args and Yields sections ( 1286427 by Timoth\u00e9e Mazzucotelli). Issue #205 and #324 , PR #331","title":"Features"},{"location":"changelog/#bug-fixes","text":"Do minimum work when falling back to re-collecting an object to get its anchor ( f6cf570 by Timoth\u00e9e Mazzucotelli). Issue #329 , PR #330","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Return multiple identifiers from fallback method ( 78c498c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/autorefs#11 , PR #350","title":"Code Refactoring"},{"location":"changelog/#0162-2021-10-04","text":"Compare with 0.16.1","title":"0.16.2 - 2021-10-04"},{"location":"changelog/#dependencies","text":"Support pymdown-extensions v9.x ( 0831343 by Ofek Lev and 38b22ec by Timoth\u00e9e Mazzucotelli).","title":"Dependencies"},{"location":"changelog/#0161-2021-09-23","text":"Compare with 0.16.0","title":"0.16.1 - 2021-09-23"},{"location":"changelog/#bug-fixes_1","text":"Fix ReadTheDocs \"return\" template ( 598621b by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#0160-2021-09-20","text":"Compare with 0.15.0","title":"0.16.0 - 2021-09-20"},{"location":"changelog/#features_2","text":"Add a rendering option to change the sorting of members ( b1fff8b by Joe Rickerby). Issue #114 , PR #274 Add option to show Python base classes ( 436f550 by Brian Koropoff). Issue #269 , PR #297 Support loading external Python inventories in Sphinx format ( a8418cb by Oleh Prypin). PR #287 Support loading external inventories and linking to them ( 8b675f4 by Oleh Prypin). PR #277 Very basic support for MkDocs theme ( 974ca90 by Oleh Prypin). PR #272 Generate objects inventory ( 14ed959 and bbd85a9 by Timoth\u00e9e Mazzucotelli). Issue #251 , PR #253","title":"Features"},{"location":"changelog/#bug-fixes_2","text":"Don't render empty code blocks for missing type annotations ( d2e9e1e by Oleh Prypin). Fix custom handler not being used ( 6dcf342 by Timoth\u00e9e Mazzucotelli). Issue #259 , PR #263 Don't hide setup_commands errors ( 92418c4 by Gabriel V\u00eejial\u0103). PR #258","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"Move writing extra files to an earlier stage in the build ( 3890ab5 by Oleh Prypin). PR #275","title":"Code Refactoring"},{"location":"changelog/#0152-2021-06-09","text":"Compare with 0.15.1","title":"0.15.2 - 2021-06-09"},{"location":"changelog/#packaging","text":"MkDocs default schema needs to be obtained differently now ( b3e122b by Oleh Prypin). PR #273 Compatibility with MkDocs 1.2: livereload isn't guaranteed now ( 36e8024 by Oleh Prypin). PR #294","title":"Packaging"},{"location":"changelog/#0151-2021-05-16","text":"Compare with 0.15.0","title":"0.15.1 - 2021-05-16"},{"location":"changelog/#bug-fixes_3","text":"Prevent error during parallel installations ( fac2c71 by Timoth\u00e9e Mazzucotelli).","title":"Bug Fixes"},{"location":"changelog/#packaging_1","text":"Support the upcoming major Jinja and MarkupSafe releases ( bb4f9de by Oleh Prypin). PR #283 Accept a higher version of mkdocs-autorefs ( c8de08e by Oleh Prypin). PR #282","title":"Packaging"},{"location":"changelog/#0150-2021-02-28","text":"Compare with 0.14.0","title":"0.15.0 - 2021-02-28"},{"location":"changelog/#breaking-changes","text":"The following items are possible breaking changes: Cross-linking to arbitrary headings now requires to opt-in to the autorefs plugin, which is installed as a dependency of mkdocstrings . See Cross-references to any Markdown heading . mkdocstrings now respects your configured code highlighting method, so if you are using the CodeHilite extension, the .highlight CSS class in the rendered HTML will become .codehilite . So make sure to adapt your extra CSS accordingly. Or just switch to using pymdownx.highlight , it's better supported by mkdocstrings anyway. See Syntax highlighting . Most of the CSS rules that mkdocstrings used to recommend for manual addition, now become mandatory (auto-injected into the site). This shouldn't break any of your styles, but you are welcome to remove the now-redundant lines that you had copied into extra_css , similarly to this diff .","title":"Breaking Changes"},{"location":"changelog/#features_3","text":"Nicer-looking error outputs - no tracebacks from mkdocstrings ( 6baf720 by Oleh Prypin). PR #230 Let handlers add CSS to the pages, do so for Python handler ( 05c7a3f by Oleh Prypin). Issue #189 , PR #218 Allow linking to an object heading not only by its canonical identifier, but also by its possible aliases ( 4789950 by Oleh Prypin). PR #217","title":"Features"},{"location":"changelog/#bug-fixes_4","text":"Propagate the CSS class to inline highlighting as well ( c7d80e6 by Oleh Prypin). PR #245 Don't double-escape characters in highlighted headings ( 6357144 by Oleh Prypin). Issue #228 , PR #241","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_3","text":"Use the autorefs plugin from its new external location ( e2d74ef by Oleh Prypin). PR #235 Split out Markdown extensions from handlers to handlers.rendering ( 7533852 by Oleh Prypin). PR #233 Theme-agnostic code highlighting, respecting configs ( f9ea009 by Oleh Prypin). PR #202 Split out autorefs plugin, make it optional ( fc67656 by Oleh Prypin). PR #220 Remove the extra wrapper div from the final doc ( 7fe438c by Oleh Prypin). PR #209 Don't re-parse the whole subdoc, expose only headings ( 15f84f9 by Oleh Prypin). PR #209 Actually exclude hidden headings from the doc ( 0fdb082 by Oleh Prypin). PR #209","title":"Code Refactoring"},{"location":"changelog/#0140-2021-01-06","text":"Compare with 0.13.6 Special thanks to Oleh @oprypin Prypin who did an amazing job (this is a euphemism) at improving mkdocstrings , fixing hard-to-fix bugs with clever solutions, implementing great new features and refactoring the code for better performance and readability! Thanks Oleh!","title":"0.14.0 - 2021-01-06"},{"location":"changelog/#bug-fixes_5","text":"Fix double code tags ( e84d401 by Timoth\u00e9e Mazzucotelli). Don't mutate the original Markdown config for permalinks ( 8f6b163 by Oleh Prypin). Preserve text immediately before an autodoc ( 07466fa by Oleh Prypin). PR #207 Remove href attributes from headings in templates ( d5602ff by Oleh Prypin). PR #204 Don't let toc extension append its permalink twice ( a154f5c by Oleh Prypin). PR #203 Fix undefined entity for &para; ( 2c29211 by Timoth\u00e9e Mazzucotelli). Make ids of Markdown sub-documents prefixed with the parent item id ( d493d33 by Oleh Prypin). Issue #186 and #193 , PR #199 More lenient regex for data-mkdocstrings-identifier ( dcfec8e by Oleh Prypin). Shift Markdown headings according to the current heading_level ( 13f41ae by Oleh Prypin). Issue #192 , PR #195 Fix footnotes appearing in all following objects ( af24bc2 by Oleh Prypin). Issue #186 , PR #195 Fix cross-references from the root index page ( 9c9f2a0 by Oleh Prypin). Issue #184 , PR #185 Fix incorrect argument name passed to Markdown ( 10ce502 by Timoth\u00e9e Mazzucotelli). Fix error when a digit immediately follows a code tag ( 9b92341 by Oleh Prypin). Issue #169 , PR #175 Detecting paths relative to template directory in logging ( a50046b by Oleh Prypin). Issue #166","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_4","text":"BlockProcessor already receives strings, use them as such ( bcf7da9 by Oleh Prypin). Remove some unused code ( 8504084 by Oleh Prypin). PR #206 Improve XML parsing error handling ( ad86410 by Timoth\u00e9e Mazzucotelli). Explicitly use MarkupSafe ( 6b9ebe7 by Oleh Prypin). Split out the handler cache, expose it through the plugin ( 6453026 by Oleh Prypin). Issue #179 , PR #191 Use ChainMap instead of copying dicts ( c634d2c by Oleh Prypin). PR #171 Rename logging to loggers to avoid confusion ( 7a119cc by Timoth\u00e9e Mazzucotelli). Simplify logging ( 409f93e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_4","text":"Allow specifying heading_level as a Markdown heading ( 10efc28 by Oleh Prypin). PR #170 Allow any characters in identifiers ( 7ede68a by Oleh Prypin). PR #174 Allow namespace packages for handlers ( 39b0465 by Timoth\u00e9e Mazzucotelli). Add template debugging/logging ( 33b32c1 by Timoth\u00e9e Mazzucotelli). Add initial support for the ReadTheDocs theme ( 1028115 by Timoth\u00e9e Mazzucotelli). Issue #107 , PR #159 Add option to show type annotations in signatures ( f94ce9b by Timoth\u00e9e Mazzucotelli). Issue #106","title":"Features"},{"location":"changelog/#packaging_2","text":"Accept verions of pytkdocs up to 0.10.x (see changelog ).","title":"Packaging"},{"location":"changelog/#performance-improvements","text":"Call update_env only once per Markdown instance ( b198c74 by Oleh Prypin). PR #201 Disable Jinja's auto_reload to reduce disk reads ( 3b28c58 by Oleh Prypin). PR #200 Rework autorefs replacement to not re-parse the final HTML ( 22a9e4b by Oleh Prypin). Issue #187 , PR #188","title":"Performance Improvements"},{"location":"changelog/#0136-2020-09-28","text":"Compare with 0.13.5","title":"0.13.6 - 2020-09-28"},{"location":"changelog/#bug-fixes_6","text":"Fix rendering when clicking on hidden toc entries ( 2af4d31 by Timoth\u00e9e Mazzucotelli). Issue #60 .","title":"Bug Fixes"},{"location":"changelog/#0135-2020-09-28","text":"Compare with 0.13.4","title":"0.13.5 - 2020-09-28"},{"location":"changelog/#packaging_3","text":"Accept pytkdocs version up to 0.9.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0134-2020-09-25","text":"Compare with 0.13.3","title":"0.13.4 - 2020-09-25"},{"location":"changelog/#bug-fixes_7","text":"Bring back arbitrary **config to Python handler ( fca7d4c by Florimond Manca). Issue #154 , PR #155","title":"Bug Fixes"},{"location":"changelog/#0133-2020-09-25","text":"Compare with 0.13.2","title":"0.13.3 - 2020-09-25"},{"location":"changelog/#packaging_4","text":"Accept pytkdocs version up to 0.8.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0132-2020-09-08","text":"Compare with 0.13.1","title":"0.13.2 - 2020-09-08"},{"location":"changelog/#bug-fixes_8","text":"Fix relative URLs when use_directory_urls is false ( 421d189 by Timoth\u00e9e Mazzucotelli). References: #149","title":"Bug Fixes"},{"location":"changelog/#0131-2020-09-03","text":"Compare with 0.13.0","title":"0.13.1 - 2020-09-03"},{"location":"changelog/#bug-fixes_9","text":"Use relative links for cross-references ( 9c77f1f by Timoth\u00e9e Mazzucotelli). References: #144 , #147","title":"Bug Fixes"},{"location":"changelog/#0130-2020-08-21","text":"Compare with 0.12.2","title":"0.13.0 - 2020-08-21"},{"location":"changelog/#bug-fixes_10","text":"Accept dashes in module names ( fcf79d0 by Timoth\u00e9e Mazzucotelli). References: #140","title":"Bug Fixes"},{"location":"changelog/#features_5","text":"Add option to show full path of direct members only ( d1b9401 by Aaron Dunmore). References: #134 , #136","title":"Features"},{"location":"changelog/#packaging_5","text":"Accept pymdown-extensions versions up to 0.8.x ( see release notes ) ( 178d48d by Hugo van Kemenade). PR #146","title":"Packaging"},{"location":"changelog/#0122-2020-07-24","text":"Compare with 0.12.1","title":"0.12.2 - 2020-07-24"},{"location":"changelog/#packaging_6","text":"Accept pytkdocs version up to 0.7.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0121-2020-07-07","text":"Compare with 0.12.0","title":"0.12.1 - 2020-07-07"},{"location":"changelog/#bug-fixes_11","text":"Fix HTML-escaped sequence parsing as XML ( db297f1 by Timoth\u00e9e Mazzucotelli). Allow running mkdocs from non-default interpreter ( 283dd7b by Jared Khan).","title":"Bug Fixes"},{"location":"changelog/#0120-2020-06-14","text":"Compare with 0.11.4","title":"0.12.0 - 2020-06-14"},{"location":"changelog/#features_6","text":"Support attributes section in Google-style docstrings ( 8300253 by Timoth\u00e9e Mazzucotelli). References: #88 Support examples section in Google-style docstrings ( 650c754 by Iago Gonz\u00e1lez). References: #112","title":"Features"},{"location":"changelog/#packaging_7","text":"Accept pytkdocs version up to 0.6.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0114-2020-06-08","text":"Compare with 0.11.3","title":"0.11.4 - 2020-06-08"},{"location":"changelog/#packaging_8","text":"Accept pytkdocs version up to 0.5.x ( changelog ). If it breaks your docs, please open issues on pytkdocs ' bug-tracker , or pin pytkdocs version to while waiting for bug fixes <0.5.0 .","title":"Packaging"},{"location":"changelog/#0113-2020-06-07","text":"Compare with 0.11.2","title":"0.11.3 - 2020-06-07"},{"location":"changelog/#bug-fixes_12","text":"Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121","title":"Bug Fixes"},{"location":"changelog/#0112-2020-05-20","text":"Compare with 0.11.1","title":"0.11.2 - 2020-05-20"},{"location":"changelog/#packaging_9","text":"Increase pytkdocs version range to accept 0.4.0 ( changelog ).","title":"Packaging"},{"location":"changelog/#0111-2020-05-14","text":"Compare with 0.11.0","title":"0.11.1 - 2020-05-14"},{"location":"changelog/#bug-fixes_13","text":"Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103","title":"Bug Fixes"},{"location":"changelog/#0110-2020-04-23","text":"Compare with 0.10.3","title":"0.11.0 - 2020-04-23"},{"location":"changelog/#bug-fixes_14","text":"Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86","title":"Bug Fixes"},{"location":"changelog/#features_7","text":"Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82","title":"Features"},{"location":"changelog/#0103-2020-04-10","text":"Compare with 0.10.2","title":"0.10.3 - 2020-04-10"},{"location":"changelog/#bug-fixes_15","text":"Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77","title":"Bug Fixes"},{"location":"changelog/#packaging_10","text":"This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs","title":"Packaging"},{"location":"changelog/#0102-2020-04-07","text":"Compare with 0.10.1","title":"0.10.2 - 2020-04-07"},{"location":"changelog/#packaging_11","text":"This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 .","title":"Packaging"},{"location":"changelog/#0101-2020-04-03","text":"Compare with 0.10.0","title":"0.10.1 - 2020-04-03"},{"location":"changelog/#bug-fixes_16","text":"Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68","title":"Bug Fixes"},{"location":"changelog/#0100-2020-03-27","text":"Compare with 0.9.1","title":"0.10.0 - 2020-03-27"},{"location":"changelog/#features_8","text":"Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector .","title":"Features"},{"location":"changelog/#091-2020-03-21","text":"Compare with 0.9.0","title":"0.9.1 - 2020-03-21"},{"location":"changelog/#bug-fixes_17","text":"Fix cross-references when deploying to GitHub pages ( 36f804b ).","title":"Bug fixes"},{"location":"changelog/#090-2020-03-21","text":"Compare with 0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users.","title":"0.9.0 - 2020-03-21"},{"location":"changelog/#features_9","text":"Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting.","title":"Features"},{"location":"changelog/#bug-fixes_18","text":"Various fixes and better error handling.","title":"Bug fixes"},{"location":"changelog/#080-2020-03-04","text":"Compare with 0.7.2","title":"0.8.0 - 2020-03-04"},{"location":"changelog/#breaking-changes_1","text":"Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2.","title":"Breaking Changes"},{"location":"changelog/#072-2020-03-04","text":"Compare with 0.7.1","title":"0.7.2 - 2020-03-04"},{"location":"changelog/#bug-fixes_19","text":"Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ).","title":"Bug Fixes"},{"location":"changelog/#071-2020-02-18","text":"Compare with 0.7.0","title":"0.7.1 - 2020-02-18"},{"location":"changelog/#bug-fixes_20","text":"Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ).","title":"Bug Fixes"},{"location":"changelog/#070-2020-01-13","text":"Compare with 0.6.1","title":"0.7.0 - 2020-01-13"},{"location":"changelog/#bug-fixes_21","text":"Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_5","text":"Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ).","title":"Code Refactoring"},{"location":"changelog/#features_10","text":"Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ).","title":"Features"},{"location":"changelog/#061-2020-01-02","text":"Compare with 0.6.0","title":"0.6.1 - 2020-01-02"},{"location":"changelog/#bug-fixes_22","text":"Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_6","text":"Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ).","title":"Code Refactoring"},{"location":"changelog/#060-2019-12-28","text":"Compare with 0.5.0","title":"0.6.0 - 2019-12-28"},{"location":"changelog/#bug-fixes_23","text":"Fix GenericMeta import error on Python 3.7+ ( febf2b9 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_7","text":"More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ).","title":"Code Refactoring"},{"location":"changelog/#050-2019-12-22","text":"Compare with 0.4.0","title":"0.5.0 - 2019-12-22"},{"location":"changelog/#features_11","text":"Use divs in HTML contents to ease styling ( 2a36a0e ).","title":"Features"},{"location":"changelog/#040-2019-12-22","text":"Compare with 0.3.0","title":"0.4.0 - 2019-12-22"},{"location":"changelog/#features_12","text":"Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ).","title":"Features"},{"location":"changelog/#030-2019-12-21","text":"Compare with 0.2.0","title":"0.3.0 - 2019-12-21"},{"location":"changelog/#features_13","text":"Allow object referencing in docstrings ( 2dd50c0 ).","title":"Features"},{"location":"changelog/#020-2019-12-15","text":"Compare with 0.1.0","title":"0.2.0 - 2019-12-15"},{"location":"changelog/#misc","text":"Refactor, features, etc. ( 111fa85 ).","title":"Misc"},{"location":"changelog/#010-2019-12-12","text":"Compare with first commit","title":"0.1.0 - 2019-12-12"},{"location":"changelog/#misc_1","text":"Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Misc"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build mkdocstrings . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 autoflake | black | darglint | docutils | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | jinja2 | markdown | markupsafe | mkdocs | mkdocs-autorefs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings-crystal | mkdocstrings-python | mkdocstrings-python-legacy | mypy | pep8-naming | pygments | pymdown-extensions | pytest | pytest-cov | pytest-randomly | pytest-xdist | safety | sphinx | toml | types-docutils | types-markdown | types-pyyaml | types-toml | wps-light Indirect dependencies \u00a4 alabaster | ansimarkup | astor | astunparse | atomicwrites | attrs | babel | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | griffe | idna | imagesize | importlib-metadata | iniconfig | markdown-callouts | mccabe | mergedeep | mkdocs-material-extensions | mkdocstrings | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pyparsing | pytest-forked | python-dateutil | pytkdocs | pytz | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | sphinxcontrib-applehelp | sphinxcontrib-devhelp | sphinxcontrib-htmlhelp | sphinxcontrib-jsmath | sphinxcontrib-qthelp | sphinxcontrib-serializinghtml | stevedore | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"autoflake | black | darglint | docutils | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | jinja2 | markdown | markupsafe | mkdocs | mkdocs-autorefs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings-crystal | mkdocstrings-python | mkdocstrings-python-legacy | mypy | pep8-naming | pygments | pymdown-extensions | pytest | pytest-cov | pytest-randomly | pytest-xdist | safety | sphinx | toml | types-docutils | types-markdown | types-pyyaml | types-toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"alabaster | ansimarkup | astor | astunparse | atomicwrites | attrs | babel | bandit | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | griffe | idna | imagesize | importlib-metadata | iniconfig | markdown-callouts | mccabe | mergedeep | mkdocs-material-extensions | mkdocstrings | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pyparsing | pytest-forked | python-dateutil | pytkdocs | pytz | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | sphinxcontrib-applehelp | sphinxcontrib-devhelp | sphinxcontrib-htmlhelp | sphinxcontrib-jsmath | sphinxcontrib-qthelp | sphinxcontrib-serializinghtml | stevedore | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2019, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"theming/","text":"Themes \u00a4 mkdocstrings can support multiple MkDocs themes. It currently supports the Material for MkDocs theme and, partially, the built-in ReadTheDocs theme. Each renderer can fallback to a particular theme when the user selected theme is not supported. For example, the Python renderer will fallback to the Material for MkDocs templates. Customization \u00a4 There is some degree of customization possible in mkdocstrings . First, you can write custom templates to override the theme templates. Second, the provided templates make use of CSS classes, so you can tweak the look and feel with extra CSS rules. Templates \u00a4 To use custom templates and override the theme ones, specify the relative path to your templates directory with the custom_templates global configuration option: mkdocs.yml plugins : - mkdocstrings : custom_templates : templates You directory structure must be identical to the provided templates one: templates \u251c\u2500\u2574<HANDLER 1> \u2502 \u251c\u2500\u2500 <THEME 1> \u2502 \u2514\u2500\u2500 <THEME 2> \u2514\u2500\u2500 <HANDLER 2> \u251c\u2500\u2500 <THEME 1> \u2514\u2500\u2500 <THEME 2> ( Check out the template tree on GitHub ) You don't have to replicate the whole tree, only the handlers, themes or templates you want to override. For example, to override some templates of the Material theme for Python: templates \u2514\u2500\u2500 python \u2514\u2500\u2500 material \u251c\u2500\u2500 parameters.html \u2514\u2500\u2500 exceptions.html In the HTML files, replace the original contents with your modified version. In the future, the templates will use Jinja blocks, so it will be easier to modify a small part of the template without copy-pasting the whole file. The Material theme provides the following template structure: children.html : where the recursion happen, to render all children of an object attribute.html : to render attributes (class-attributes, etc.) class.html : to render classes function.html : to render functions method.html : to render methods module.html : to render modules docstring.html : to render docstrings attributes.html : to render attributes sections of docstrings examples.html : to render examples sections of docstrings exceptions.html : to render exceptions/\"raises\" sections of docstrings parameters.html : to render parameters/arguments sections of docstrings return.html : to render \"return\" sections of docstrings properties.html : to render the properties of an object ( staticmethod , read-only , etc.) signature.html : to render functions and methods signatures Debugging \u00a4 Every template has access to a log function, allowing to log messages as usual: {{ log.debug ( \"A DEBUG message.\" ) }} {{ log.info ( \"An INFO message.\" ) }} {{ log.warning ( \"A WARNING message.\" ) }} {{ log.error ( \"An ERROR message.\" ) }} {{ log.critical ( \"A CRITICAL message.\" ) }} CSS classes \u00a4 The Material theme uses the following CSS classes in the HTML: doc : on all the following elements doc-children : on div s containing the children of an object doc-object : on div s containing an object doc-attribute : on div s containing an attribute doc-class : on div s containing a class doc-function : on div s containing a function doc-method : on div s containing a method doc-module : on div s containing a module doc-heading : on objects headings doc-contents : on div s wrapping the docstring then the children (if any) first : same, but only on the root object's contents div doc-properties : on span s wrapping the object's properties doc-property : on small elements containing a property doc-property-PROPERTY : same, where PROPERTY is replaced by the actual property Example with colorful properties CSS Result . doc-property { border-radius : 15 px ; padding : 0 5 px ; } . doc-property-special { background-color : blue ; color : white ; } . doc-property-private { background-color : red ; color : white ; } . doc-property-property { background-color : green ; color : white ; } . doc-property-read-only { background-color : yellow ; color : black ; } .prop { border-radius: 15px; padding: 0 5px; } special private property read-only As you can see, CSS is not my field of predilection... Syntax highlighting \u00a4 Code blocks that occur in the docstring of an item inserted with mkdocstrings , as well as code blocks (such as Source code ) that mkdocstrings inserts itself, are syntax-highlighted according to the same rules as other normal code blocks in your document. See more details in mkdocstrings.handlers.rendering.Highlighter . As for the CSS class used for code blocks -- it will also match the \"normal\" config, so the default ( .codehilite or .highlight ) will match your chosen Markdown extension for highlighting. Changed in version 0.15 The CSS class used to always be .highlight , but now it depends on the configuration. Long story short, you probably should add pymdownx.highlight to your markdown_extensions , and then use .doc-contents .highlight as the CSS selector in case you want to change something about mkdocstrings' code blocks specifically.","title":"Theming"},{"location":"theming/#themes","text":"mkdocstrings can support multiple MkDocs themes. It currently supports the Material for MkDocs theme and, partially, the built-in ReadTheDocs theme. Each renderer can fallback to a particular theme when the user selected theme is not supported. For example, the Python renderer will fallback to the Material for MkDocs templates.","title":"Themes"},{"location":"theming/#customization","text":"There is some degree of customization possible in mkdocstrings . First, you can write custom templates to override the theme templates. Second, the provided templates make use of CSS classes, so you can tweak the look and feel with extra CSS rules.","title":"Customization"},{"location":"theming/#templates","text":"To use custom templates and override the theme ones, specify the relative path to your templates directory with the custom_templates global configuration option: mkdocs.yml plugins : - mkdocstrings : custom_templates : templates You directory structure must be identical to the provided templates one: templates \u251c\u2500\u2574<HANDLER 1> \u2502 \u251c\u2500\u2500 <THEME 1> \u2502 \u2514\u2500\u2500 <THEME 2> \u2514\u2500\u2500 <HANDLER 2> \u251c\u2500\u2500 <THEME 1> \u2514\u2500\u2500 <THEME 2> ( Check out the template tree on GitHub ) You don't have to replicate the whole tree, only the handlers, themes or templates you want to override. For example, to override some templates of the Material theme for Python: templates \u2514\u2500\u2500 python \u2514\u2500\u2500 material \u251c\u2500\u2500 parameters.html \u2514\u2500\u2500 exceptions.html In the HTML files, replace the original contents with your modified version. In the future, the templates will use Jinja blocks, so it will be easier to modify a small part of the template without copy-pasting the whole file. The Material theme provides the following template structure: children.html : where the recursion happen, to render all children of an object attribute.html : to render attributes (class-attributes, etc.) class.html : to render classes function.html : to render functions method.html : to render methods module.html : to render modules docstring.html : to render docstrings attributes.html : to render attributes sections of docstrings examples.html : to render examples sections of docstrings exceptions.html : to render exceptions/\"raises\" sections of docstrings parameters.html : to render parameters/arguments sections of docstrings return.html : to render \"return\" sections of docstrings properties.html : to render the properties of an object ( staticmethod , read-only , etc.) signature.html : to render functions and methods signatures","title":"Templates"},{"location":"theming/#debugging","text":"Every template has access to a log function, allowing to log messages as usual: {{ log.debug ( \"A DEBUG message.\" ) }} {{ log.info ( \"An INFO message.\" ) }} {{ log.warning ( \"A WARNING message.\" ) }} {{ log.error ( \"An ERROR message.\" ) }} {{ log.critical ( \"A CRITICAL message.\" ) }}","title":"Debugging"},{"location":"theming/#css-classes","text":"The Material theme uses the following CSS classes in the HTML: doc : on all the following elements doc-children : on div s containing the children of an object doc-object : on div s containing an object doc-attribute : on div s containing an attribute doc-class : on div s containing a class doc-function : on div s containing a function doc-method : on div s containing a method doc-module : on div s containing a module doc-heading : on objects headings doc-contents : on div s wrapping the docstring then the children (if any) first : same, but only on the root object's contents div doc-properties : on span s wrapping the object's properties doc-property : on small elements containing a property doc-property-PROPERTY : same, where PROPERTY is replaced by the actual property Example with colorful properties CSS Result . doc-property { border-radius : 15 px ; padding : 0 5 px ; } . doc-property-special { background-color : blue ; color : white ; } . doc-property-private { background-color : red ; color : white ; } . doc-property-property { background-color : green ; color : white ; } . doc-property-read-only { background-color : yellow ; color : black ; } .prop { border-radius: 15px; padding: 0 5px; }","title":"CSS classes"},{"location":"theming/#syntax-highlighting","text":"Code blocks that occur in the docstring of an item inserted with mkdocstrings , as well as code blocks (such as Source code ) that mkdocstrings inserts itself, are syntax-highlighted according to the same rules as other normal code blocks in your document. See more details in mkdocstrings.handlers.rendering.Highlighter . As for the CSS class used for code blocks -- it will also match the \"normal\" config, so the default ( .codehilite or .highlight ) will match your chosen Markdown extension for highlighting. Changed in version 0.15 The CSS class used to always be .highlight , but now it depends on the configuration. Long story short, you probably should add pymdownx.highlight to your markdown_extensions , and then use .doc-contents .highlight as the CSS selector in case you want to change something about mkdocstrings' code blocks specifically.","title":"Syntax highlighting"},{"location":"troubleshooting/","text":"Troubleshooting \u00a4 Code blocks in admonitions (in docstrings or else) are not rendered correctly \u00a4 To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences Footnotes are duplicated or overridden \u00a4 Before version 0.14, footnotes could be duplicated over a page. Please upgrade to version 0.14 or higher. See also: Issue #186 Tabs in docstrings (from pymdownx.tabbed ) are not working properly . MkDocs warns me about links to unfound documentation files \u00a4 A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] . Some objects are not rendered (they do not appear in the generated docs) \u00a4 Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the supported docstring styles page. Re-run the Mkdocs command with -v , and carefully read any traceback. Tabs in docstrings (from pymdownx.tabbed ) are not working properly \u00a4 Before version 0.14, multiple tab blocks injected on the same page would result in broken links: clicking on a tab would bring the user to the wrong one. Please upgrade to version 0.14 or higher. See also: Issue #193 Footnotes are duplicated or overridden . If you are stuck on a version before 0.14, and want to use multiple tab blocks in one page, use this workaround. JavaScript workaround Put the following code in a .js file, and list it in MkDocs' extra_javascript : // Credits to Nikolaos Zioulis (@zuru on GitHub) function setID (){ var tabs = document . getElementsByClassName ( \"tabbed-set\" ); for ( var i = 0 ; i < tabs . length ; i ++ ) { children = tabs [ i ]. children ; var counter = 0 ; var iscontent = 0 ; for ( var j = 0 ; j < children . length ; j ++ ){ if ( typeof children [ j ]. htmlFor === 'undefined' ){ if (( iscontent + 1 ) % 2 == 0 ){ // check if it is content if ( iscontent == 1 ){ btn = children [ j ]. childNodes [ 1 ]. getElementsByTagName ( \"button\" ); } } else { // if not change the id children [ j ]. id = \"__tabbed_\" + String ( i + 1 ) + \"_\" + String ( counter + 1 ); children [ j ]. name = \"__tabbed_\" + String ( i + 1 ); // make default tab open if ( j == 0 ) children [ j ]. click (); } iscontent ++ ; } else { // link to the correct tab children [ j ]. htmlFor = \"__tabbed_\" + String ( i + 1 ) + \"_\" + String ( counter + 1 ); counter ++ ; } } } } setID (); This code will correctly reset the IDs for tabs on a same page. The generated documentation does not look good \u00a4 Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Note that you can always customize the look of mkdocstrings blocks -- through both HTML and CSS. Warning: could not find cross-reference target \u00a4 New in version 0.15 Cross-linking used to include any Markdown heading, but now it's only for mkdocstrings identifiers by default. See Cross-references to any Markdown heading to opt back in. Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it. Python specifics \u00a4 Nothing is rendered at all \u00a4 Is your package available in the Python path? See Python handler: Finding modules . LaTeX in docstrings is not rendered correctly \u00a4 If you are using a Markdown extension like Arithmatex Mathjax or markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\" My docstrings in comments ( #: ) are not picked up \u00a4 It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. You can use: import enum class MyEnum ( enum . Enum ): \"\"\"My enum. Attributes: v1: The first choice. v2: The second choice. \"\"\" v1 = 1 v2 = 2 Or: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" My wrapped function shows documentation/code for its wrapper instead of its own \u00a4 Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#code-blocks-in-admonitions-in-docstrings-or-else-are-not-rendered-correctly","text":"To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences","title":"Code blocks in admonitions (in docstrings or else) are not rendered correctly"},{"location":"troubleshooting/#footnotes-are-duplicated-or-overridden","text":"Before version 0.14, footnotes could be duplicated over a page. Please upgrade to version 0.14 or higher. See also: Issue #186 Tabs in docstrings (from pymdownx.tabbed ) are not working properly .","title":"Footnotes are duplicated or overridden"},{"location":"troubleshooting/#mkdocs-warns-me-about-links-to-unfound-documentation-files","text":"A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] .","title":"MkDocs warns me about links to unfound documentation files"},{"location":"troubleshooting/#some-objects-are-not-rendered-they-do-not-appear-in-the-generated-docs","text":"Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the supported docstring styles page. Re-run the Mkdocs command with -v , and carefully read any traceback.","title":"Some objects are not rendered (they do not appear in the generated docs)"},{"location":"troubleshooting/#tabs-in-docstrings-from-pymdownxtabbed-are-not-working-properly","text":"Before version 0.14, multiple tab blocks injected on the same page would result in broken links: clicking on a tab would bring the user to the wrong one. Please upgrade to version 0.14 or higher. See also: Issue #193 Footnotes are duplicated or overridden . If you are stuck on a version before 0.14, and want to use multiple tab blocks in one page, use this workaround. JavaScript workaround Put the following code in a .js file, and list it in MkDocs' extra_javascript : // Credits to Nikolaos Zioulis (@zuru on GitHub) function setID (){ var tabs = document . getElementsByClassName ( \"tabbed-set\" ); for ( var i = 0 ; i < tabs . length ; i ++ ) { children = tabs [ i ]. children ; var counter = 0 ; var iscontent = 0 ; for ( var j = 0 ; j < children . length ; j ++ ){ if ( typeof children [ j ]. htmlFor === 'undefined' ){ if (( iscontent + 1 ) % 2 == 0 ){ // check if it is content if ( iscontent == 1 ){ btn = children [ j ]. childNodes [ 1 ]. getElementsByTagName ( \"button\" ); } } else { // if not change the id children [ j ]. id = \"__tabbed_\" + String ( i + 1 ) + \"_\" + String ( counter + 1 ); children [ j ]. name = \"__tabbed_\" + String ( i + 1 ); // make default tab open if ( j == 0 ) children [ j ]. click (); } iscontent ++ ; } else { // link to the correct tab children [ j ]. htmlFor = \"__tabbed_\" + String ( i + 1 ) + \"_\" + String ( counter + 1 ); counter ++ ; } } } } setID (); This code will correctly reset the IDs for tabs on a same page.","title":"Tabs in docstrings (from pymdownx.tabbed) are not working properly"},{"location":"troubleshooting/#the-generated-documentation-does-not-look-good","text":"Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Note that you can always customize the look of mkdocstrings blocks -- through both HTML and CSS.","title":"The generated documentation does not look good"},{"location":"troubleshooting/#warning-could-not-find-cross-reference-target","text":"New in version 0.15 Cross-linking used to include any Markdown heading, but now it's only for mkdocstrings identifiers by default. See Cross-references to any Markdown heading to opt back in. Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it.","title":"Warning: could not find cross-reference target"},{"location":"troubleshooting/#python-specifics","text":"","title":"Python specifics"},{"location":"troubleshooting/#nothing-is-rendered-at-all","text":"Is your package available in the Python path? See Python handler: Finding modules .","title":"Nothing is rendered at all"},{"location":"troubleshooting/#latex-in-docstrings-is-not-rendered-correctly","text":"If you are using a Markdown extension like Arithmatex Mathjax or markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\"","title":"LaTeX in docstrings is not rendered correctly"},{"location":"troubleshooting/#my-docstrings-in-comments-are-not-picked-up","text":"It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. You can use: import enum class MyEnum ( enum . Enum ): \"\"\"My enum. Attributes: v1: The first choice. v2: The second choice. \"\"\" v1 = 1 v2 = 2 Or: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\"","title":"My docstrings in comments (#:) are not picked up"},{"location":"troubleshooting/#my-wrapped-function-shows-documentationcode-for-its-wrapper-instead-of-its-own","text":"Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"My wrapped function shows documentation/code for its wrapper instead of its own"},{"location":"usage/","text":"Usage \u00a4 Autodoc syntax \u00a4 mkdocstrings works by processing special expressions in your Markdown files. The syntax is as follows: ::: identifier YAML block Resources on YAML YAML can sometimes be a bit tricky, particularly on indentation. Here are some resources that other users found useful to better understand YAML's peculiarities. YAML idiosyncrasies YAML multiline The identifier is a string identifying the object you want to document. The format of an identifier can vary from one handler to another. For example, the Python handler expects the full dotted-path to a Python object: my_package.my_module.MyClass.my_method . The YAML block is optional, and contains some configuration options: handler : the name of the handler to use to collect and render this object. By default, it will use the value defined in the Global options 's default_handler key, or \"python\" . selection : a dictionary of options passed to the handler's collector. The collector is responsible for collecting the documentation from the source code. Therefore, selection options change how the documentation is collected from the source code. rendering : a dictionary of options passed to the handler's renderer. The renderer is responsible for rendering the documentation with Jinja2 templates. Therefore, rendering options affect how the selected object's documentation is rendered. Every handler accepts at least these two keys, selection and rendering , and some handlers accept additional keys. Check the documentation for your handler of interest in Handlers . Example with the Python handler docs/my_page.md mkdocs.yml src/my_package/my_module.py Result # Documentation for `MyClass` ::: my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false nav : - \"My page\" : my_page.md class MyClass : \"\"\"Print print print!\"\"\" def method_a ( self ): \"\"\"Print A!\"\"\" print ( \"A!\" ) def method_b ( self ): \"\"\"Print B!\"\"\" print ( \"B!\" ) def method_c ( self ): \"\"\"Print C!\"\"\" print ( \"C!\" ) Documentation for MyClass Print print print! method_a ( self ) Print A! method_b ( self ) Print B! It is also possible to integrate a mkdocstrings identifier into a Markdown header: ## ::: my_package.my_module.MyClass rendering: show_source: false The above is equivalent to: ::: my_package.my_module.MyClass rendering: show_source: false heading_level: 2 Global options \u00a4 mkdocstrings accepts a few top-level configuration options in mkdocs.yml : watch : a list of directories to watch while serving the documentation. See Watch directories . default_handler : the handler that is used by default when no handler is specified. custom_templates : the path to a directory containing custom templates. The path is relative to the docs directory. See Theming . handlers : the handlers global configuration. enable_inventory : whether to enable inventory file generation. See Cross-references to other projects / inventories Example: mkdocs.yml plugins : - mkdocstrings : default_handler : python handlers : python : rendering : show_source : false custom_templates : templates watch : - src/my_package The handlers global configuration can then be overridden by local configurations: :: : my_package.my_module.MyClass rendering : show_source : true Cross-references \u00a4 Cross-references are written as Markdown reference-style links: Markdown HTML Result With a custom title: [ `Object 1` ][full.path.object1] With the identifier as title: [ full.path.object2 ][] < p > With a custom title: < a href = \"https://example.com/page1#full.path.object1\" >< code > Object 1 </ code ></ a >< p > < p > With the identifier as title: < a href = \"https://example.com/page2#full.path.object2\" > full.path.object2 </ a ></ p > Any item that was inserted using the autodoc syntax (e.g. ::: full.path.object1 ) is possible to link to by using the same identifier with the cross-reference syntax ( [example][full.path.object1] ). But the cross-references are also applicable to the items' children that get pulled in. Finding out the anchor \u00a4 If you're not sure which exact identifier a doc item uses, you can look at its \"anchor\", which your Web browser will show in the URL bar when clicking an item's entry in the table of contents. If the URL is https://example.com/some/page.html#full.path.object1 then you know that this item is possible to link to with [example][full.path.object1] , regardless of the current page. Cross-references to any Markdown heading \u00a4 Changed in version 0.15 Linking to any Markdown heading used to be the default, but now opt-in is required. If you want to link to any Markdown heading, not just mkdocstrings -inserted items, please enable the autorefs plugin for MkDocs by adding autorefs to plugins : mkdocs.yml plugins : - admonition - search - autorefs - mkdocstrings : [ ... ] Note that you don't need to ( pip ) install anything more; this plugin is guaranteed to be pulled in with mkdocstrings . Example doc1.md doc2.md Result HTML for doc2 ## Hello, world! Testing ## Something else Please see the [ Hello, World! ][ hello-world ] section. < p > Please see the < a href = \"doc1.html#hello-world\" > Hello, World! </ a > section. </ p > Cross-references to a sub-heading in a docstring \u00a4 New in version 0.14 If you have a Markdown heading inside your docstring, you can also link directly to it. In the example below you see the identifier to be linked is foo.bar--tips , because it's the \"Tips\" heading that's part of the foo.bar object, joined with \" -- \". Example foo.py doc1.md doc2.md Result HTML for doc2 def bar (): \"\"\"Hello, world! # Tips - Stay hydrated. \"\"\" ::: foo.bar Check out the [ tips ][ foo.bar--tips ] < p > Check out the < a href = \"doc1.html#foo.bar--tips\" > tips </ a ></ p > The above tip about Finding out the anchor also applies the same way here. You may also notice that such a heading does not get rendered as a <h1> element directly, but rather the level gets shifted to fit the encompassing document structure. If you're curious about the implementation, check out mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor and others. Cross-references to other projects / inventories \u00a4 New in version 0.16. Python developers coming from Sphinx might know about its intersphinx extension, that allows to cross-reference items between several projects. mkdocstrings has a similar feature. To reference an item from another project, you must first tell mkdocstrings to load the inventory it provides. Each handler will be responsible of loading inventories specific to its language. For example, the Python handler can load Sphinx-generated inventories ( objects.inv ). In the following snippet, we load the inventory provided by requests : plugins : - mkdocstrings : handlers : python : import : - https://docs.python-requests.org/en/master/objects.inv Now it is possible to cross-reference requests ' items! For example: Markdown Result (HTML) Result (displayed) See [ requests.request ][] to know what parameters you can pass. < p > See < a href = \"https://docs.python-requests.org/en/latest/api/#requests.request\" > requests.request </ a > to know what parameters you can pass. </ p > See requests.request to know what parameters you can pass. You can of course select another version of the inventory, for example: plugins : - mkdocstrings : handlers : python : import : - https://docs.python-requests.org/en/v3.0.0/objects.inv In case the inventory file is not served under the base documentation URL, you can explicitly specify both URLs: plugins : - mkdocstrings : handlers : python : import : - url : https://cdn.example.com/version/objects.inv base_url : https://docs.example.com/version Absolute URLs to cross-referenced items will then be based on https://docs.example.com/version/ instead of https://cdn.example.com/version/ . Reciprocally, mkdocstrings also allows to generate an inventory file in the Sphinx format. It will be enabled by default if the Python handler is used, and generated as objects.inv in the final site directory. Other projects will be able to cross-reference items from your project! To explicitely enable or disable the generation of the inventory file, use the global enable_inventory option: plugins : - mkdocstrings : enable_inventory : false Watch directories \u00a4 You can add directories to watch with the watch key. It accepts a list of paths. mkdocs.yml plugins : - mkdocstrings : watch : - src/my_package_1 - src/my_package_2 When serving your documentation and a change occur in one of the listed path, MkDocs will rebuild the site and reload the current page. The watch feature doesn't have special effects. Adding directories to the watch list doesn't have any other effect than watching for changes. For example, it will not tell the Python handler to look for packages in these paths (the paths are not added to the PYTHONPATH variable). If you want to tell Python where to look for packages and modules, see Python Handler: Finding modules .","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#autodoc-syntax","text":"mkdocstrings works by processing special expressions in your Markdown files. The syntax is as follows: ::: identifier YAML block Resources on YAML YAML can sometimes be a bit tricky, particularly on indentation. Here are some resources that other users found useful to better understand YAML's peculiarities. YAML idiosyncrasies YAML multiline The identifier is a string identifying the object you want to document. The format of an identifier can vary from one handler to another. For example, the Python handler expects the full dotted-path to a Python object: my_package.my_module.MyClass.my_method . The YAML block is optional, and contains some configuration options: handler : the name of the handler to use to collect and render this object. By default, it will use the value defined in the Global options 's default_handler key, or \"python\" . selection : a dictionary of options passed to the handler's collector. The collector is responsible for collecting the documentation from the source code. Therefore, selection options change how the documentation is collected from the source code. rendering : a dictionary of options passed to the handler's renderer. The renderer is responsible for rendering the documentation with Jinja2 templates. Therefore, rendering options affect how the selected object's documentation is rendered. Every handler accepts at least these two keys, selection and rendering , and some handlers accept additional keys. Check the documentation for your handler of interest in Handlers . Example with the Python handler docs/my_page.md mkdocs.yml src/my_package/my_module.py Result # Documentation for `MyClass` ::: my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false nav : - \"My page\" : my_page.md class MyClass : \"\"\"Print print print!\"\"\" def method_a ( self ): \"\"\"Print A!\"\"\" print ( \"A!\" ) def method_b ( self ): \"\"\"Print B!\"\"\" print ( \"B!\" ) def method_c ( self ): \"\"\"Print C!\"\"\" print ( \"C!\" )","title":"Autodoc syntax"},{"location":"usage/#global-options","text":"mkdocstrings accepts a few top-level configuration options in mkdocs.yml : watch : a list of directories to watch while serving the documentation. See Watch directories . default_handler : the handler that is used by default when no handler is specified. custom_templates : the path to a directory containing custom templates. The path is relative to the docs directory. See Theming . handlers : the handlers global configuration. enable_inventory : whether to enable inventory file generation. See Cross-references to other projects / inventories Example: mkdocs.yml plugins : - mkdocstrings : default_handler : python handlers : python : rendering : show_source : false custom_templates : templates watch : - src/my_package The handlers global configuration can then be overridden by local configurations: :: : my_package.my_module.MyClass rendering : show_source : true","title":"Global options"},{"location":"usage/#cross-references","text":"Cross-references are written as Markdown reference-style links: Markdown HTML Result With a custom title: [ `Object 1` ][full.path.object1] With the identifier as title: [ full.path.object2 ][] < p > With a custom title: < a href = \"https://example.com/page1#full.path.object1\" >< code > Object 1 </ code ></ a >< p > < p > With the identifier as title: < a href = \"https://example.com/page2#full.path.object2\" > full.path.object2 </ a ></ p > Any item that was inserted using the autodoc syntax (e.g. ::: full.path.object1 ) is possible to link to by using the same identifier with the cross-reference syntax ( [example][full.path.object1] ). But the cross-references are also applicable to the items' children that get pulled in.","title":"Cross-references"},{"location":"usage/#finding-out-the-anchor","text":"If you're not sure which exact identifier a doc item uses, you can look at its \"anchor\", which your Web browser will show in the URL bar when clicking an item's entry in the table of contents. If the URL is https://example.com/some/page.html#full.path.object1 then you know that this item is possible to link to with [example][full.path.object1] , regardless of the current page.","title":"Finding out the anchor"},{"location":"usage/#cross-references-to-any-markdown-heading","text":"Changed in version 0.15 Linking to any Markdown heading used to be the default, but now opt-in is required. If you want to link to any Markdown heading, not just mkdocstrings -inserted items, please enable the autorefs plugin for MkDocs by adding autorefs to plugins : mkdocs.yml plugins : - admonition - search - autorefs - mkdocstrings : [ ... ] Note that you don't need to ( pip ) install anything more; this plugin is guaranteed to be pulled in with mkdocstrings . Example doc1.md doc2.md Result HTML for doc2 ## Hello, world! Testing ## Something else Please see the [ Hello, World! ][ hello-world ] section. < p > Please see the < a href = \"doc1.html#hello-world\" > Hello, World! </ a > section. </ p >","title":"Cross-references to any Markdown heading"},{"location":"usage/#cross-references-to-a-sub-heading-in-a-docstring","text":"New in version 0.14 If you have a Markdown heading inside your docstring, you can also link directly to it. In the example below you see the identifier to be linked is foo.bar--tips , because it's the \"Tips\" heading that's part of the foo.bar object, joined with \" -- \". Example foo.py doc1.md doc2.md Result HTML for doc2 def bar (): \"\"\"Hello, world! # Tips - Stay hydrated. \"\"\" ::: foo.bar Check out the [ tips ][ foo.bar--tips ] < p > Check out the < a href = \"doc1.html#foo.bar--tips\" > tips </ a ></ p > The above tip about Finding out the anchor also applies the same way here. You may also notice that such a heading does not get rendered as a <h1> element directly, but rather the level gets shifted to fit the encompassing document structure. If you're curious about the implementation, check out mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor and others.","title":"Cross-references to a sub-heading in a docstring"},{"location":"usage/#cross-references-to-other-projects-inventories","text":"New in version 0.16. Python developers coming from Sphinx might know about its intersphinx extension, that allows to cross-reference items between several projects. mkdocstrings has a similar feature. To reference an item from another project, you must first tell mkdocstrings to load the inventory it provides. Each handler will be responsible of loading inventories specific to its language. For example, the Python handler can load Sphinx-generated inventories ( objects.inv ). In the following snippet, we load the inventory provided by requests : plugins : - mkdocstrings : handlers : python : import : - https://docs.python-requests.org/en/master/objects.inv Now it is possible to cross-reference requests ' items! For example: Markdown Result (HTML) Result (displayed) See [ requests.request ][] to know what parameters you can pass. < p > See < a href = \"https://docs.python-requests.org/en/latest/api/#requests.request\" > requests.request </ a > to know what parameters you can pass. </ p > See requests.request to know what parameters you can pass. You can of course select another version of the inventory, for example: plugins : - mkdocstrings : handlers : python : import : - https://docs.python-requests.org/en/v3.0.0/objects.inv In case the inventory file is not served under the base documentation URL, you can explicitly specify both URLs: plugins : - mkdocstrings : handlers : python : import : - url : https://cdn.example.com/version/objects.inv base_url : https://docs.example.com/version Absolute URLs to cross-referenced items will then be based on https://docs.example.com/version/ instead of https://cdn.example.com/version/ . Reciprocally, mkdocstrings also allows to generate an inventory file in the Sphinx format. It will be enabled by default if the Python handler is used, and generated as objects.inv in the final site directory. Other projects will be able to cross-reference items from your project! To explicitely enable or disable the generation of the inventory file, use the global enable_inventory option: plugins : - mkdocstrings : enable_inventory : false","title":"Cross-references to other projects / inventories"},{"location":"usage/#watch-directories","text":"You can add directories to watch with the watch key. It accepts a list of paths. mkdocs.yml plugins : - mkdocstrings : watch : - src/my_package_1 - src/my_package_2 When serving your documentation and a change occur in one of the listed path, MkDocs will rebuild the site and reload the current page. The watch feature doesn't have special effects. Adding directories to the watch list doesn't have any other effect than watching for changes. For example, it will not tell the Python handler to look for packages in these paths (the paths are not added to the PYTHONPATH variable). If you want to tell Python where to look for packages and modules, see Python Handler: Finding modules .","title":"Watch directories"},{"location":"handlers/overview/","text":"Handlers \u00a4 A handler is what makes it possible to collect and render documentation for a particular language. Available handlers \u00a4 Crystal Python (Legacy) Python (Experimental) About the Python handlers \u00a4 Since version 0.18, a new, experimental Python handler is available. It is based on Griffe , which is an improved version of pytkdocs . Note that the experimental handler does not yet offer the same features as the legacy one. If you are making extensive use of the current (legacy) Python handler selection and rendering options, you might want to wait a bit before trying the experimental handler. It is also not completely ready to handle dynamically built objects, like classes built with a call to type(...) . For most other cases, the experimental handler will work just fine. If you want to keep using the legacy handler as long as possible, you can depend on mkdocstrings-python-legacy directly, or specify the python-legacy extra when depending on mkdocstrings : # PEP 621 dependencies declaration # adapt to your dependencies manager [project] dependencies = [ \"mkdocstrings[python-legacy]>=0.18\" , ] The legacy handler will continue to \"work\" for many releases, as long as the new handler does not cover all previous use-cases. Using the legacy handler will emit a UserWarning stating that users should specify the python-legacy extra when depending on mkdocstrings . The warning will be emitted even if you do specify the extra, as we have no way to detect it. Warnings can be globally ignored by setting the PYTHONWARNINGS environment variable : PYTHONWARNINGS = ignore::UserWarning:mkdocstrings.handlers.python Migrate to the experimental Python handler \u00a4 To use the new, experimental Python handler, you can depend on mkdocstrings-python directly, or specify the python extra when depending on mkdocstrings : # PEP 621 dependencies declaration # adapt to your dependencies manager [project] dependencies = [ \"mkdocstrings[python]>=0.18\" , ] Handler options \u00a4 setup_commands is not yet implemented. But in most cases, you won't need it, since by default the new handler does not execute the code. Selection options \u00a4 filters is not yet implemented. Every declared object is picked up by default, but only rendered if it has a docstring. Since code is not executed, inherited attributes (like special methods and private members) are not picked up. members is not yet implemented. inherited_members is not yet implemented. docstring_style is implemented, and used as before, except for the restructured-text style which is renamed sphinx . Numpy-style is now built-in, so you can stop depending on pytkdocs[numpy-style] or docstring_parser . docstring_options is implemented, and used as before, however none of the provided parsers accept any option yet. new_path_syntax is irrelevant now. If you were setting it to True, remove the option and replace every colon ( : ) in your autodoc identifiers by dots ( . ). Rendering options \u00a4 Every previous option is supported. Additional options are available: separate_signature : Render the signature in a code block below the heading, instead as inline code. Useful for long signatures. If Black is installed, the signature is formatted. Default: false. line_length : The maximum line length to use when formatting signatures. Default: 60. show_submodules : Whether to render submodules of a module when iterating on children. Default: true. docstring_section_style : The style to use to render docstring sections such as attributes, parameters, etc. Available styles: table (default), list and spacy . The SpaCy style is a poor implementation of their table style . We are open to improvements through PRs! Templates \u00a4 Templates are mostly the same as before, but the file layout has changed, as well as some file names. Here is the new tree: theme \u251c\u2500\u2500 attribute.html \u251c\u2500\u2500 children.html \u251c\u2500\u2500 class.html \u251c\u2500\u2500 docstring \u2502 \u251c\u2500\u2500 admonition.html \u2502 \u251c\u2500\u2500 attributes.html \u2502 \u251c\u2500\u2500 examples.html \u2502 \u251c\u2500\u2500 other_parameters.html \u2502 \u251c\u2500\u2500 parameters.html \u2502 \u251c\u2500\u2500 raises.html \u2502 \u251c\u2500\u2500 receives.html \u2502 \u251c\u2500\u2500 returns.html \u2502 \u251c\u2500\u2500 warns.html \u2502 \u2514\u2500\u2500 yields.html \u251c\u2500\u2500 docstring.html \u251c\u2500\u2500 expression.html \u251c\u2500\u2500 function.html \u251c\u2500\u2500 labels.html \u251c\u2500\u2500 module.html \u2514\u2500\u2500 signature.html See them in the handler repository . In preparation for Jinja2 blocks, which will improve customization, each one of these templates extends in fact a base version in theme/_base . Example: theme/docstring/admonition.html {% extends \"_base/docstring/admonition.html\" %} theme/_base/docstring/admonition.html {{ log.debug () }} < details class = \" {{ section.value.kind }} \" > < summary > {{ section.title | convert_markdown ( heading_level , html_id , strip_paragraph = True ) }} </ summary > {{ section.value.contents | convert_markdown ( heading_level , html_id ) }} </ details > It means you will be able to customize only parts of a template without having to fully copy-paste it in your project: templates/theme/docstring.html {% extends \"_base/docstring.html\" %} {% block contents %} {{ block .super }} Additional contents {% endblock contents %} Block-level customization is not ready yet. Custom handlers \u00a4 Since version 0.14, you can create and use custom handlers thanks to namespace packages. For more information about namespace packages, see their documentation . Packaging \u00a4 For mkdocstrings , a custom handler package would have the following structure: \ud83d\udcc1 your_repository \u2514\u2500\u2574\ud83d\udcc1 mkdocstrings_handlers \u2514\u2500\u2574\ud83d\udcc1 custom_handler \u251c\u2500\u2574\ud83d\udcc1 templates \u2502 \u251c\u2500\u2574\ud83d\udcc1 material \u2502 \u251c\u2500\u2574\ud83d\udcc1 mkdocs \u2502 \u2514\u2500\u2574\ud83d\udcc1 readthedocs \u2514\u2500\u2574\ud83d\udcc4 __init__.py Note the absence of __init__.py module in mkdocstrings_handlers ! Code \u00a4 A handler is composed of a Collector and a Renderer. See the documentation for BaseHandler , BaseCollector and BaseRenderer . Check out how the Python handler is written for inspiration. You must implement a get_handler method at the module level. This function takes the theme (string, theme name) and custom_templates (optional string, path to custom templates directory) arguments, and you can add any other keyword argument you'd like. The global configuration items (other than selection and rendering ) will be passed to this function when getting your handler. Templates \u00a4 Your renderer's implementation should normally be backed by templates, which go to the directory mkdocstrings_handlers/custom_handler/templates/some_theme . ( custom_handler here should be replaced with the actual name of your handler, and some_theme should be the name of an actual MkDocs theme that you support, e.g. material ). With that structure, you can use self.env.get_template(\"foo.html\") inside your render implementation. This already chooses the subdirectory based on the current MkDocs theme. If you wish to support any MkDocs theme, rather than a few specifically selected ones, you can pick one theme's subdirectory to be the fallback for when an unknown theme is encountered. Then you just need to set the fallback_theme variable on your renderer subclass. The fallback directory can be used even for themes you explicitly support: you can omit some template from one of the other theme directories in case they're exactly the same as in the fallback theme. If your theme's HTML requires CSS to go along with it, put it into a file named mkdocstrings_handlers/custom_handler/templates/some_theme/style.css , then this will be included into the final site automatically if this handler is ever used. Alternatively, you can put the CSS as a string into the extra_css variable of your renderer. Finally, it's possible to entirely omit templates, and tell mkdocstrings to use the templates of another handler. In you renderer, override the get_templates_dir() method to return the other handlers templates path: from pathlib import Path from mkdocstrings.handlers.base import BaseRenderer class CobraRenderer ( BaseRenderer ): def get_templates_dir ( self , handler : str ) -> Path : # use the python handler templates # (it assumes the python handler is installed) return super () . get_templates_dir ( \"python\" ) Usage \u00a4 When a custom handler is installed, it is then available to mkdocstrings . You can configure it as usual: mkdocs.yml plugins : - mkdocstrings : handlers : custom_handler : selection : some_config_option : \"a\" rendering : other_config_option : 0 handler_config_option : yes ...and use it in your autodoc instructions: # Documentation for an object ::: some.objects.path handler: custom_handler selection: some_config_option: \"b\" rendering: other_config_option: 1","title":"Handlers"},{"location":"handlers/overview/#handlers","text":"A handler is what makes it possible to collect and render documentation for a particular language.","title":"Handlers"},{"location":"handlers/overview/#available-handlers","text":"Crystal Python (Legacy) Python (Experimental)","title":"Available handlers"},{"location":"handlers/overview/#about-the-python-handlers","text":"Since version 0.18, a new, experimental Python handler is available. It is based on Griffe , which is an improved version of pytkdocs . Note that the experimental handler does not yet offer the same features as the legacy one. If you are making extensive use of the current (legacy) Python handler selection and rendering options, you might want to wait a bit before trying the experimental handler. It is also not completely ready to handle dynamically built objects, like classes built with a call to type(...) . For most other cases, the experimental handler will work just fine. If you want to keep using the legacy handler as long as possible, you can depend on mkdocstrings-python-legacy directly, or specify the python-legacy extra when depending on mkdocstrings : # PEP 621 dependencies declaration # adapt to your dependencies manager [project] dependencies = [ \"mkdocstrings[python-legacy]>=0.18\" , ] The legacy handler will continue to \"work\" for many releases, as long as the new handler does not cover all previous use-cases. Using the legacy handler will emit a UserWarning stating that users should specify the python-legacy extra when depending on mkdocstrings . The warning will be emitted even if you do specify the extra, as we have no way to detect it. Warnings can be globally ignored by setting the PYTHONWARNINGS environment variable : PYTHONWARNINGS = ignore::UserWarning:mkdocstrings.handlers.python","title":"About the Python handlers"},{"location":"handlers/overview/#migrate-to-the-experimental-python-handler","text":"To use the new, experimental Python handler, you can depend on mkdocstrings-python directly, or specify the python extra when depending on mkdocstrings : # PEP 621 dependencies declaration # adapt to your dependencies manager [project] dependencies = [ \"mkdocstrings[python]>=0.18\" , ]","title":"Migrate to the experimental Python handler"},{"location":"handlers/overview/#handler-options","text":"setup_commands is not yet implemented. But in most cases, you won't need it, since by default the new handler does not execute the code.","title":"Handler options"},{"location":"handlers/overview/#selection-options","text":"filters is not yet implemented. Every declared object is picked up by default, but only rendered if it has a docstring. Since code is not executed, inherited attributes (like special methods and private members) are not picked up. members is not yet implemented. inherited_members is not yet implemented. docstring_style is implemented, and used as before, except for the restructured-text style which is renamed sphinx . Numpy-style is now built-in, so you can stop depending on pytkdocs[numpy-style] or docstring_parser . docstring_options is implemented, and used as before, however none of the provided parsers accept any option yet. new_path_syntax is irrelevant now. If you were setting it to True, remove the option and replace every colon ( : ) in your autodoc identifiers by dots ( . ).","title":"Selection options"},{"location":"handlers/overview/#rendering-options","text":"Every previous option is supported. Additional options are available: separate_signature : Render the signature in a code block below the heading, instead as inline code. Useful for long signatures. If Black is installed, the signature is formatted. Default: false. line_length : The maximum line length to use when formatting signatures. Default: 60. show_submodules : Whether to render submodules of a module when iterating on children. Default: true. docstring_section_style : The style to use to render docstring sections such as attributes, parameters, etc. Available styles: table (default), list and spacy . The SpaCy style is a poor implementation of their table style . We are open to improvements through PRs!","title":"Rendering options"},{"location":"handlers/overview/#templates","text":"Templates are mostly the same as before, but the file layout has changed, as well as some file names. Here is the new tree: theme \u251c\u2500\u2500 attribute.html \u251c\u2500\u2500 children.html \u251c\u2500\u2500 class.html \u251c\u2500\u2500 docstring \u2502 \u251c\u2500\u2500 admonition.html \u2502 \u251c\u2500\u2500 attributes.html \u2502 \u251c\u2500\u2500 examples.html \u2502 \u251c\u2500\u2500 other_parameters.html \u2502 \u251c\u2500\u2500 parameters.html \u2502 \u251c\u2500\u2500 raises.html \u2502 \u251c\u2500\u2500 receives.html \u2502 \u251c\u2500\u2500 returns.html \u2502 \u251c\u2500\u2500 warns.html \u2502 \u2514\u2500\u2500 yields.html \u251c\u2500\u2500 docstring.html \u251c\u2500\u2500 expression.html \u251c\u2500\u2500 function.html \u251c\u2500\u2500 labels.html \u251c\u2500\u2500 module.html \u2514\u2500\u2500 signature.html See them in the handler repository . In preparation for Jinja2 blocks, which will improve customization, each one of these templates extends in fact a base version in theme/_base . Example: theme/docstring/admonition.html {% extends \"_base/docstring/admonition.html\" %} theme/_base/docstring/admonition.html {{ log.debug () }} < details class = \" {{ section.value.kind }} \" > < summary > {{ section.title | convert_markdown ( heading_level , html_id , strip_paragraph = True ) }} </ summary > {{ section.value.contents | convert_markdown ( heading_level , html_id ) }} </ details > It means you will be able to customize only parts of a template without having to fully copy-paste it in your project: templates/theme/docstring.html {% extends \"_base/docstring.html\" %} {% block contents %} {{ block .super }} Additional contents {% endblock contents %} Block-level customization is not ready yet.","title":"Templates"},{"location":"handlers/overview/#custom-handlers","text":"Since version 0.14, you can create and use custom handlers thanks to namespace packages. For more information about namespace packages, see their documentation .","title":"Custom handlers"},{"location":"handlers/overview/#packaging","text":"For mkdocstrings , a custom handler package would have the following structure: \ud83d\udcc1 your_repository \u2514\u2500\u2574\ud83d\udcc1 mkdocstrings_handlers \u2514\u2500\u2574\ud83d\udcc1 custom_handler \u251c\u2500\u2574\ud83d\udcc1 templates \u2502 \u251c\u2500\u2574\ud83d\udcc1 material \u2502 \u251c\u2500\u2574\ud83d\udcc1 mkdocs \u2502 \u2514\u2500\u2574\ud83d\udcc1 readthedocs \u2514\u2500\u2574\ud83d\udcc4 __init__.py Note the absence of __init__.py module in mkdocstrings_handlers !","title":"Packaging"},{"location":"handlers/overview/#code","text":"A handler is composed of a Collector and a Renderer. See the documentation for BaseHandler , BaseCollector and BaseRenderer . Check out how the Python handler is written for inspiration. You must implement a get_handler method at the module level. This function takes the theme (string, theme name) and custom_templates (optional string, path to custom templates directory) arguments, and you can add any other keyword argument you'd like. The global configuration items (other than selection and rendering ) will be passed to this function when getting your handler.","title":"Code"},{"location":"handlers/overview/#templates_1","text":"Your renderer's implementation should normally be backed by templates, which go to the directory mkdocstrings_handlers/custom_handler/templates/some_theme . ( custom_handler here should be replaced with the actual name of your handler, and some_theme should be the name of an actual MkDocs theme that you support, e.g. material ). With that structure, you can use self.env.get_template(\"foo.html\") inside your render implementation. This already chooses the subdirectory based on the current MkDocs theme. If you wish to support any MkDocs theme, rather than a few specifically selected ones, you can pick one theme's subdirectory to be the fallback for when an unknown theme is encountered. Then you just need to set the fallback_theme variable on your renderer subclass. The fallback directory can be used even for themes you explicitly support: you can omit some template from one of the other theme directories in case they're exactly the same as in the fallback theme. If your theme's HTML requires CSS to go along with it, put it into a file named mkdocstrings_handlers/custom_handler/templates/some_theme/style.css , then this will be included into the final site automatically if this handler is ever used. Alternatively, you can put the CSS as a string into the extra_css variable of your renderer. Finally, it's possible to entirely omit templates, and tell mkdocstrings to use the templates of another handler. In you renderer, override the get_templates_dir() method to return the other handlers templates path: from pathlib import Path from mkdocstrings.handlers.base import BaseRenderer class CobraRenderer ( BaseRenderer ): def get_templates_dir ( self , handler : str ) -> Path : # use the python handler templates # (it assumes the python handler is installed) return super () . get_templates_dir ( \"python\" )","title":"Templates"},{"location":"handlers/overview/#usage","text":"When a custom handler is installed, it is then available to mkdocstrings . You can configure it as usual: mkdocs.yml plugins : - mkdocstrings : handlers : custom_handler : selection : some_config_option : \"a\" rendering : other_config_option : 0 handler_config_option : yes ...and use it in your autodoc instructions: # Documentation for an object ::: some.objects.path handler: custom_handler selection: some_config_option: \"b\" rendering: other_config_option: 1","title":"Usage"},{"location":"reference/SUMMARY/","text":"mkdocstrings extension.py handlers base.py rendering.py inventory.py loggers.py plugin.py","title":"SUMMARY"},{"location":"reference/extension/","text":"This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a handler to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc AutoDocProcessor ( BlockProcessor ) \u00a4 Our \"autodoc\" Markdown block processor. It has a test method that tells if a block matches a criterion, and a run method that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. Source code in mkdocstrings/extension.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class AutoDocProcessor ( BlockProcessor ): \"\"\"Our \"autodoc\" Markdown block processor. It has a [`test` method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [`run` method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. \"\"\" regex = re . compile ( r \"^(?P<heading>#{1,6} *|)::: ?(?P<name>.+?) *$\" , flags = re . MULTILINE ) def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_env = False def test ( self , parent : Element , block : str ) -> bool : \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . renderer . get_headings () el . extend ( headings ) page = self . _autorefs . current_page for anchor in handler . renderer . get_anchors ( data ): self . _autorefs . register_anchor ( page , anchor ) for heading in headings : anchor = heading . attrib [ \"id\" ] # noqa: WPS440 self . _autorefs . register_anchor ( page , anchor ) # noqa: WPS441 if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , # noqa: WPS441 domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , # noqa: WPS441 ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) def _process_block ( self , identifier : str , yaml_block : str , heading_level : int = 0 , ) -> Tuple [ str , BaseHandler , CollectorItem ]: \"\"\"Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. heading_level: Suggested level of the the heading to insert (0 to ignore). Raises: PluginError: When something wrong happened during collection. TemplateNotFound: When a template used for rendering could not be found. Returns: Rendered HTML, the handler that was used, and the collected item. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . _handlers . get_handler_name ( config ) log . debug ( f \"Using handler ' { handler_name } '\" ) handler_config = self . _handlers . get_handler_config ( handler_name ) handler = self . _handlers . get_handler ( handler_name , handler_config ) selection , rendering = get_item_configs ( handler_config , config ) if heading_level : rendering = ChainMap ( rendering , { \"heading_level\" : heading_level }) # like setdefault log . debug ( \"Collecting data\" ) try : data : CollectorItem = handler . collector . collect ( identifier , selection ) except CollectionError as exception : log . error ( str ( exception )) if PluginError is SystemExit : # When MkDocs 1.2 is sufficiently common, this can be dropped. log . error ( f \"Error reading page ' { self . _autorefs . current_page } ':\" ) raise PluginError ( f \"Could not collect ' { identifier } '\" ) from exception if not self . _updated_env : log . debug ( \"Updating renderer's env\" ) handler . renderer . _update_env ( self . md , self . _config ) # noqa: WPS437 (protected member OK) self . _updated_env = True log . debug ( \"Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"Template ' { exc . name } ' not found for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise return rendered , handler , data __init__ ( self , parser , md , config , handlers , autorefs ) \u00a4 Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The configuration of the mkdocstrings plugin. required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required Source code in mkdocstrings/extension.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_env = False _process_block ( self , identifier , yaml_block , heading_level = 0 ) \u00a4 Process an autodoc block. Parameters: Name Type Description Default identifier str The identifier of the object to collect and render. required yaml_block str The YAML configuration. required heading_level int Suggested level of the the heading to insert (0 to ignore). 0 Raises: Type Description PluginError When something wrong happened during collection. TemplateNotFound When a template used for rendering could not be found. Returns: Type Description Tuple [ str , BaseHandler , CollectorItem ] Rendered HTML, the handler that was used, and the collected item. Source code in mkdocstrings/extension.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def _process_block ( self , identifier : str , yaml_block : str , heading_level : int = 0 , ) -> Tuple [ str , BaseHandler , CollectorItem ]: \"\"\"Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. heading_level: Suggested level of the the heading to insert (0 to ignore). Raises: PluginError: When something wrong happened during collection. TemplateNotFound: When a template used for rendering could not be found. Returns: Rendered HTML, the handler that was used, and the collected item. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . _handlers . get_handler_name ( config ) log . debug ( f \"Using handler ' { handler_name } '\" ) handler_config = self . _handlers . get_handler_config ( handler_name ) handler = self . _handlers . get_handler ( handler_name , handler_config ) selection , rendering = get_item_configs ( handler_config , config ) if heading_level : rendering = ChainMap ( rendering , { \"heading_level\" : heading_level }) # like setdefault log . debug ( \"Collecting data\" ) try : data : CollectorItem = handler . collector . collect ( identifier , selection ) except CollectionError as exception : log . error ( str ( exception )) if PluginError is SystemExit : # When MkDocs 1.2 is sufficiently common, this can be dropped. log . error ( f \"Error reading page ' { self . _autorefs . current_page } ':\" ) raise PluginError ( f \"Could not collect ' { identifier } '\" ) from exception if not self . _updated_env : log . debug ( \"Updating renderer's env\" ) handler . renderer . _update_env ( self . md , self . _config ) # noqa: WPS437 (protected member OK) self . _updated_env = True log . debug ( \"Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"Template ' { exc . name } ' not found for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise return rendered , handler , data run ( self , parent , blocks ) \u00a4 Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks MutableSequence [ str ] The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . renderer . get_headings () el . extend ( headings ) page = self . _autorefs . current_page for anchor in handler . renderer . get_anchors ( data ): self . _autorefs . register_anchor ( page , anchor ) for heading in headings : anchor = heading . attrib [ \"id\" ] # noqa: WPS440 self . _autorefs . register_anchor ( page , anchor ) # noqa: WPS441 if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , # noqa: WPS441 domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , # noqa: WPS441 ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) test ( self , parent , block ) \u00a4 Match our autodoc instructions. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required block str The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in mkdocstrings/extension.py 82 83 84 85 86 87 88 89 90 91 92 def test ( self , parent : Element , block : str ) -> bool : \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) MkdocstringsExtension ( Extension ) \u00a4 Our Markdown extension. It cannot work outside of mkdocstrings . Source code in mkdocstrings/extension.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 class MkdocstringsExtension ( Extension ): \"\"\"Our Markdown extension. It cannot work outside of `mkdocstrings`. \"\"\" def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md . parser ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. ) __init__ ( self , config , handlers , autorefs , ** kwargs ) \u00a4 Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in extendMarkdown . required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required **kwargs Any Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our AutoDocProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md . parser ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. ) get_item_configs ( handler_config , config ) \u00a4 Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple [ Mapping , MutableMapping ] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py 210 211 212 213 214 215 216 217 218 219 220 221 222 def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ Mapping , MutableMapping ]: \"\"\"Get the selection and rendering configuration merged into the global configuration of the given handler. Arguments: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = ChainMap ( config . get ( \"selection\" , {}), handler_config . get ( \"selection\" , {})) item_rendering_config = ChainMap ( config . get ( \"rendering\" , {}), handler_config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"extension.py"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor","text":"Our \"autodoc\" Markdown block processor. It has a test method that tells if a block matches a criterion, and a run method that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. Source code in mkdocstrings/extension.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class AutoDocProcessor ( BlockProcessor ): \"\"\"Our \"autodoc\" Markdown block processor. It has a [`test` method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [`run` method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. \"\"\" regex = re . compile ( r \"^(?P<heading>#{1,6} *|)::: ?(?P<name>.+?) *$\" , flags = re . MULTILINE ) def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_env = False def test ( self , parent : Element , block : str ) -> bool : \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . renderer . get_headings () el . extend ( headings ) page = self . _autorefs . current_page for anchor in handler . renderer . get_anchors ( data ): self . _autorefs . register_anchor ( page , anchor ) for heading in headings : anchor = heading . attrib [ \"id\" ] # noqa: WPS440 self . _autorefs . register_anchor ( page , anchor ) # noqa: WPS441 if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , # noqa: WPS441 domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , # noqa: WPS441 ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) def _process_block ( self , identifier : str , yaml_block : str , heading_level : int = 0 , ) -> Tuple [ str , BaseHandler , CollectorItem ]: \"\"\"Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. heading_level: Suggested level of the the heading to insert (0 to ignore). Raises: PluginError: When something wrong happened during collection. TemplateNotFound: When a template used for rendering could not be found. Returns: Rendered HTML, the handler that was used, and the collected item. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . _handlers . get_handler_name ( config ) log . debug ( f \"Using handler ' { handler_name } '\" ) handler_config = self . _handlers . get_handler_config ( handler_name ) handler = self . _handlers . get_handler ( handler_name , handler_config ) selection , rendering = get_item_configs ( handler_config , config ) if heading_level : rendering = ChainMap ( rendering , { \"heading_level\" : heading_level }) # like setdefault log . debug ( \"Collecting data\" ) try : data : CollectorItem = handler . collector . collect ( identifier , selection ) except CollectionError as exception : log . error ( str ( exception )) if PluginError is SystemExit : # When MkDocs 1.2 is sufficiently common, this can be dropped. log . error ( f \"Error reading page ' { self . _autorefs . current_page } ':\" ) raise PluginError ( f \"Could not collect ' { identifier } '\" ) from exception if not self . _updated_env : log . debug ( \"Updating renderer's env\" ) handler . renderer . _update_env ( self . md , self . _config ) # noqa: WPS437 (protected member OK) self . _updated_env = True log . debug ( \"Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"Template ' { exc . name } ' not found for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise return rendered , handler , data","title":"AutoDocProcessor"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The configuration of the mkdocstrings plugin. required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required Source code in mkdocstrings/extension.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_env = False","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor._process_block","text":"Process an autodoc block. Parameters: Name Type Description Default identifier str The identifier of the object to collect and render. required yaml_block str The YAML configuration. required heading_level int Suggested level of the the heading to insert (0 to ignore). 0 Raises: Type Description PluginError When something wrong happened during collection. TemplateNotFound When a template used for rendering could not be found. Returns: Type Description Tuple [ str , BaseHandler , CollectorItem ] Rendered HTML, the handler that was used, and the collected item. Source code in mkdocstrings/extension.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def _process_block ( self , identifier : str , yaml_block : str , heading_level : int = 0 , ) -> Tuple [ str , BaseHandler , CollectorItem ]: \"\"\"Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. heading_level: Suggested level of the the heading to insert (0 to ignore). Raises: PluginError: When something wrong happened during collection. TemplateNotFound: When a template used for rendering could not be found. Returns: Rendered HTML, the handler that was used, and the collected item. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . _handlers . get_handler_name ( config ) log . debug ( f \"Using handler ' { handler_name } '\" ) handler_config = self . _handlers . get_handler_config ( handler_name ) handler = self . _handlers . get_handler ( handler_name , handler_config ) selection , rendering = get_item_configs ( handler_config , config ) if heading_level : rendering = ChainMap ( rendering , { \"heading_level\" : heading_level }) # like setdefault log . debug ( \"Collecting data\" ) try : data : CollectorItem = handler . collector . collect ( identifier , selection ) except CollectionError as exception : log . error ( str ( exception )) if PluginError is SystemExit : # When MkDocs 1.2 is sufficiently common, this can be dropped. log . error ( f \"Error reading page ' { self . _autorefs . current_page } ':\" ) raise PluginError ( f \"Could not collect ' { identifier } '\" ) from exception if not self . _updated_env : log . debug ( \"Updating renderer's env\" ) handler . renderer . _update_env ( self . md , self . _config ) # noqa: WPS437 (protected member OK) self . _updated_env = True log . debug ( \"Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"Template ' { exc . name } ' not found for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise return rendered , handler , data","title":"_process_block()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.run","text":"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks MutableSequence [ str ] The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . renderer . get_headings () el . extend ( headings ) page = self . _autorefs . current_page for anchor in handler . renderer . get_anchors ( data ): self . _autorefs . register_anchor ( page , anchor ) for heading in headings : anchor = heading . attrib [ \"id\" ] # noqa: WPS440 self . _autorefs . register_anchor ( page , anchor ) # noqa: WPS441 if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , # noqa: WPS441 domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , # noqa: WPS441 ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest )","title":"run()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.test","text":"Match our autodoc instructions. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required block str The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in mkdocstrings/extension.py 82 83 84 85 86 87 88 89 90 91 92 def test ( self , parent : Element , block : str ) -> bool : \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block ))","title":"test()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension","text":"Our Markdown extension. It cannot work outside of mkdocstrings . Source code in mkdocstrings/extension.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 class MkdocstringsExtension ( Extension ): \"\"\"Our Markdown extension. It cannot work outside of `mkdocstrings`. \"\"\" def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md . parser ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. )","title":"MkdocstringsExtension"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in extendMarkdown . required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required **kwargs Any Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","text":"Register the extension. Add an instance of our AutoDocProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md . parser ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. )","title":"extendMarkdown()"},{"location":"reference/extension/#mkdocstrings.extension.get_item_configs","text":"Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple [ Mapping , MutableMapping ] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py 210 211 212 213 214 215 216 217 218 219 220 221 222 def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ Mapping , MutableMapping ]: \"\"\"Get the selection and rendering configuration merged into the global configuration of the given handler. Arguments: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = ChainMap ( config . get ( \"selection\" , {}), handler_config . get ( \"selection\" , {})) item_rendering_config = ChainMap ( config . get ( \"rendering\" , {}), handler_config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"get_item_configs()"},{"location":"reference/inventory/","text":"Module responsible for the objects inventory. Inventory ( dict ) \u00a4 Inventory of collected and rendered objects. Source code in mkdocstrings/inventory.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class Inventory ( dict ): \"\"\"Inventory of collected and rendered objects.\"\"\" def __init__ ( self , items : Optional [ List [ InventoryItem ]] = None , project : str = \"project\" , version : str = \"0.0.0\" ): \"\"\"Initialize the object. Arguments: items: A list of items. project: The project name. version: The project version. \"\"\" super () . __init__ () items = items or [] for item in items : self [ item . name ] = item self . project = project self . version = version def register ( self , * args : str , ** kwargs : str ): \"\"\"Create and register an item. Arguments: *args: Arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. **kwargs: Keyword arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. \"\"\" item = InventoryItem ( * args , ** kwargs ) self [ item . name ] = item def format_sphinx ( self ) -> bytes : \"\"\"Format this inventory as a Sphinx `objects.inv` file. Returns: The inventory as bytes. \"\"\" header = ( dedent ( f \"\"\" # Sphinx inventory version 2 # Project: { self . project } # Version: { self . version } # The remainder of this file is compressed using zlib. \"\"\" ) . lstrip () . encode ( \"utf8\" ) ) lines = [ item . format_sphinx () . encode ( \"utf8\" ) for item in self . values ()] return header + zlib . compress ( b \" \\n \" . join ( lines ) + b \" \\n \" , 9 ) @classmethod def parse_sphinx ( cls , in_file : BinaryIO , * , domain_filter : Collection [ str ] = ()) -> \"Inventory\" : \"\"\"Parse a Sphinx v2 inventory file and return an `Inventory` from it. Arguments: in_file: The binary file-like object to read from. domain_filter: A collection of domain values to allow (and filter out all other ones). Returns: An `Inventory` containing the collected `InventoryItem`s. \"\"\" for _ in range ( 4 ): in_file . readline () lines = zlib . decompress ( in_file . read ()) . splitlines () items = [ InventoryItem . parse_sphinx ( line . decode ( \"utf8\" )) for line in lines ] if domain_filter : items = [ item for item in items if item . domain in domain_filter ] return cls ( items ) __init__ ( self , items = None , project = 'project' , version = '0.0.0' ) \u00a4 Initialize the object. Parameters: Name Type Description Default items Optional [ List [ InventoryItem ]] A list of items. None project str The project name. 'project' version str The project version. '0.0.0' Source code in mkdocstrings/inventory.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , items : Optional [ List [ InventoryItem ]] = None , project : str = \"project\" , version : str = \"0.0.0\" ): \"\"\"Initialize the object. Arguments: items: A list of items. project: The project name. version: The project version. \"\"\" super () . __init__ () items = items or [] for item in items : self [ item . name ] = item self . project = project self . version = version format_sphinx ( self ) \u00a4 Format this inventory as a Sphinx objects.inv file. Returns: Type Description bytes The inventory as bytes. Source code in mkdocstrings/inventory.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def format_sphinx ( self ) -> bytes : \"\"\"Format this inventory as a Sphinx `objects.inv` file. Returns: The inventory as bytes. \"\"\" header = ( dedent ( f \"\"\" # Sphinx inventory version 2 # Project: { self . project } # Version: { self . version } # The remainder of this file is compressed using zlib. \"\"\" ) . lstrip () . encode ( \"utf8\" ) ) lines = [ item . format_sphinx () . encode ( \"utf8\" ) for item in self . values ()] return header + zlib . compress ( b \" \\n \" . join ( lines ) + b \" \\n \" , 9 ) parse_sphinx ( cls , in_file , * , domain_filter = ()) \u00a4 Parse a Sphinx v2 inventory file and return an Inventory from it. Parameters: Name Type Description Default in_file BinaryIO The binary file-like object to read from. required domain_filter Collection [ str ] A collection of domain values to allow (and filter out all other ones). () Returns: Type Description 'Inventory' An Inventory containing the collected InventoryItem s. Source code in mkdocstrings/inventory.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @classmethod def parse_sphinx ( cls , in_file : BinaryIO , * , domain_filter : Collection [ str ] = ()) -> \"Inventory\" : \"\"\"Parse a Sphinx v2 inventory file and return an `Inventory` from it. Arguments: in_file: The binary file-like object to read from. domain_filter: A collection of domain values to allow (and filter out all other ones). Returns: An `Inventory` containing the collected `InventoryItem`s. \"\"\" for _ in range ( 4 ): in_file . readline () lines = zlib . decompress ( in_file . read ()) . splitlines () items = [ InventoryItem . parse_sphinx ( line . decode ( \"utf8\" )) for line in lines ] if domain_filter : items = [ item for item in items if item . domain in domain_filter ] return cls ( items ) register ( self , * args , ** kwargs ) \u00a4 Create and register an item. Parameters: Name Type Description Default *args str Arguments passed to InventoryItem . () **kwargs str Keyword arguments passed to InventoryItem . {} Source code in mkdocstrings/inventory.py 83 84 85 86 87 88 89 90 91 def register ( self , * args : str , ** kwargs : str ): \"\"\"Create and register an item. Arguments: *args: Arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. **kwargs: Keyword arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. \"\"\" item = InventoryItem ( * args , ** kwargs ) self [ item . name ] = item InventoryItem \u00a4 Inventory item. Source code in mkdocstrings/inventory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class InventoryItem : \"\"\"Inventory item.\"\"\" def __init__ ( self , name : str , domain : str , role : str , uri : str , priority : str = \"1\" , dispname : Optional [ str ] = None ): \"\"\"Initialize the object. Arguments: name: The item name. domain: The item domain, like 'python' or 'crystal'. role: The item role, like 'class' or 'method'. uri: The item URI. priority: The item priority. It can help for inventory suggestions. dispname: The item display name. \"\"\" self . name : str = name self . domain : str = domain self . role : str = role self . uri : str = uri self . priority : str = priority self . dispname : str = dispname or name def format_sphinx ( self ) -> str : \"\"\"Format this item as a Sphinx inventory line. Returns: A line formatted for an `objects.inv` file. \"\"\" dispname = self . dispname if dispname == self . name : dispname = \"-\" uri = self . uri if uri . endswith ( self . name ): uri = uri [: - len ( self . name )] + \"$\" return f \" { self . name } { self . domain } : { self . role } { self . priority } { uri } { dispname } \" sphinx_item_regex = re . compile ( r \"^(.+?)\\s+(\\S+):(\\S+)\\s+(-?\\d+)\\s+(\\S+)\\s+(.*)$\" ) @classmethod def parse_sphinx ( cls , line : str ) -> \"InventoryItem\" : \"\"\"Parse a line from a Sphinx v2 inventory file and return an `InventoryItem` from it.\"\"\" match = cls . sphinx_item_regex . search ( line ) if not match : raise ValueError ( line ) name , domain , role , priority , uri , dispname = match . groups () if uri . endswith ( \"$\" ): uri = uri [: - 1 ] + name if dispname == \"-\" : dispname = name return cls ( name , domain , role , uri , priority , dispname ) __init__ ( self , name , domain , role , uri , priority = '1' , dispname = None ) \u00a4 Initialize the object. Parameters: Name Type Description Default name str The item name. required domain str The item domain, like 'python' or 'crystal'. required role str The item role, like 'class' or 'method'. required uri str The item URI. required priority str The item priority. It can help for inventory suggestions. '1' dispname Optional [ str ] The item display name. None Source code in mkdocstrings/inventory.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , name : str , domain : str , role : str , uri : str , priority : str = \"1\" , dispname : Optional [ str ] = None ): \"\"\"Initialize the object. Arguments: name: The item name. domain: The item domain, like 'python' or 'crystal'. role: The item role, like 'class' or 'method'. uri: The item URI. priority: The item priority. It can help for inventory suggestions. dispname: The item display name. \"\"\" self . name : str = name self . domain : str = domain self . role : str = role self . uri : str = uri self . priority : str = priority self . dispname : str = dispname or name format_sphinx ( self ) \u00a4 Format this item as a Sphinx inventory line. Returns: Type Description str A line formatted for an objects.inv file. Source code in mkdocstrings/inventory.py 35 36 37 38 39 40 41 42 43 44 45 46 47 def format_sphinx ( self ) -> str : \"\"\"Format this item as a Sphinx inventory line. Returns: A line formatted for an `objects.inv` file. \"\"\" dispname = self . dispname if dispname == self . name : dispname = \"-\" uri = self . uri if uri . endswith ( self . name ): uri = uri [: - len ( self . name )] + \"$\" return f \" { self . name } { self . domain } : { self . role } { self . priority } { uri } { dispname } \" parse_sphinx ( cls , line ) \u00a4 Parse a line from a Sphinx v2 inventory file and return an InventoryItem from it. Source code in mkdocstrings/inventory.py 51 52 53 54 55 56 57 58 59 60 61 62 @classmethod def parse_sphinx ( cls , line : str ) -> \"InventoryItem\" : \"\"\"Parse a line from a Sphinx v2 inventory file and return an `InventoryItem` from it.\"\"\" match = cls . sphinx_item_regex . search ( line ) if not match : raise ValueError ( line ) name , domain , role , priority , uri , dispname = match . groups () if uri . endswith ( \"$\" ): uri = uri [: - 1 ] + name if dispname == \"-\" : dispname = name return cls ( name , domain , role , uri , priority , dispname )","title":"inventory.py"},{"location":"reference/inventory/#mkdocstrings.inventory.Inventory","text":"Inventory of collected and rendered objects. Source code in mkdocstrings/inventory.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class Inventory ( dict ): \"\"\"Inventory of collected and rendered objects.\"\"\" def __init__ ( self , items : Optional [ List [ InventoryItem ]] = None , project : str = \"project\" , version : str = \"0.0.0\" ): \"\"\"Initialize the object. Arguments: items: A list of items. project: The project name. version: The project version. \"\"\" super () . __init__ () items = items or [] for item in items : self [ item . name ] = item self . project = project self . version = version def register ( self , * args : str , ** kwargs : str ): \"\"\"Create and register an item. Arguments: *args: Arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. **kwargs: Keyword arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. \"\"\" item = InventoryItem ( * args , ** kwargs ) self [ item . name ] = item def format_sphinx ( self ) -> bytes : \"\"\"Format this inventory as a Sphinx `objects.inv` file. Returns: The inventory as bytes. \"\"\" header = ( dedent ( f \"\"\" # Sphinx inventory version 2 # Project: { self . project } # Version: { self . version } # The remainder of this file is compressed using zlib. \"\"\" ) . lstrip () . encode ( \"utf8\" ) ) lines = [ item . format_sphinx () . encode ( \"utf8\" ) for item in self . values ()] return header + zlib . compress ( b \" \\n \" . join ( lines ) + b \" \\n \" , 9 ) @classmethod def parse_sphinx ( cls , in_file : BinaryIO , * , domain_filter : Collection [ str ] = ()) -> \"Inventory\" : \"\"\"Parse a Sphinx v2 inventory file and return an `Inventory` from it. Arguments: in_file: The binary file-like object to read from. domain_filter: A collection of domain values to allow (and filter out all other ones). Returns: An `Inventory` containing the collected `InventoryItem`s. \"\"\" for _ in range ( 4 ): in_file . readline () lines = zlib . decompress ( in_file . read ()) . splitlines () items = [ InventoryItem . parse_sphinx ( line . decode ( \"utf8\" )) for line in lines ] if domain_filter : items = [ item for item in items if item . domain in domain_filter ] return cls ( items )","title":"Inventory"},{"location":"reference/inventory/#mkdocstrings.inventory.Inventory.__init__","text":"Initialize the object. Parameters: Name Type Description Default items Optional [ List [ InventoryItem ]] A list of items. None project str The project name. 'project' version str The project version. '0.0.0' Source code in mkdocstrings/inventory.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , items : Optional [ List [ InventoryItem ]] = None , project : str = \"project\" , version : str = \"0.0.0\" ): \"\"\"Initialize the object. Arguments: items: A list of items. project: The project name. version: The project version. \"\"\" super () . __init__ () items = items or [] for item in items : self [ item . name ] = item self . project = project self . version = version","title":"__init__()"},{"location":"reference/inventory/#mkdocstrings.inventory.Inventory.format_sphinx","text":"Format this inventory as a Sphinx objects.inv file. Returns: Type Description bytes The inventory as bytes. Source code in mkdocstrings/inventory.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def format_sphinx ( self ) -> bytes : \"\"\"Format this inventory as a Sphinx `objects.inv` file. Returns: The inventory as bytes. \"\"\" header = ( dedent ( f \"\"\" # Sphinx inventory version 2 # Project: { self . project } # Version: { self . version } # The remainder of this file is compressed using zlib. \"\"\" ) . lstrip () . encode ( \"utf8\" ) ) lines = [ item . format_sphinx () . encode ( \"utf8\" ) for item in self . values ()] return header + zlib . compress ( b \" \\n \" . join ( lines ) + b \" \\n \" , 9 )","title":"format_sphinx()"},{"location":"reference/inventory/#mkdocstrings.inventory.Inventory.parse_sphinx","text":"Parse a Sphinx v2 inventory file and return an Inventory from it. Parameters: Name Type Description Default in_file BinaryIO The binary file-like object to read from. required domain_filter Collection [ str ] A collection of domain values to allow (and filter out all other ones). () Returns: Type Description 'Inventory' An Inventory containing the collected InventoryItem s. Source code in mkdocstrings/inventory.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @classmethod def parse_sphinx ( cls , in_file : BinaryIO , * , domain_filter : Collection [ str ] = ()) -> \"Inventory\" : \"\"\"Parse a Sphinx v2 inventory file and return an `Inventory` from it. Arguments: in_file: The binary file-like object to read from. domain_filter: A collection of domain values to allow (and filter out all other ones). Returns: An `Inventory` containing the collected `InventoryItem`s. \"\"\" for _ in range ( 4 ): in_file . readline () lines = zlib . decompress ( in_file . read ()) . splitlines () items = [ InventoryItem . parse_sphinx ( line . decode ( \"utf8\" )) for line in lines ] if domain_filter : items = [ item for item in items if item . domain in domain_filter ] return cls ( items )","title":"parse_sphinx()"},{"location":"reference/inventory/#mkdocstrings.inventory.Inventory.register","text":"Create and register an item. Parameters: Name Type Description Default *args str Arguments passed to InventoryItem . () **kwargs str Keyword arguments passed to InventoryItem . {} Source code in mkdocstrings/inventory.py 83 84 85 86 87 88 89 90 91 def register ( self , * args : str , ** kwargs : str ): \"\"\"Create and register an item. Arguments: *args: Arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. **kwargs: Keyword arguments passed to [InventoryItem][mkdocstrings.inventory.InventoryItem]. \"\"\" item = InventoryItem ( * args , ** kwargs ) self [ item . name ] = item","title":"register()"},{"location":"reference/inventory/#mkdocstrings.inventory.InventoryItem","text":"Inventory item. Source code in mkdocstrings/inventory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class InventoryItem : \"\"\"Inventory item.\"\"\" def __init__ ( self , name : str , domain : str , role : str , uri : str , priority : str = \"1\" , dispname : Optional [ str ] = None ): \"\"\"Initialize the object. Arguments: name: The item name. domain: The item domain, like 'python' or 'crystal'. role: The item role, like 'class' or 'method'. uri: The item URI. priority: The item priority. It can help for inventory suggestions. dispname: The item display name. \"\"\" self . name : str = name self . domain : str = domain self . role : str = role self . uri : str = uri self . priority : str = priority self . dispname : str = dispname or name def format_sphinx ( self ) -> str : \"\"\"Format this item as a Sphinx inventory line. Returns: A line formatted for an `objects.inv` file. \"\"\" dispname = self . dispname if dispname == self . name : dispname = \"-\" uri = self . uri if uri . endswith ( self . name ): uri = uri [: - len ( self . name )] + \"$\" return f \" { self . name } { self . domain } : { self . role } { self . priority } { uri } { dispname } \" sphinx_item_regex = re . compile ( r \"^(.+?)\\s+(\\S+):(\\S+)\\s+(-?\\d+)\\s+(\\S+)\\s+(.*)$\" ) @classmethod def parse_sphinx ( cls , line : str ) -> \"InventoryItem\" : \"\"\"Parse a line from a Sphinx v2 inventory file and return an `InventoryItem` from it.\"\"\" match = cls . sphinx_item_regex . search ( line ) if not match : raise ValueError ( line ) name , domain , role , priority , uri , dispname = match . groups () if uri . endswith ( \"$\" ): uri = uri [: - 1 ] + name if dispname == \"-\" : dispname = name return cls ( name , domain , role , uri , priority , dispname )","title":"InventoryItem"},{"location":"reference/inventory/#mkdocstrings.inventory.InventoryItem.__init__","text":"Initialize the object. Parameters: Name Type Description Default name str The item name. required domain str The item domain, like 'python' or 'crystal'. required role str The item role, like 'class' or 'method'. required uri str The item URI. required priority str The item priority. It can help for inventory suggestions. '1' dispname Optional [ str ] The item display name. None Source code in mkdocstrings/inventory.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , name : str , domain : str , role : str , uri : str , priority : str = \"1\" , dispname : Optional [ str ] = None ): \"\"\"Initialize the object. Arguments: name: The item name. domain: The item domain, like 'python' or 'crystal'. role: The item role, like 'class' or 'method'. uri: The item URI. priority: The item priority. It can help for inventory suggestions. dispname: The item display name. \"\"\" self . name : str = name self . domain : str = domain self . role : str = role self . uri : str = uri self . priority : str = priority self . dispname : str = dispname or name","title":"__init__()"},{"location":"reference/inventory/#mkdocstrings.inventory.InventoryItem.format_sphinx","text":"Format this item as a Sphinx inventory line. Returns: Type Description str A line formatted for an objects.inv file. Source code in mkdocstrings/inventory.py 35 36 37 38 39 40 41 42 43 44 45 46 47 def format_sphinx ( self ) -> str : \"\"\"Format this item as a Sphinx inventory line. Returns: A line formatted for an `objects.inv` file. \"\"\" dispname = self . dispname if dispname == self . name : dispname = \"-\" uri = self . uri if uri . endswith ( self . name ): uri = uri [: - len ( self . name )] + \"$\" return f \" { self . name } { self . domain } : { self . role } { self . priority } { uri } { dispname } \"","title":"format_sphinx()"},{"location":"reference/inventory/#mkdocstrings.inventory.InventoryItem.parse_sphinx","text":"Parse a line from a Sphinx v2 inventory file and return an InventoryItem from it. Source code in mkdocstrings/inventory.py 51 52 53 54 55 56 57 58 59 60 61 62 @classmethod def parse_sphinx ( cls , line : str ) -> \"InventoryItem\" : \"\"\"Parse a line from a Sphinx v2 inventory file and return an `InventoryItem` from it.\"\"\" match = cls . sphinx_item_regex . search ( line ) if not match : raise ValueError ( line ) name , domain , role , priority , uri , dispname = match . groups () if uri . endswith ( \"$\" ): uri = uri [: - 1 ] + name if dispname == \"-\" : dispname = name return cls ( name , domain , role , uri , priority , dispname )","title":"parse_sphinx()"},{"location":"reference/loggers/","text":"Logging functions. LoggerAdapter ( logging . LoggerAdapter ) \u00a4 A logger adapter to prefix messages. Source code in mkdocstrings/loggers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class LoggerAdapter ( logging . LoggerAdapter ): \"\"\"A logger adapter to prefix messages.\"\"\" def __init__ ( self , prefix : str , logger : logging . Logger ): \"\"\"Initialize the object. Arguments: prefix: The string to insert in front of every message. logger: The logger instance. \"\"\" super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg : str , kwargs : MutableMapping [ str , Any ]) -> Tuple [ str , Any ]: \"\"\"Process the message. Arguments: msg: The message: kwargs: Remaining arguments. Returns: The processed message. \"\"\" return f \" { self . prefix } : { msg } \" , kwargs __init__ ( self , prefix , logger ) \u00a4 Initialize the object. Parameters: Name Type Description Default prefix str The string to insert in front of every message. required logger logging . Logger The logger instance. required Source code in mkdocstrings/loggers.py 21 22 23 24 25 26 27 28 29 def __init__ ( self , prefix : str , logger : logging . Logger ): \"\"\"Initialize the object. Arguments: prefix: The string to insert in front of every message. logger: The logger instance. \"\"\" super () . __init__ ( logger , {}) self . prefix = prefix process ( self , msg , kwargs ) \u00a4 Process the message. Parameters: Name Type Description Default msg str The message: required kwargs MutableMapping [ str , Any ] Remaining arguments. required Returns: Type Description Tuple [ str , Any ] The processed message. Source code in mkdocstrings/loggers.py 31 32 33 34 35 36 37 38 39 40 41 def process ( self , msg : str , kwargs : MutableMapping [ str , Any ]) -> Tuple [ str , Any ]: \"\"\"Process the message. Arguments: msg: The message: kwargs: Remaining arguments. Returns: The processed message. \"\"\" return f \" { self . prefix } : { msg } \" , kwargs TemplateLogger \u00a4 A wrapper class to allow logging in templates. Attributes: Name Type Description debug Function to log a DEBUG message. info Function to log an INFO message. warning Function to log a WARNING message. error Function to log an ERROR message. critical Function to log a CRITICAL message. Source code in mkdocstrings/loggers.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class TemplateLogger : \"\"\"A wrapper class to allow logging in templates. Attributes: debug: Function to log a DEBUG message. info: Function to log an INFO message. warning: Function to log a WARNING message. error: Function to log an ERROR message. critical: Function to log a CRITICAL message. \"\"\" def __init__ ( self , logger : LoggerAdapter ): \"\"\"Initialize the object. Arguments: logger: A logger adapter. \"\"\" self . debug = get_template_logger_function ( logger . debug ) self . info = get_template_logger_function ( logger . info ) self . warning = get_template_logger_function ( logger . warning ) self . error = get_template_logger_function ( logger . error ) self . critical = get_template_logger_function ( logger . critical ) __init__ ( self , logger ) \u00a4 Initialize the object. Parameters: Name Type Description Default logger LoggerAdapter A logger adapter. required Source code in mkdocstrings/loggers.py 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , logger : LoggerAdapter ): \"\"\"Initialize the object. Arguments: logger: A logger adapter. \"\"\" self . debug = get_template_logger_function ( logger . debug ) self . info = get_template_logger_function ( logger . info ) self . warning = get_template_logger_function ( logger . warning ) self . error = get_template_logger_function ( logger . error ) self . critical = get_template_logger_function ( logger . critical ) get_logger ( name ) \u00a4 Return a pre-configured logger. Parameters: Name Type Description Default name str The name to use with logging.getLogger . required Returns: Type Description LoggerAdapter A logger configured to work well in MkDocs. Source code in mkdocstrings/loggers.py 114 115 116 117 118 119 120 121 122 123 124 125 def get_logger ( name : str ) -> LoggerAdapter : \"\"\"Return a pre-configured logger. Arguments: name: The name to use with `logging.getLogger`. Returns: A logger configured to work well in MkDocs. \"\"\" logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) logger . addFilter ( warning_filter ) return LoggerAdapter ( name . split ( \".\" , 1 )[ 0 ], logger ) get_template_logger () \u00a4 Return a logger usable in templates. Returns: Type Description TemplateLogger A template logger. Source code in mkdocstrings/loggers.py 128 129 130 131 132 133 134 def get_template_logger () -> TemplateLogger : \"\"\"Return a logger usable in templates. Returns: A template logger. \"\"\" return TemplateLogger ( get_logger ( \"mkdocstrings.templates\" )) get_template_logger_function ( logger_func ) \u00a4 Create a wrapper function that automatically receives the Jinja template context. Parameters: Name Type Description Default logger_func Callable The logger function to use within the wrapper. required Returns: Type Description Callable A function. Source code in mkdocstrings/loggers.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_template_logger_function ( logger_func : Callable ) -> Callable : \"\"\"Create a wrapper function that automatically receives the Jinja template context. Arguments: logger_func: The logger function to use within the wrapper. Returns: A function. \"\"\" @pass_context def wrapper ( context : Context , msg : Optional [ str ] = None ) -> str : \"\"\"Log a message. Arguments: context: The template context, automatically provided by Jinja. msg: The message to log. Returns: An empty string. \"\"\" template_path = get_template_path ( context ) logger_func ( f \" { template_path } : { msg or 'Rendering' } \" ) return \"\" return wrapper get_template_path ( context ) \u00a4 Return the path to the template currently using the given context. Parameters: Name Type Description Default context Context The template context. required Returns: Type Description str The relative path to the template. Source code in mkdocstrings/loggers.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_template_path ( context : Context ) -> str : \"\"\"Return the path to the template currently using the given context. Arguments: context: The template context. Returns: The relative path to the template. \"\"\" filename = context . environment . get_template ( context . name ) . filename if filename : try : return str ( Path ( filename ) . relative_to ( TEMPLATES_DIR )) except ValueError : return filename return context . name","title":"loggers.py"},{"location":"reference/loggers/#mkdocstrings.loggers.LoggerAdapter","text":"A logger adapter to prefix messages. Source code in mkdocstrings/loggers.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class LoggerAdapter ( logging . LoggerAdapter ): \"\"\"A logger adapter to prefix messages.\"\"\" def __init__ ( self , prefix : str , logger : logging . Logger ): \"\"\"Initialize the object. Arguments: prefix: The string to insert in front of every message. logger: The logger instance. \"\"\" super () . __init__ ( logger , {}) self . prefix = prefix def process ( self , msg : str , kwargs : MutableMapping [ str , Any ]) -> Tuple [ str , Any ]: \"\"\"Process the message. Arguments: msg: The message: kwargs: Remaining arguments. Returns: The processed message. \"\"\" return f \" { self . prefix } : { msg } \" , kwargs","title":"LoggerAdapter"},{"location":"reference/loggers/#mkdocstrings.loggers.LoggerAdapter.__init__","text":"Initialize the object. Parameters: Name Type Description Default prefix str The string to insert in front of every message. required logger logging . Logger The logger instance. required Source code in mkdocstrings/loggers.py 21 22 23 24 25 26 27 28 29 def __init__ ( self , prefix : str , logger : logging . Logger ): \"\"\"Initialize the object. Arguments: prefix: The string to insert in front of every message. logger: The logger instance. \"\"\" super () . __init__ ( logger , {}) self . prefix = prefix","title":"__init__()"},{"location":"reference/loggers/#mkdocstrings.loggers.LoggerAdapter.process","text":"Process the message. Parameters: Name Type Description Default msg str The message: required kwargs MutableMapping [ str , Any ] Remaining arguments. required Returns: Type Description Tuple [ str , Any ] The processed message. Source code in mkdocstrings/loggers.py 31 32 33 34 35 36 37 38 39 40 41 def process ( self , msg : str , kwargs : MutableMapping [ str , Any ]) -> Tuple [ str , Any ]: \"\"\"Process the message. Arguments: msg: The message: kwargs: Remaining arguments. Returns: The processed message. \"\"\" return f \" { self . prefix } : { msg } \" , kwargs","title":"process()"},{"location":"reference/loggers/#mkdocstrings.loggers.TemplateLogger","text":"A wrapper class to allow logging in templates. Attributes: Name Type Description debug Function to log a DEBUG message. info Function to log an INFO message. warning Function to log a WARNING message. error Function to log an ERROR message. critical Function to log a CRITICAL message. Source code in mkdocstrings/loggers.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class TemplateLogger : \"\"\"A wrapper class to allow logging in templates. Attributes: debug: Function to log a DEBUG message. info: Function to log an INFO message. warning: Function to log a WARNING message. error: Function to log an ERROR message. critical: Function to log a CRITICAL message. \"\"\" def __init__ ( self , logger : LoggerAdapter ): \"\"\"Initialize the object. Arguments: logger: A logger adapter. \"\"\" self . debug = get_template_logger_function ( logger . debug ) self . info = get_template_logger_function ( logger . info ) self . warning = get_template_logger_function ( logger . warning ) self . error = get_template_logger_function ( logger . error ) self . critical = get_template_logger_function ( logger . critical )","title":"TemplateLogger"},{"location":"reference/loggers/#mkdocstrings.loggers.TemplateLogger.__init__","text":"Initialize the object. Parameters: Name Type Description Default logger LoggerAdapter A logger adapter. required Source code in mkdocstrings/loggers.py 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , logger : LoggerAdapter ): \"\"\"Initialize the object. Arguments: logger: A logger adapter. \"\"\" self . debug = get_template_logger_function ( logger . debug ) self . info = get_template_logger_function ( logger . info ) self . warning = get_template_logger_function ( logger . warning ) self . error = get_template_logger_function ( logger . error ) self . critical = get_template_logger_function ( logger . critical )","title":"__init__()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_logger","text":"Return a pre-configured logger. Parameters: Name Type Description Default name str The name to use with logging.getLogger . required Returns: Type Description LoggerAdapter A logger configured to work well in MkDocs. Source code in mkdocstrings/loggers.py 114 115 116 117 118 119 120 121 122 123 124 125 def get_logger ( name : str ) -> LoggerAdapter : \"\"\"Return a pre-configured logger. Arguments: name: The name to use with `logging.getLogger`. Returns: A logger configured to work well in MkDocs. \"\"\" logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) logger . addFilter ( warning_filter ) return LoggerAdapter ( name . split ( \".\" , 1 )[ 0 ], logger )","title":"get_logger()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_template_logger","text":"Return a logger usable in templates. Returns: Type Description TemplateLogger A template logger. Source code in mkdocstrings/loggers.py 128 129 130 131 132 133 134 def get_template_logger () -> TemplateLogger : \"\"\"Return a logger usable in templates. Returns: A template logger. \"\"\" return TemplateLogger ( get_logger ( \"mkdocstrings.templates\" ))","title":"get_template_logger()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_template_logger_function","text":"Create a wrapper function that automatically receives the Jinja template context. Parameters: Name Type Description Default logger_func Callable The logger function to use within the wrapper. required Returns: Type Description Callable A function. Source code in mkdocstrings/loggers.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_template_logger_function ( logger_func : Callable ) -> Callable : \"\"\"Create a wrapper function that automatically receives the Jinja template context. Arguments: logger_func: The logger function to use within the wrapper. Returns: A function. \"\"\" @pass_context def wrapper ( context : Context , msg : Optional [ str ] = None ) -> str : \"\"\"Log a message. Arguments: context: The template context, automatically provided by Jinja. msg: The message to log. Returns: An empty string. \"\"\" template_path = get_template_path ( context ) logger_func ( f \" { template_path } : { msg or 'Rendering' } \" ) return \"\" return wrapper","title":"get_template_logger_function()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_template_path","text":"Return the path to the template currently using the given context. Parameters: Name Type Description Default context Context The template context. required Returns: Type Description str The relative path to the template. Source code in mkdocstrings/loggers.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_template_path ( context : Context ) -> str : \"\"\"Return the path to the template currently using the given context. Arguments: context: The template context. Returns: The relative path to the template. \"\"\" filename = context . environment . get_template ( context . name ) . filename if filename : try : return str ( Path ( filename ) . relative_to ( TEMPLATES_DIR )) except ValueError : return filename return context . name","title":"get_template_path()"},{"location":"reference/plugin/","text":"This module contains the \"mkdocstrings\" plugin for MkDocs. The plugin instantiates a Markdown extension ( MkdocstringsExtension ), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . Once the documentation is built, the on_post_build event hook is triggered and calls the handlers.teardown() method . This method is used to teardown the handlers that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook . RENDERING_OPTS_KEY : str = 'rendering' \u00a4 The name of the rendering parameter in YAML configuration blocks. SELECTION_OPTS_KEY : str = 'selection' \u00a4 The name of the selection parameter in YAML configuration blocks. MkdocstringsPlugin ( BasePlugin ) \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_env on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in mkdocstrings/plugin.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class MkdocstringsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_env` - `on_post_build` - `on_serve` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" config_scheme : Tuple [ Tuple [ str , MkType ]] = ( ( \"watch\" , MkType ( list , default = [])), # type: ignore ( \"handlers\" , MkType ( dict , default = {})), ( \"default_handler\" , MkType ( str , default = \"python\" )), ( \"custom_templates\" , MkType ( str , default = None )), ( \"enable_inventory\" , MkType ( bool , default = None )), ) \"\"\" The configuration options of `mkdocstrings`, written in `mkdocs.yml`. Available options are: - __`watch`__: A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. - __`default_handler`__: The default handler to use. The value is the name of the handler module. Default is \"python\". - __`handlers`__: Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: ```yaml plugins: - mkdocstrings: handlers: python: selection: selection_opt: true rendering: rendering_opt: \"value\" setup_commands: - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust: selection: selection_opt: 2 ``` \"\"\" css_filename = \"assets/_mkdocstrings.css\" def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Optional [ Handlers ] = None @property def handlers ( self ) -> Handlers : \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build. Raises: RuntimeError: If the plugin hasn't been initialized with a config. Returns: An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build). \"\"\" if not self . _handlers : raise RuntimeError ( \"The plugin hasn't been initialized with a config yet\" ) return self . _handlers def on_serve ( self , server : LiveReloadServer , builder : Callable , ** kwargs : Any ): # noqa: W0613 (unused arguments) \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. **kwargs: Additional arguments passed by MkDocs. \"\"\" for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: W0613 (unused arguments) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } to_import . append (( handler_name , import_item )) extension_config = { \"site_name\" : config [ \"site_name\" ], \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . _handlers = Handlers ( extension_config ) try : # noqa: WPS229 # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : # noqa: WPS440 future = inv_loader . submit ( self . _load_inventory , self . get_handler ( handler_name ) . load_inventory , ** import_item ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) return config @property def inventory_enabled ( self ) -> bool : \"\"\"Tell if the inventory is enabled or not. Returns: Whether the inventory is enabled. \"\"\" inventory_enabled = self . config [ \"enable_inventory\" ] if inventory_enabled is None : inventory_enabled = any ( handler . enable_inventory for handler in self . handlers . seen_handlers ) return inventory_enabled def on_env ( self , env , config : Config , ** kwargs ): \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if self . _handlers : css_content = \" \\n \" . join ( handler . renderer . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = [] def on_post_build ( self , config : Config , ** kwargs : Any ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown () def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) @classmethod @functools . lru_cache ( maxsize = None ) def _load_inventory ( cls , loader : InventoryLoaderType , url : str , ** kwargs : Any ) -> Mapping [ str , str ]: \"\"\"Download and process inventory files using a handler. Arguments: loader: A function returning a sequence of pairs (identifier, url). url: The URL to download and process. **kwargs: Extra arguments to pass to the loader. Returns: A mapping from identifier to absolute URL. \"\"\" log . debug ( f \"Downloading inventory from { url !r} \" ) req = request . Request ( url , headers = { \"Accept-Encoding\" : \"gzip\" , \"User-Agent\" : \"mkdocstrings/0.15.0\" }) with request . urlopen ( req ) as resp : # noqa: S310 (URL audit OK: comes from a checked-in config) content : BinaryIO = resp if \"gzip\" in resp . headers . get ( \"content-encoding\" , \"\" ): content = gzip . GzipFile ( fileobj = resp ) # type: ignore[assignment] result = dict ( loader ( content , url = url , ** kwargs )) log . debug ( f \"Loaded inventory from { url !r} : { len ( result ) } items\" ) return result config_scheme : Tuple [ Tuple [ str , MkType ]] = (( 'watch' , MkType ( list , default = [])), ( 'handlers' , MkType ( dict , default = {})), ( 'default_handler' , MkType ( str , default = 'python' )), ( 'custom_templates' , MkType ( str , default = None )), ( 'enable_inventory' , MkType ( bool , default = None ))) \u00a4 The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2 __init__ ( self ) \u00a4 Initialize the object. Source code in mkdocstrings/plugin.py 99 100 101 102 def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Optional [ Handlers ] = None _load_inventory ( cls , loader , url , ** kwargs ) \u00a4 Download and process inventory files using a handler. Parameters: Name Type Description Default loader InventoryLoaderType A function returning a sequence of pairs (identifier, url). required url str The URL to download and process. required **kwargs Any Extra arguments to pass to the loader. {} Returns: Type Description Mapping [ str , str ] A mapping from identifier to absolute URL. Source code in mkdocstrings/plugin.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 @classmethod @functools . lru_cache ( maxsize = None ) def _load_inventory ( cls , loader : InventoryLoaderType , url : str , ** kwargs : Any ) -> Mapping [ str , str ]: \"\"\"Download and process inventory files using a handler. Arguments: loader: A function returning a sequence of pairs (identifier, url). url: The URL to download and process. **kwargs: Extra arguments to pass to the loader. Returns: A mapping from identifier to absolute URL. \"\"\" log . debug ( f \"Downloading inventory from { url !r} \" ) req = request . Request ( url , headers = { \"Accept-Encoding\" : \"gzip\" , \"User-Agent\" : \"mkdocstrings/0.15.0\" }) with request . urlopen ( req ) as resp : # noqa: S310 (URL audit OK: comes from a checked-in config) content : BinaryIO = resp if \"gzip\" in resp . headers . get ( \"content-encoding\" , \"\" ): content = gzip . GzipFile ( fileobj = resp ) # type: ignore[assignment] result = dict ( loader ( content , url = url , ** kwargs )) log . debug ( f \"Loaded inventory from { url !r} : { len ( result ) } items\" ) return result get_handler ( self , handler_name ) \u00a4 Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler . Parameters: Name Type Description Default handler_name str The name of the handler. required Returns: Type Description BaseHandler An instance of a subclass of BaseHandler . Source code in mkdocstrings/plugin.py 265 266 267 268 269 270 271 272 273 274 def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) handlers ( self ) \u00a4 Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build. Raises: Type Description RuntimeError If the plugin hasn't been initialized with a config. Returns: Type Description Handlers An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build). Source code in mkdocstrings/plugin.py 104 105 106 107 108 109 110 111 112 113 114 115 116 @property def handlers ( self ) -> Handlers : \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build. Raises: RuntimeError: If the plugin hasn't been initialized with a config. Returns: An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build). \"\"\" if not self . _handlers : raise RuntimeError ( \"The plugin hasn't been initialized with a config yet\" ) return self . _handlers inventory_enabled ( self ) \u00a4 Tell if the inventory is enabled or not. Returns: Type Description bool Whether the inventory is enabled. Source code in mkdocstrings/plugin.py 206 207 208 209 210 211 212 213 214 215 216 @property def inventory_enabled ( self ) -> bool : \"\"\"Tell if the inventory is enabled or not. Returns: Whether the inventory is enabled. \"\"\" inventory_enabled = self . config [ \"enable_inventory\" ] if inventory_enabled is None : inventory_enabled = any ( handler . enable_inventory for handler in self . handlers . seen_handlers ) return inventory_enabled on_config ( self , config , ** kwargs ) \u00a4 Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our MkdocstringsExtension and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocstrings/plugin.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: W0613 (unused arguments) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } to_import . append (( handler_name , import_item )) extension_config = { \"site_name\" : config [ \"site_name\" ], \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . _handlers = Handlers ( extension_config ) try : # noqa: WPS229 # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : # noqa: WPS440 future = inv_loader . submit ( self . _load_inventory , self . get_handler ( handler_name ) . load_inventory , ** import_item ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) return config on_env ( self , env , config , ** kwargs ) \u00a4 Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the on_env event . Write mkdocstrings' extra files into the site dir. Gather results from background inventory download tasks. Source code in mkdocstrings/plugin.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def on_env ( self , env , config : Config , ** kwargs ): \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if self . _handlers : css_content = \" \\n \" . join ( handler . renderer . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = [] on_post_build ( self , config , ** kwargs ) \u00a4 Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's teardown method, which is indirectly called by this hook. Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def on_post_build ( self , config : Config , ** kwargs : Any ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown () on_serve ( self , server , builder , ** kwargs ) \u00a4 Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server LiveReloadServer The livereload server instance. required builder Callable The function to build the site. required **kwargs Any Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def on_serve ( self , server : LiveReloadServer , builder : Callable , ** kwargs : Any ): # noqa: W0613 (unused arguments) \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. **kwargs: Additional arguments passed by MkDocs. \"\"\" for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder )","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin.RENDERING_OPTS_KEY","text":"The name of the rendering parameter in YAML configuration blocks.","title":"RENDERING_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.SELECTION_OPTS_KEY","text":"The name of the selection parameter in YAML configuration blocks.","title":"SELECTION_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_env on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in mkdocstrings/plugin.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class MkdocstringsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_env` - `on_post_build` - `on_serve` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" config_scheme : Tuple [ Tuple [ str , MkType ]] = ( ( \"watch\" , MkType ( list , default = [])), # type: ignore ( \"handlers\" , MkType ( dict , default = {})), ( \"default_handler\" , MkType ( str , default = \"python\" )), ( \"custom_templates\" , MkType ( str , default = None )), ( \"enable_inventory\" , MkType ( bool , default = None )), ) \"\"\" The configuration options of `mkdocstrings`, written in `mkdocs.yml`. Available options are: - __`watch`__: A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. - __`default_handler`__: The default handler to use. The value is the name of the handler module. Default is \"python\". - __`handlers`__: Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: ```yaml plugins: - mkdocstrings: handlers: python: selection: selection_opt: true rendering: rendering_opt: \"value\" setup_commands: - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust: selection: selection_opt: 2 ``` \"\"\" css_filename = \"assets/_mkdocstrings.css\" def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Optional [ Handlers ] = None @property def handlers ( self ) -> Handlers : \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build. Raises: RuntimeError: If the plugin hasn't been initialized with a config. Returns: An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build). \"\"\" if not self . _handlers : raise RuntimeError ( \"The plugin hasn't been initialized with a config yet\" ) return self . _handlers def on_serve ( self , server : LiveReloadServer , builder : Callable , ** kwargs : Any ): # noqa: W0613 (unused arguments) \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. **kwargs: Additional arguments passed by MkDocs. \"\"\" for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: W0613 (unused arguments) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } to_import . append (( handler_name , import_item )) extension_config = { \"site_name\" : config [ \"site_name\" ], \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . _handlers = Handlers ( extension_config ) try : # noqa: WPS229 # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : # noqa: WPS440 future = inv_loader . submit ( self . _load_inventory , self . get_handler ( handler_name ) . load_inventory , ** import_item ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) return config @property def inventory_enabled ( self ) -> bool : \"\"\"Tell if the inventory is enabled or not. Returns: Whether the inventory is enabled. \"\"\" inventory_enabled = self . config [ \"enable_inventory\" ] if inventory_enabled is None : inventory_enabled = any ( handler . enable_inventory for handler in self . handlers . seen_handlers ) return inventory_enabled def on_env ( self , env , config : Config , ** kwargs ): \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if self . _handlers : css_content = \" \\n \" . join ( handler . renderer . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = [] def on_post_build ( self , config : Config , ** kwargs : Any ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown () def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) @classmethod @functools . lru_cache ( maxsize = None ) def _load_inventory ( cls , loader : InventoryLoaderType , url : str , ** kwargs : Any ) -> Mapping [ str , str ]: \"\"\"Download and process inventory files using a handler. Arguments: loader: A function returning a sequence of pairs (identifier, url). url: The URL to download and process. **kwargs: Extra arguments to pass to the loader. Returns: A mapping from identifier to absolute URL. \"\"\" log . debug ( f \"Downloading inventory from { url !r} \" ) req = request . Request ( url , headers = { \"Accept-Encoding\" : \"gzip\" , \"User-Agent\" : \"mkdocstrings/0.15.0\" }) with request . urlopen ( req ) as resp : # noqa: S310 (URL audit OK: comes from a checked-in config) content : BinaryIO = resp if \"gzip\" in resp . headers . get ( \"content-encoding\" , \"\" ): content = gzip . GzipFile ( fileobj = resp ) # type: ignore[assignment] result = dict ( loader ( content , url = url , ** kwargs )) log . debug ( f \"Loaded inventory from { url !r} : { len ( result ) } items\" ) return result","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","text":"The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2","title":"config_scheme"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","text":"Initialize the object. Source code in mkdocstrings/plugin.py 99 100 101 102 def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Optional [ Handlers ] = None","title":"__init__()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin._load_inventory","text":"Download and process inventory files using a handler. Parameters: Name Type Description Default loader InventoryLoaderType A function returning a sequence of pairs (identifier, url). required url str The URL to download and process. required **kwargs Any Extra arguments to pass to the loader. {} Returns: Type Description Mapping [ str , str ] A mapping from identifier to absolute URL. Source code in mkdocstrings/plugin.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 @classmethod @functools . lru_cache ( maxsize = None ) def _load_inventory ( cls , loader : InventoryLoaderType , url : str , ** kwargs : Any ) -> Mapping [ str , str ]: \"\"\"Download and process inventory files using a handler. Arguments: loader: A function returning a sequence of pairs (identifier, url). url: The URL to download and process. **kwargs: Extra arguments to pass to the loader. Returns: A mapping from identifier to absolute URL. \"\"\" log . debug ( f \"Downloading inventory from { url !r} \" ) req = request . Request ( url , headers = { \"Accept-Encoding\" : \"gzip\" , \"User-Agent\" : \"mkdocstrings/0.15.0\" }) with request . urlopen ( req ) as resp : # noqa: S310 (URL audit OK: comes from a checked-in config) content : BinaryIO = resp if \"gzip\" in resp . headers . get ( \"content-encoding\" , \"\" ): content = gzip . GzipFile ( fileobj = resp ) # type: ignore[assignment] result = dict ( loader ( content , url = url , ** kwargs )) log . debug ( f \"Loaded inventory from { url !r} : { len ( result ) } items\" ) return result","title":"_load_inventory()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.get_handler","text":"Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler . Parameters: Name Type Description Default handler_name str The name of the handler. required Returns: Type Description BaseHandler An instance of a subclass of BaseHandler . Source code in mkdocstrings/plugin.py 265 266 267 268 269 270 271 272 273 274 def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name )","title":"get_handler()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.handlers","text":"Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build. Raises: Type Description RuntimeError If the plugin hasn't been initialized with a config. Returns: Type Description Handlers An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build). Source code in mkdocstrings/plugin.py 104 105 106 107 108 109 110 111 112 113 114 115 116 @property def handlers ( self ) -> Handlers : \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build. Raises: RuntimeError: If the plugin hasn't been initialized with a config. Returns: An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build). \"\"\" if not self . _handlers : raise RuntimeError ( \"The plugin hasn't been initialized with a config yet\" ) return self . _handlers","title":"handlers()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.inventory_enabled","text":"Tell if the inventory is enabled or not. Returns: Type Description bool Whether the inventory is enabled. Source code in mkdocstrings/plugin.py 206 207 208 209 210 211 212 213 214 215 216 @property def inventory_enabled ( self ) -> bool : \"\"\"Tell if the inventory is enabled or not. Returns: Whether the inventory is enabled. \"\"\" inventory_enabled = self . config [ \"enable_inventory\" ] if inventory_enabled is None : inventory_enabled = any ( handler . enable_inventory for handler in self . handlers . seen_handlers ) return inventory_enabled","title":"inventory_enabled()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our MkdocstringsExtension and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocstrings/plugin.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: W0613 (unused arguments) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } to_import . append (( handler_name , import_item )) extension_config = { \"site_name\" : config [ \"site_name\" ], \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . _handlers = Handlers ( extension_config ) try : # noqa: WPS229 # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : # noqa: WPS440 future = inv_loader . submit ( self . _load_inventory , self . get_handler ( handler_name ) . load_inventory , ** import_item ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) return config","title":"on_config()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_env","text":"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the on_env event . Write mkdocstrings' extra files into the site dir. Gather results from background inventory download tasks. Source code in mkdocstrings/plugin.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def on_env ( self , env , config : Config , ** kwargs ): \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if self . _handlers : css_content = \" \\n \" . join ( handler . renderer . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = []","title":"on_env()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","text":"Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's teardown method, which is indirectly called by this hook. Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def on_post_build ( self , config : Config , ** kwargs : Any ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown ()","title":"on_post_build()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","text":"Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server LiveReloadServer The livereload server instance. required builder Callable The function to build the site. required **kwargs Any Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def on_serve ( self , server : LiveReloadServer , builder : Callable , ** kwargs : Any ): # noqa: W0613 (unused arguments) \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. **kwargs: Additional arguments passed by MkDocs. \"\"\" for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder )","title":"on_serve()"},{"location":"reference/autorefs/plugin/","text":"window.location.href = \"https://mkdocstrings.github.io/autorefs/reference/mkdocs_autorefs/plugin/\"; Redirecting...","title":"Plugin"},{"location":"reference/autorefs/references/","text":"window.location.href = \"https://mkdocstrings.github.io/autorefs/reference/mkdocs_autorefs/references/\"; Redirecting...","title":"References"},{"location":"reference/handlers/base/","text":"Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache. BaseCollector ( ABC ) \u00a4 The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. Source code in mkdocstrings/handlers/base.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class BaseCollector ( ABC ): \"\"\"The base collector class. Inherit from this class to implement a collector. You will have to implement the `collect` method. You can also implement the `teardown` method. \"\"\" @abstractmethod def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section) def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\" collect ( self , identifier , config ) \u00a4 Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description CollectorItem Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/base.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 @abstractmethod def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section) teardown ( self ) \u00a4 Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in mkdocstrings/handlers/base.py 343 344 345 346 347 348 def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\" BaseHandler \u00a4 The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: Name Type Description domain str The cross-documentation domain/language for this handler. enable_inventory bool Whether this handler is interested in enabling the creation of the objects.inv Sphinx inventory file. Source code in mkdocstrings/handlers/base.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 class BaseHandler : \"\"\"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: domain: The cross-documentation domain/language for this handler. enable_inventory: Whether this handler is interested in enabling the creation of the `objects.inv` Sphinx inventory file. \"\"\" domain : str = \"default\" enable_inventory : bool = False def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer __init__ ( self , collector , renderer ) \u00a4 Initialize the object. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/base.py 367 368 369 370 371 372 373 374 375 def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer BaseRenderer ( ABC ) \u00a4 The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a fallback_theme class-variable. To add custom CSS, add an extra_css variable or create an 'style.css' file beside the templates. Source code in mkdocstrings/handlers/base.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 class BaseRenderer ( ABC ): \"\"\"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the `render` method. You can also override the `update_env` method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a `fallback_theme` class-variable. To add custom CSS, add an `extra_css` variable or create an 'style.css' file beside the templates. \"\"\" fallback_theme : str = \"\" extra_css = \"\" def __init__ ( self , handler : str , theme : str , custom_templates : Optional [ str ] = None , directory : str = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. directory: Deprecated and renamed as `handler`. \"\"\" # TODO: remove at some point if directory : warnings . warn ( \"The 'directory' keyword parameter is deprecated and renamed 'handler'. \" , DeprecationWarning , ) if not handler : handler = directory paths = [] themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) # noqa: WPS601 break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : List [ Element ] = [] self . _md : Markdown = None # type: ignore # To be populated in `update_env`. @abstractmethod def render ( self , data : CollectorItem , config : dict ) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section) def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : # noqa: WPS609 theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : # noqa: WPS609,WPS440 theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" ) def get_anchors ( self , data : CollectorItem ) -> Sequence [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore except AttributeError : return () def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset () def do_heading ( self , content : str , heading_level : int , * , role : Optional [ str ] = None , hidden : bool = False , toc_label : Optional [ str ] = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( el , Markup ) else content # type: ignore el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: W0613 (unused argument 'config') \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading def _update_env ( self , md : Markdown , config : dict ): extensions = config [ \"mdx\" ] + [ MkdocstringsInnerExtension ( self . _headings )] new_md = Markdown ( extensions = extensions , extension_configs = config [ \"mdx_configs\" ]) # MkDocs adds its own (required) extension that's not part of the config. Propagate it. if \"relpath\" in md . treeprocessors : new_md . treeprocessors . register ( md . treeprocessors [ \"relpath\" ], \"relpath\" , priority = 0 ) self . update_env ( new_md , config ) __init__ ( self , handler , theme , custom_templates = None , directory = None ) \u00a4 Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default handler str The name of the handler. required theme str The name of theme to use. required custom_templates Optional [ str ] Directory containing custom templates. None directory str Deprecated and renamed as handler . None Source code in mkdocstrings/handlers/base.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , handler : str , theme : str , custom_templates : Optional [ str ] = None , directory : str = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. directory: Deprecated and renamed as `handler`. \"\"\" # TODO: remove at some point if directory : warnings . warn ( \"The 'directory' keyword parameter is deprecated and renamed 'handler'. \" , DeprecationWarning , ) if not handler : handler = directory paths = [] themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) # noqa: WPS601 break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : List [ Element ] = [] self . _md : Markdown = None # type: ignore # To be populated in `update_env`. do_convert_markdown ( self , text , heading_level , html_id = '' , * , strip_paragraph = False ) \u00a4 Render Markdown text; for use inside templates. Parameters: Name Type Description Default text str The text to convert. required heading_level int The base heading level to start all Markdown headings from. required html_id str The HTML id of the element that's considered the parent of this element. '' strip_paragraph bool Whether to exclude the tag from around the whole output. False Returns: Type Description Markup An HTML string. Source code in mkdocstrings/handlers/base.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset () do_heading ( self , content , heading_level , * , role = None , hidden = False , toc_label = None , ** attributes ) \u00a4 Render an HTML heading and register it for the table of contents. For use inside templates. Parameters: Name Type Description Default content str The HTML within the heading. required heading_level int The level of heading (e.g. 3 -> h3 ). required role Optional [ str ] An optional role for the object bound to this heading. None hidden bool If True, only register it for the table of contents, don't render anything. False toc_label Optional [ str ] The title to use in the table of contents ('data-toc-label' attribute). None **attributes str Any extra HTML attributes of the heading. {} Returns: Type Description Markup An HTML string. Source code in mkdocstrings/handlers/base.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def do_heading ( self , content : str , heading_level : int , * , role : Optional [ str ] = None , hidden : bool = False , toc_label : Optional [ str ] = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( el , Markup ) else content # type: ignore el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) get_anchors ( self , data ) \u00a4 Return the possible identifiers (HTML anchors) for a collected item. Parameters: Name Type Description Default data CollectorItem The collected data. required Returns: Type Description Sequence [ str ] The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. Source code in mkdocstrings/handlers/base.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def get_anchors ( self , data : CollectorItem ) -> Sequence [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore except AttributeError : return () get_headings ( self ) \u00a4 Return and clear the headings gathered so far. Returns: Type Description Sequence [ Element ] A list of HTML elements. Source code in mkdocstrings/handlers/base.py 282 283 284 285 286 287 288 289 290 def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result get_templates_dir ( self , handler ) \u00a4 Return the path to the handler's templates directory. Override to customize how the templates directory is found. Parameters: Name Type Description Default handler str The name of the handler to get the templates directory of. required Raises: Type Description FileNotFoundError When the templates directory cannot be found. Returns: Type Description Path The templates directory path. Source code in mkdocstrings/handlers/base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : # noqa: WPS609 theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : # noqa: WPS609,WPS440 theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" ) render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data CollectorItem The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/base.py 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def render ( self , data : CollectorItem , config : dict ) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section) update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in mkdocstrings/handlers/base.py 292 293 294 295 296 297 298 299 300 301 302 303 def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: W0613 (unused argument 'config') \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading CollectionError ( Exception ) \u00a4 An exception raised when some collection of data failed. Source code in mkdocstrings/handlers/base.py 36 37 class CollectionError ( Exception ): \"\"\"An exception raised when some collection of data failed.\"\"\" Handlers \u00a4 A collection of handlers. Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access. Source code in mkdocstrings/handlers/base.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 class Handlers : \"\"\"A collection of handlers. Do not instantiate this directly. [The plugin][mkdocstrings.plugin.MkdocstringsPlugin] will keep one instance of this for the purpose of caching. Use [mkdocstrings.plugin.MkdocstringsPlugin.get_handler][] for convenient access. \"\"\" def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : Dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"site_name\" ]) def get_anchors ( self , identifier : str ) -> Sequence [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler . collector , \"fallback_config\" , {}) try : anchors = handler . renderer . get_anchors ( handler . collector . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return () def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ] def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} def get_handler ( self , name : str , handler_config : Optional [ dict ] = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" ) ) self . _handlers [ name ] = module . get_handler ( self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) return self . _handlers [ name ] @property def seen_handlers ( self ) -> Iterable [ BaseHandler ]: \"\"\"Get the handlers that were encountered so far throughout the build. Returns: An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler] (usable only to loop through it). \"\"\" return self . _handlers . values () def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . collector . teardown () self . _handlers . clear () __init__ ( self , config ) \u00a4 Initialize the object. Parameters: Name Type Description Default config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in mkdocstrings/handlers/base.py 385 386 387 388 389 390 391 392 393 394 def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : Dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"site_name\" ]) get_anchors ( self , identifier ) \u00a4 Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Parameters: Name Type Description Default identifier str The identifier (one that collect can accept). required Returns: Type Description Sequence [ str ] A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. Source code in mkdocstrings/handlers/base.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def get_anchors ( self , identifier : str ) -> Sequence [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler . collector , \"fallback_config\" , {}) try : anchors = handler . renderer . get_anchors ( handler . collector . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return () get_handler ( self , name , handler_config = None ) \u00a4 Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required handler_config Optional [ dict ] Configuration passed to the handler. None Returns: Type Description BaseHandler An instance of a subclass of BaseHandler , BaseHandler as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/base.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def get_handler ( self , name : str , handler_config : Optional [ dict ] = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" ) ) self . _handlers [ name ] = module . get_handler ( self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) return self . _handlers [ name ] get_handler_config ( self , name ) \u00a4 Return the global configuration of the given handler. Parameters: Name Type Description Default name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/handlers/base.py 429 430 431 432 433 434 435 436 437 438 439 440 441 def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} get_handler_name ( self , config ) \u00a4 Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/handlers/base.py 415 416 417 418 419 420 421 422 423 424 425 426 427 def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ] seen_handlers ( self ) \u00a4 Get the handlers that were encountered so far throughout the build. Returns: Type Description Iterable [ BaseHandler ] An iterable of instances of BaseHandler Iterable [ BaseHandler ] (usable only to loop through it). Source code in mkdocstrings/handlers/base.py 480 481 482 483 484 485 486 487 488 @property def seen_handlers ( self ) -> Iterable [ BaseHandler ]: \"\"\"Get the handlers that were encountered so far throughout the build. Returns: An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler] (usable only to loop through it). \"\"\" return self . _handlers . values () teardown ( self ) \u00a4 Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/base.py 490 491 492 493 494 def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . collector . teardown () self . _handlers . clear () ThemeNotSupported ( Exception ) \u00a4 An exception raised to tell a theme is not supported. Source code in mkdocstrings/handlers/base.py 40 41 class ThemeNotSupported ( Exception ): \"\"\"An exception raised to tell a theme is not supported.\"\"\" do_any ( seq , attribute = None ) \u00a4 Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\"Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"base.py"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseCollector","text":"The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. Source code in mkdocstrings/handlers/base.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class BaseCollector ( ABC ): \"\"\"The base collector class. Inherit from this class to implement a collector. You will have to implement the `collect` method. You can also implement the `teardown` method. \"\"\" @abstractmethod def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section) def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\"","title":"BaseCollector"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseCollector.collect","text":"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description CollectorItem Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/base.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 @abstractmethod def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section)","title":"collect()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseCollector.teardown","text":"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in mkdocstrings/handlers/base.py 343 344 345 346 347 348 def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\"","title":"teardown()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseHandler","text":"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: Name Type Description domain str The cross-documentation domain/language for this handler. enable_inventory bool Whether this handler is interested in enabling the creation of the objects.inv Sphinx inventory file. Source code in mkdocstrings/handlers/base.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 class BaseHandler : \"\"\"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: domain: The cross-documentation domain/language for this handler. enable_inventory: Whether this handler is interested in enabling the creation of the `objects.inv` Sphinx inventory file. \"\"\" domain : str = \"default\" enable_inventory : bool = False def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer","title":"BaseHandler"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseHandler.__init__","text":"Initialize the object. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/base.py 367 368 369 370 371 372 373 374 375 def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer","title":"__init__()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer","text":"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a fallback_theme class-variable. To add custom CSS, add an extra_css variable or create an 'style.css' file beside the templates. Source code in mkdocstrings/handlers/base.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 class BaseRenderer ( ABC ): \"\"\"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the `render` method. You can also override the `update_env` method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a `fallback_theme` class-variable. To add custom CSS, add an `extra_css` variable or create an 'style.css' file beside the templates. \"\"\" fallback_theme : str = \"\" extra_css = \"\" def __init__ ( self , handler : str , theme : str , custom_templates : Optional [ str ] = None , directory : str = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. directory: Deprecated and renamed as `handler`. \"\"\" # TODO: remove at some point if directory : warnings . warn ( \"The 'directory' keyword parameter is deprecated and renamed 'handler'. \" , DeprecationWarning , ) if not handler : handler = directory paths = [] themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) # noqa: WPS601 break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : List [ Element ] = [] self . _md : Markdown = None # type: ignore # To be populated in `update_env`. @abstractmethod def render ( self , data : CollectorItem , config : dict ) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section) def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : # noqa: WPS609 theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : # noqa: WPS609,WPS440 theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" ) def get_anchors ( self , data : CollectorItem ) -> Sequence [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore except AttributeError : return () def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset () def do_heading ( self , content : str , heading_level : int , * , role : Optional [ str ] = None , hidden : bool = False , toc_label : Optional [ str ] = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( el , Markup ) else content # type: ignore el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: W0613 (unused argument 'config') \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading def _update_env ( self , md : Markdown , config : dict ): extensions = config [ \"mdx\" ] + [ MkdocstringsInnerExtension ( self . _headings )] new_md = Markdown ( extensions = extensions , extension_configs = config [ \"mdx_configs\" ]) # MkDocs adds its own (required) extension that's not part of the config. Propagate it. if \"relpath\" in md . treeprocessors : new_md . treeprocessors . register ( md . treeprocessors [ \"relpath\" ], \"relpath\" , priority = 0 ) self . update_env ( new_md , config )","title":"BaseRenderer"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.__init__","text":"Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default handler str The name of the handler. required theme str The name of theme to use. required custom_templates Optional [ str ] Directory containing custom templates. None directory str Deprecated and renamed as handler . None Source code in mkdocstrings/handlers/base.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , handler : str , theme : str , custom_templates : Optional [ str ] = None , directory : str = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. directory: Deprecated and renamed as `handler`. \"\"\" # TODO: remove at some point if directory : warnings . warn ( \"The 'directory' keyword parameter is deprecated and renamed 'handler'. \" , DeprecationWarning , ) if not handler : handler = directory paths = [] themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) # noqa: WPS601 break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : List [ Element ] = [] self . _md : Markdown = None # type: ignore # To be populated in `update_env`.","title":"__init__()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.do_convert_markdown","text":"Render Markdown text; for use inside templates. Parameters: Name Type Description Default text str The text to convert. required heading_level int The base heading level to start all Markdown headings from. required html_id str The HTML id of the element that's considered the parent of this element. '' strip_paragraph bool Whether to exclude the tag from around the whole output. False Returns: Type Description Markup An HTML string. Source code in mkdocstrings/handlers/base.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset ()","title":"do_convert_markdown()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.do_heading","text":"Render an HTML heading and register it for the table of contents. For use inside templates. Parameters: Name Type Description Default content str The HTML within the heading. required heading_level int The level of heading (e.g. 3 -> h3 ). required role Optional [ str ] An optional role for the object bound to this heading. None hidden bool If True, only register it for the table of contents, don't render anything. False toc_label Optional [ str ] The title to use in the table of contents ('data-toc-label' attribute). None **attributes str Any extra HTML attributes of the heading. {} Returns: Type Description Markup An HTML string. Source code in mkdocstrings/handlers/base.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def do_heading ( self , content : str , heading_level : int , * , role : Optional [ str ] = None , hidden : bool = False , toc_label : Optional [ str ] = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( el , Markup ) else content # type: ignore el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html )","title":"do_heading()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.get_anchors","text":"Return the possible identifiers (HTML anchors) for a collected item. Parameters: Name Type Description Default data CollectorItem The collected data. required Returns: Type Description Sequence [ str ] The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. Source code in mkdocstrings/handlers/base.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def get_anchors ( self , data : CollectorItem ) -> Sequence [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore except AttributeError : return ()","title":"get_anchors()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.get_headings","text":"Return and clear the headings gathered so far. Returns: Type Description Sequence [ Element ] A list of HTML elements. Source code in mkdocstrings/handlers/base.py 282 283 284 285 286 287 288 289 290 def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result","title":"get_headings()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.get_templates_dir","text":"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Parameters: Name Type Description Default handler str The name of the handler to get the templates directory of. required Raises: Type Description FileNotFoundError When the templates directory cannot be found. Returns: Type Description Path The templates directory path. Source code in mkdocstrings/handlers/base.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : # noqa: WPS609 theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : # noqa: WPS609,WPS440 theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" )","title":"get_templates_dir()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data CollectorItem The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/base.py 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def render ( self , data : CollectorItem , config : dict ) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section)","title":"render()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in mkdocstrings/handlers/base.py 292 293 294 295 296 297 298 299 300 301 302 303 def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: W0613 (unused argument 'config') \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading","title":"update_env()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.CollectionError","text":"An exception raised when some collection of data failed. Source code in mkdocstrings/handlers/base.py 36 37 class CollectionError ( Exception ): \"\"\"An exception raised when some collection of data failed.\"\"\"","title":"CollectionError"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers","text":"A collection of handlers. Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access. Source code in mkdocstrings/handlers/base.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 class Handlers : \"\"\"A collection of handlers. Do not instantiate this directly. [The plugin][mkdocstrings.plugin.MkdocstringsPlugin] will keep one instance of this for the purpose of caching. Use [mkdocstrings.plugin.MkdocstringsPlugin.get_handler][] for convenient access. \"\"\" def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : Dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"site_name\" ]) def get_anchors ( self , identifier : str ) -> Sequence [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler . collector , \"fallback_config\" , {}) try : anchors = handler . renderer . get_anchors ( handler . collector . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return () def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ] def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} def get_handler ( self , name : str , handler_config : Optional [ dict ] = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" ) ) self . _handlers [ name ] = module . get_handler ( self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) return self . _handlers [ name ] @property def seen_handlers ( self ) -> Iterable [ BaseHandler ]: \"\"\"Get the handlers that were encountered so far throughout the build. Returns: An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler] (usable only to loop through it). \"\"\" return self . _handlers . values () def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . collector . teardown () self . _handlers . clear ()","title":"Handlers"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in mkdocstrings/handlers/base.py 385 386 387 388 389 390 391 392 393 394 def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : Dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"site_name\" ])","title":"__init__()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_anchors","text":"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Parameters: Name Type Description Default identifier str The identifier (one that collect can accept). required Returns: Type Description Sequence [ str ] A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. Source code in mkdocstrings/handlers/base.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def get_anchors ( self , identifier : str ) -> Sequence [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler . collector , \"fallback_config\" , {}) try : anchors = handler . renderer . get_anchors ( handler . collector . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return ()","title":"get_anchors()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_handler","text":"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required handler_config Optional [ dict ] Configuration passed to the handler. None Returns: Type Description BaseHandler An instance of a subclass of BaseHandler , BaseHandler as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/base.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def get_handler ( self , name : str , handler_config : Optional [ dict ] = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" ) ) self . _handlers [ name ] = module . get_handler ( self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) return self . _handlers [ name ]","title":"get_handler()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_handler_config","text":"Return the global configuration of the given handler. Parameters: Name Type Description Default name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/handlers/base.py 429 430 431 432 433 434 435 436 437 438 439 440 441 def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {}","title":"get_handler_config()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_handler_name","text":"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/handlers/base.py 415 416 417 418 419 420 421 422 423 424 425 426 427 def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ]","title":"get_handler_name()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.seen_handlers","text":"Get the handlers that were encountered so far throughout the build. Returns: Type Description Iterable [ BaseHandler ] An iterable of instances of BaseHandler Iterable [ BaseHandler ] (usable only to loop through it). Source code in mkdocstrings/handlers/base.py 480 481 482 483 484 485 486 487 488 @property def seen_handlers ( self ) -> Iterable [ BaseHandler ]: \"\"\"Get the handlers that were encountered so far throughout the build. Returns: An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler] (usable only to loop through it). \"\"\" return self . _handlers . values ()","title":"seen_handlers()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.teardown","text":"Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/base.py 490 491 492 493 494 def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . collector . teardown () self . _handlers . clear ()","title":"teardown()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.ThemeNotSupported","text":"An exception raised to tell a theme is not supported. Source code in mkdocstrings/handlers/base.py 40 41 class ThemeNotSupported ( Exception ): \"\"\"An exception raised to tell a theme is not supported.\"\"\"","title":"ThemeNotSupported"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.do_any","text":"Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\"Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"do_any()"},{"location":"reference/handlers/rendering/","text":"This module holds helpers responsible for augmentations to the Markdown sub-documents produced by handlers. HeadingShiftingTreeprocessor ( Treeprocessor ) \u00a4 Shift levels of all Markdown headings according to the configured base level. Source code in mkdocstrings/handlers/rendering.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class HeadingShiftingTreeprocessor ( Treeprocessor ): \"\"\"Shift levels of all Markdown headings according to the configured base level.\"\"\" name = \"mkdocstrings_headings\" regex = re . compile ( r \"([Hh])([1-6])\" ) shift_by : int \"\"\"The number of heading \"levels\" to add to every heading. `<h2>` with `shift_by = 3` becomes `<h5>`.\"\"\" def __init__ ( self , md : Markdown , shift_by : int ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. shift_by: The number of heading \"levels\" to add to every heading. \"\"\" super () . __init__ ( md ) self . shift_by = shift_by def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . shift_by : return for el in root . iter (): match = self . regex . fullmatch ( el . tag ) if match : level = int ( match [ 2 ]) + self . shift_by level = max ( 1 , min ( level , 6 )) el . tag = f \" { match [ 1 ] }{ level } \" __init__ ( self , md , shift_by ) \u00a4 Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required shift_by int The number of heading \"levels\" to add to every heading. required Source code in mkdocstrings/handlers/rendering.py 167 168 169 170 171 172 173 174 175 def __init__ ( self , md : Markdown , shift_by : int ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. shift_by: The number of heading \"levels\" to add to every heading. \"\"\" super () . __init__ ( md ) self . shift_by = shift_by Highlighter ( Highlight ) \u00a4 Code highlighter that tries to match the Markdown configuration. Picking up the global config and defaults works only if you use the codehilite or pymdownx.highlight (recommended) Markdown extension. If you use pymdownx.highlight , highlighting settings are picked up from it, and the default CSS class is .highlight . This also means the default of guess_lang: false . Otherwise, if you use the codehilite extension, settings are picked up from it, and the default CSS class is .codehilite . Also consider setting guess_lang: false . If neither are added to markdown_extensions , highlighting is enabled anyway. This is for backwards compatibility. If you really want to disable highlighting even in mkdocstrings , add one of these extensions anyway and set use_pygments: false . The underlying implementation is pymdownx.highlight regardless. Source code in mkdocstrings/handlers/rendering.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Highlighter ( Highlight ): \"\"\"Code highlighter that tries to match the Markdown configuration. Picking up the global config and defaults works only if you use the `codehilite` or `pymdownx.highlight` (recommended) Markdown extension. - If you use `pymdownx.highlight`, highlighting settings are picked up from it, and the default CSS class is `.highlight`. This also means the default of `guess_lang: false`. - Otherwise, if you use the `codehilite` extension, settings are picked up from it, and the default CSS class is `.codehilite`. Also consider setting `guess_lang: false`. - If neither are added to `markdown_extensions`, highlighting is enabled anyway. This is for backwards compatibility. If you really want to disable highlighting even in *mkdocstrings*, add one of these extensions anyway and set `use_pygments: false`. The underlying implementation is `pymdownx.highlight` regardless. \"\"\" # https://raw.githubusercontent.com/facelessuser/pymdown-extensions/main/docs/src/markdown/extensions/highlight.md _highlight_config_keys = frozenset ( ( \"css_class\" , \"guess_lang\" , \"pygments_style\" , \"noclasses\" , \"use_pygments\" , \"linenums\" , \"linenums_special\" , \"linenums_style\" , \"linenums_class\" , \"extend_pygments_lang\" , \"language_prefix\" , \"code_attr_on_pre\" , \"auto_title\" , \"auto_title_map\" , \"line_spans\" , \"anchor_linenums\" , \"line_anchors\" , ) ) def __init__ ( self , md : Markdown ): \"\"\"Configure to match a `markdown.Markdown` instance. Arguments: md: The Markdown instance to read configs from. \"\"\" config : Dict [ str , Any ] = {} for ext in md . registeredExtensions : if isinstance ( ext , HighlightExtension ) and ( ext . enabled or not config ): config = ext . getConfigs () break # This one takes priority, no need to continue looking if isinstance ( ext , CodeHiliteExtension ) and not config : config = ext . getConfigs () config [ \"language_prefix\" ] = config [ \"lang_prefix\" ] self . _css_class = config . pop ( \"css_class\" , \"highlight\" ) super () . __init__ ( ** { name : opt for name , opt in config . items () if name in self . _highlight_config_keys }) def highlight ( # noqa: W0221 (intentionally different params, we're extending the functionality) self , src : str , language : Optional [ str ] = None , * , inline : bool = False , dedent : bool = True , linenums : Optional [ bool ] = None , ** kwargs : Any , ) -> str : \"\"\"Highlight a code-snippet. Arguments: src: The code to highlight. language: Explicitly tell what language to use for highlighting. inline: Whether to highlight as inline. dedent: Whether to dedent the code before highlighting it or not. linenums: Whether to add line numbers in the result. **kwargs: Pass on to `pymdownx.highlight.Highlight.highlight`. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if isinstance ( src , Markup ): src = src . unescape () if dedent : src = textwrap . dedent ( src ) kwargs . setdefault ( \"css_class\" , self . _css_class ) old_linenums = self . linenums # type: ignore if linenums is not None : self . linenums = linenums try : result = super () . highlight ( src , language , inline = inline , ** kwargs ) finally : self . linenums = old_linenums if inline : return Markup ( f '<code class=\" { kwargs [ \"css_class\" ] } language- { language } \"> { result . text } </code>' ) return Markup ( result ) __init__ ( self , md ) \u00a4 Configure to match a markdown.Markdown instance. Parameters: Name Type Description Default md Markdown The Markdown instance to read configs from. required Source code in mkdocstrings/handlers/rendering.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , md : Markdown ): \"\"\"Configure to match a `markdown.Markdown` instance. Arguments: md: The Markdown instance to read configs from. \"\"\" config : Dict [ str , Any ] = {} for ext in md . registeredExtensions : if isinstance ( ext , HighlightExtension ) and ( ext . enabled or not config ): config = ext . getConfigs () break # This one takes priority, no need to continue looking if isinstance ( ext , CodeHiliteExtension ) and not config : config = ext . getConfigs () config [ \"language_prefix\" ] = config [ \"lang_prefix\" ] self . _css_class = config . pop ( \"css_class\" , \"highlight\" ) super () . __init__ ( ** { name : opt for name , opt in config . items () if name in self . _highlight_config_keys }) highlight ( self , src , language = None , * , inline = False , dedent = True , linenums = None , ** kwargs ) \u00a4 Highlight a code-snippet. Parameters: Name Type Description Default src str The code to highlight. required language Optional [ str ] Explicitly tell what language to use for highlighting. None inline bool Whether to highlight as inline. False dedent bool Whether to dedent the code before highlighting it or not. True linenums Optional [ bool ] Whether to add line numbers in the result. None **kwargs Any Pass on to pymdownx.highlight.Highlight.highlight . {} Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/rendering.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def highlight ( # noqa: W0221 (intentionally different params, we're extending the functionality) self , src : str , language : Optional [ str ] = None , * , inline : bool = False , dedent : bool = True , linenums : Optional [ bool ] = None , ** kwargs : Any , ) -> str : \"\"\"Highlight a code-snippet. Arguments: src: The code to highlight. language: Explicitly tell what language to use for highlighting. inline: Whether to highlight as inline. dedent: Whether to dedent the code before highlighting it or not. linenums: Whether to add line numbers in the result. **kwargs: Pass on to `pymdownx.highlight.Highlight.highlight`. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if isinstance ( src , Markup ): src = src . unescape () if dedent : src = textwrap . dedent ( src ) kwargs . setdefault ( \"css_class\" , self . _css_class ) old_linenums = self . linenums # type: ignore if linenums is not None : self . linenums = linenums try : result = super () . highlight ( src , language , inline = inline , ** kwargs ) finally : self . linenums = old_linenums if inline : return Markup ( f '<code class=\" { kwargs [ \"css_class\" ] } language- { language } \"> { result . text } </code>' ) return Markup ( result ) IdPrependingTreeprocessor ( Treeprocessor ) \u00a4 Prepend the configured prefix to IDs of all HTML elements. Source code in mkdocstrings/handlers/rendering.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class IdPrependingTreeprocessor ( Treeprocessor ): \"\"\"Prepend the configured prefix to IDs of all HTML elements.\"\"\" name = \"mkdocstrings_ids\" id_prefix : str \"\"\"The prefix to add to every ID. It is prepended without any separator; specify your own separator if needed.\"\"\" def __init__ ( self , md : Markdown , id_prefix : str ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. id_prefix: The prefix to add to every ID. It is prepended without any separator. \"\"\" super () . __init__ ( md ) self . id_prefix = id_prefix def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . id_prefix : return for el in root . iter (): id_attr = el . get ( \"id\" ) if id_attr : el . set ( \"id\" , self . id_prefix + id_attr ) href_attr = el . get ( \"href\" ) if href_attr and href_attr . startswith ( \"#\" ): el . set ( \"href\" , \"#\" + self . id_prefix + href_attr [ 1 :]) name_attr = el . get ( \"name\" ) if name_attr : el . set ( \"name\" , self . id_prefix + name_attr ) if el . tag == \"label\" : for_attr = el . get ( \"for\" ) if for_attr : el . set ( \"for\" , self . id_prefix + for_attr ) __init__ ( self , md , id_prefix ) \u00a4 Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required id_prefix str The prefix to add to every ID. It is prepended without any separator. required Source code in mkdocstrings/handlers/rendering.py 126 127 128 129 130 131 132 133 134 def __init__ ( self , md : Markdown , id_prefix : str ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. id_prefix: The prefix to add to every ID. It is prepended without any separator. \"\"\" super () . __init__ ( md ) self . id_prefix = id_prefix MkdocstringsInnerExtension ( Extension ) \u00a4 Extension that should always be added to Markdown sub-documents that handlers request (and only them). Source code in mkdocstrings/handlers/rendering.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class MkdocstringsInnerExtension ( Extension ): \"\"\"Extension that should always be added to Markdown sub-documents that handlers request (and *only* them).\"\"\" def __init__ ( self , headings : List [ Element ]): \"\"\"Initialize the object. Arguments: headings: A list that will be populated with all HTML heading elements encountered in the document. \"\"\" super () . __init__ () self . headings = headings def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) md . treeprocessors . register ( HeadingShiftingTreeprocessor ( md , 0 ), HeadingShiftingTreeprocessor . name , priority = 12 , ) md . treeprocessors . register ( IdPrependingTreeprocessor ( md , \"\" ), IdPrependingTreeprocessor . name , priority = 4 , # Right after 'toc' (needed because that extension adds ids to headers). ) md . treeprocessors . register ( _HeadingReportingTreeprocessor ( md , self . headings ), _HeadingReportingTreeprocessor . name , priority = 1 , # Close to the end. ) md . treeprocessors . register ( ParagraphStrippingTreeprocessor ( md ), ParagraphStrippingTreeprocessor . name , priority = 0.99 , # Close to the end. ) __init__ ( self , headings ) \u00a4 Initialize the object. Parameters: Name Type Description Default headings List [ Element ] A list that will be populated with all HTML heading elements encountered in the document. required Source code in mkdocstrings/handlers/rendering.py 228 229 230 231 232 233 234 235 def __init__ ( self , headings : List [ Element ]): \"\"\"Initialize the object. Arguments: headings: A list that will be populated with all HTML heading elements encountered in the document. \"\"\" super () . __init__ () self . headings = headings extendMarkdown ( self , md ) \u00a4 Register the extension. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/handlers/rendering.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) md . treeprocessors . register ( HeadingShiftingTreeprocessor ( md , 0 ), HeadingShiftingTreeprocessor . name , priority = 12 , ) md . treeprocessors . register ( IdPrependingTreeprocessor ( md , \"\" ), IdPrependingTreeprocessor . name , priority = 4 , # Right after 'toc' (needed because that extension adds ids to headers). ) md . treeprocessors . register ( _HeadingReportingTreeprocessor ( md , self . headings ), _HeadingReportingTreeprocessor . name , priority = 1 , # Close to the end. ) md . treeprocessors . register ( ParagraphStrippingTreeprocessor ( md ), ParagraphStrippingTreeprocessor . name , priority = 0.99 , # Close to the end. ) ParagraphStrippingTreeprocessor ( Treeprocessor ) \u00a4 Unwraps the element around the whole output. Source code in mkdocstrings/handlers/rendering.py 212 213 214 215 216 217 218 219 220 221 222 class ParagraphStrippingTreeprocessor ( Treeprocessor ): \"\"\"Unwraps the <p> element around the whole output.\"\"\" name = \"mkdocstrings_strip_paragraph\" strip = False def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if self . strip and len ( root ) == 1 and root [ 0 ] . tag == \"p\" : # Turn the single <p> element into the root element and inherit its tag name (it's significant!) root [ 0 ] . tag = root . tag return root [ 0 ] _HeadingReportingTreeprocessor ( Treeprocessor ) \u00a4 Records the heading elements encountered in the document. Source code in mkdocstrings/handlers/rendering.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class _HeadingReportingTreeprocessor ( Treeprocessor ): \"\"\"Records the heading elements encountered in the document.\"\"\" name = \"mkdocstrings_headings_list\" regex = re . compile ( r \"[Hh][1-6]\" ) headings : List [ Element ] \"\"\"The list (the one passed in the initializer) that is used to record the heading elements (by appending to it).\"\"\" def __init__ ( self , md : Markdown , headings : List [ Element ]): super () . __init__ ( md ) self . headings = headings def run ( self , root : Element ): for el in root . iter (): if self . regex . fullmatch ( el . tag ): el = copy . copy ( el ) # 'toc' extension's first pass (which we require to build heading stubs/ids) also edits the HTML. # Undo the permalink edit so we can pass this heading to the outer pass of the 'toc' extension. if len ( el ) > 0 and el [ - 1 ] . get ( \"class\" ) == self . md . treeprocessors [ \"toc\" ] . permalink_class : # noqa: WPS507 del el [ - 1 ] self . headings . append ( el )","title":"rendering.py"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor","text":"Shift levels of all Markdown headings according to the configured base level. Source code in mkdocstrings/handlers/rendering.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class HeadingShiftingTreeprocessor ( Treeprocessor ): \"\"\"Shift levels of all Markdown headings according to the configured base level.\"\"\" name = \"mkdocstrings_headings\" regex = re . compile ( r \"([Hh])([1-6])\" ) shift_by : int \"\"\"The number of heading \"levels\" to add to every heading. `<h2>` with `shift_by = 3` becomes `<h5>`.\"\"\" def __init__ ( self , md : Markdown , shift_by : int ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. shift_by: The number of heading \"levels\" to add to every heading. \"\"\" super () . __init__ ( md ) self . shift_by = shift_by def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . shift_by : return for el in root . iter (): match = self . regex . fullmatch ( el . tag ) if match : level = int ( match [ 2 ]) + self . shift_by level = max ( 1 , min ( level , 6 )) el . tag = f \" { match [ 1 ] }{ level } \"","title":"HeadingShiftingTreeprocessor"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required shift_by int The number of heading \"levels\" to add to every heading. required Source code in mkdocstrings/handlers/rendering.py 167 168 169 170 171 172 173 174 175 def __init__ ( self , md : Markdown , shift_by : int ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. shift_by: The number of heading \"levels\" to add to every heading. \"\"\" super () . __init__ ( md ) self . shift_by = shift_by","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.Highlighter","text":"Code highlighter that tries to match the Markdown configuration. Picking up the global config and defaults works only if you use the codehilite or pymdownx.highlight (recommended) Markdown extension. If you use pymdownx.highlight , highlighting settings are picked up from it, and the default CSS class is .highlight . This also means the default of guess_lang: false . Otherwise, if you use the codehilite extension, settings are picked up from it, and the default CSS class is .codehilite . Also consider setting guess_lang: false . If neither are added to markdown_extensions , highlighting is enabled anyway. This is for backwards compatibility. If you really want to disable highlighting even in mkdocstrings , add one of these extensions anyway and set use_pygments: false . The underlying implementation is pymdownx.highlight regardless. Source code in mkdocstrings/handlers/rendering.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Highlighter ( Highlight ): \"\"\"Code highlighter that tries to match the Markdown configuration. Picking up the global config and defaults works only if you use the `codehilite` or `pymdownx.highlight` (recommended) Markdown extension. - If you use `pymdownx.highlight`, highlighting settings are picked up from it, and the default CSS class is `.highlight`. This also means the default of `guess_lang: false`. - Otherwise, if you use the `codehilite` extension, settings are picked up from it, and the default CSS class is `.codehilite`. Also consider setting `guess_lang: false`. - If neither are added to `markdown_extensions`, highlighting is enabled anyway. This is for backwards compatibility. If you really want to disable highlighting even in *mkdocstrings*, add one of these extensions anyway and set `use_pygments: false`. The underlying implementation is `pymdownx.highlight` regardless. \"\"\" # https://raw.githubusercontent.com/facelessuser/pymdown-extensions/main/docs/src/markdown/extensions/highlight.md _highlight_config_keys = frozenset ( ( \"css_class\" , \"guess_lang\" , \"pygments_style\" , \"noclasses\" , \"use_pygments\" , \"linenums\" , \"linenums_special\" , \"linenums_style\" , \"linenums_class\" , \"extend_pygments_lang\" , \"language_prefix\" , \"code_attr_on_pre\" , \"auto_title\" , \"auto_title_map\" , \"line_spans\" , \"anchor_linenums\" , \"line_anchors\" , ) ) def __init__ ( self , md : Markdown ): \"\"\"Configure to match a `markdown.Markdown` instance. Arguments: md: The Markdown instance to read configs from. \"\"\" config : Dict [ str , Any ] = {} for ext in md . registeredExtensions : if isinstance ( ext , HighlightExtension ) and ( ext . enabled or not config ): config = ext . getConfigs () break # This one takes priority, no need to continue looking if isinstance ( ext , CodeHiliteExtension ) and not config : config = ext . getConfigs () config [ \"language_prefix\" ] = config [ \"lang_prefix\" ] self . _css_class = config . pop ( \"css_class\" , \"highlight\" ) super () . __init__ ( ** { name : opt for name , opt in config . items () if name in self . _highlight_config_keys }) def highlight ( # noqa: W0221 (intentionally different params, we're extending the functionality) self , src : str , language : Optional [ str ] = None , * , inline : bool = False , dedent : bool = True , linenums : Optional [ bool ] = None , ** kwargs : Any , ) -> str : \"\"\"Highlight a code-snippet. Arguments: src: The code to highlight. language: Explicitly tell what language to use for highlighting. inline: Whether to highlight as inline. dedent: Whether to dedent the code before highlighting it or not. linenums: Whether to add line numbers in the result. **kwargs: Pass on to `pymdownx.highlight.Highlight.highlight`. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if isinstance ( src , Markup ): src = src . unescape () if dedent : src = textwrap . dedent ( src ) kwargs . setdefault ( \"css_class\" , self . _css_class ) old_linenums = self . linenums # type: ignore if linenums is not None : self . linenums = linenums try : result = super () . highlight ( src , language , inline = inline , ** kwargs ) finally : self . linenums = old_linenums if inline : return Markup ( f '<code class=\" { kwargs [ \"css_class\" ] } language- { language } \"> { result . text } </code>' ) return Markup ( result )","title":"Highlighter"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.Highlighter.__init__","text":"Configure to match a markdown.Markdown instance. Parameters: Name Type Description Default md Markdown The Markdown instance to read configs from. required Source code in mkdocstrings/handlers/rendering.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , md : Markdown ): \"\"\"Configure to match a `markdown.Markdown` instance. Arguments: md: The Markdown instance to read configs from. \"\"\" config : Dict [ str , Any ] = {} for ext in md . registeredExtensions : if isinstance ( ext , HighlightExtension ) and ( ext . enabled or not config ): config = ext . getConfigs () break # This one takes priority, no need to continue looking if isinstance ( ext , CodeHiliteExtension ) and not config : config = ext . getConfigs () config [ \"language_prefix\" ] = config [ \"lang_prefix\" ] self . _css_class = config . pop ( \"css_class\" , \"highlight\" ) super () . __init__ ( ** { name : opt for name , opt in config . items () if name in self . _highlight_config_keys })","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.Highlighter.highlight","text":"Highlight a code-snippet. Parameters: Name Type Description Default src str The code to highlight. required language Optional [ str ] Explicitly tell what language to use for highlighting. None inline bool Whether to highlight as inline. False dedent bool Whether to dedent the code before highlighting it or not. True linenums Optional [ bool ] Whether to add line numbers in the result. None **kwargs Any Pass on to pymdownx.highlight.Highlight.highlight . {} Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/rendering.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def highlight ( # noqa: W0221 (intentionally different params, we're extending the functionality) self , src : str , language : Optional [ str ] = None , * , inline : bool = False , dedent : bool = True , linenums : Optional [ bool ] = None , ** kwargs : Any , ) -> str : \"\"\"Highlight a code-snippet. Arguments: src: The code to highlight. language: Explicitly tell what language to use for highlighting. inline: Whether to highlight as inline. dedent: Whether to dedent the code before highlighting it or not. linenums: Whether to add line numbers in the result. **kwargs: Pass on to `pymdownx.highlight.Highlight.highlight`. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if isinstance ( src , Markup ): src = src . unescape () if dedent : src = textwrap . dedent ( src ) kwargs . setdefault ( \"css_class\" , self . _css_class ) old_linenums = self . linenums # type: ignore if linenums is not None : self . linenums = linenums try : result = super () . highlight ( src , language , inline = inline , ** kwargs ) finally : self . linenums = old_linenums if inline : return Markup ( f '<code class=\" { kwargs [ \"css_class\" ] } language- { language } \"> { result . text } </code>' ) return Markup ( result )","title":"highlight()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.IdPrependingTreeprocessor","text":"Prepend the configured prefix to IDs of all HTML elements. Source code in mkdocstrings/handlers/rendering.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class IdPrependingTreeprocessor ( Treeprocessor ): \"\"\"Prepend the configured prefix to IDs of all HTML elements.\"\"\" name = \"mkdocstrings_ids\" id_prefix : str \"\"\"The prefix to add to every ID. It is prepended without any separator; specify your own separator if needed.\"\"\" def __init__ ( self , md : Markdown , id_prefix : str ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. id_prefix: The prefix to add to every ID. It is prepended without any separator. \"\"\" super () . __init__ ( md ) self . id_prefix = id_prefix def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . id_prefix : return for el in root . iter (): id_attr = el . get ( \"id\" ) if id_attr : el . set ( \"id\" , self . id_prefix + id_attr ) href_attr = el . get ( \"href\" ) if href_attr and href_attr . startswith ( \"#\" ): el . set ( \"href\" , \"#\" + self . id_prefix + href_attr [ 1 :]) name_attr = el . get ( \"name\" ) if name_attr : el . set ( \"name\" , self . id_prefix + name_attr ) if el . tag == \"label\" : for_attr = el . get ( \"for\" ) if for_attr : el . set ( \"for\" , self . id_prefix + for_attr )","title":"IdPrependingTreeprocessor"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.IdPrependingTreeprocessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required id_prefix str The prefix to add to every ID. It is prepended without any separator. required Source code in mkdocstrings/handlers/rendering.py 126 127 128 129 130 131 132 133 134 def __init__ ( self , md : Markdown , id_prefix : str ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. id_prefix: The prefix to add to every ID. It is prepended without any separator. \"\"\" super () . __init__ ( md ) self . id_prefix = id_prefix","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.MkdocstringsInnerExtension","text":"Extension that should always be added to Markdown sub-documents that handlers request (and only them). Source code in mkdocstrings/handlers/rendering.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class MkdocstringsInnerExtension ( Extension ): \"\"\"Extension that should always be added to Markdown sub-documents that handlers request (and *only* them).\"\"\" def __init__ ( self , headings : List [ Element ]): \"\"\"Initialize the object. Arguments: headings: A list that will be populated with all HTML heading elements encountered in the document. \"\"\" super () . __init__ () self . headings = headings def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) md . treeprocessors . register ( HeadingShiftingTreeprocessor ( md , 0 ), HeadingShiftingTreeprocessor . name , priority = 12 , ) md . treeprocessors . register ( IdPrependingTreeprocessor ( md , \"\" ), IdPrependingTreeprocessor . name , priority = 4 , # Right after 'toc' (needed because that extension adds ids to headers). ) md . treeprocessors . register ( _HeadingReportingTreeprocessor ( md , self . headings ), _HeadingReportingTreeprocessor . name , priority = 1 , # Close to the end. ) md . treeprocessors . register ( ParagraphStrippingTreeprocessor ( md ), ParagraphStrippingTreeprocessor . name , priority = 0.99 , # Close to the end. )","title":"MkdocstringsInnerExtension"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.MkdocstringsInnerExtension.__init__","text":"Initialize the object. Parameters: Name Type Description Default headings List [ Element ] A list that will be populated with all HTML heading elements encountered in the document. required Source code in mkdocstrings/handlers/rendering.py 228 229 230 231 232 233 234 235 def __init__ ( self , headings : List [ Element ]): \"\"\"Initialize the object. Arguments: headings: A list that will be populated with all HTML heading elements encountered in the document. \"\"\" super () . __init__ () self . headings = headings","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.MkdocstringsInnerExtension.extendMarkdown","text":"Register the extension. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/handlers/rendering.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) md . treeprocessors . register ( HeadingShiftingTreeprocessor ( md , 0 ), HeadingShiftingTreeprocessor . name , priority = 12 , ) md . treeprocessors . register ( IdPrependingTreeprocessor ( md , \"\" ), IdPrependingTreeprocessor . name , priority = 4 , # Right after 'toc' (needed because that extension adds ids to headers). ) md . treeprocessors . register ( _HeadingReportingTreeprocessor ( md , self . headings ), _HeadingReportingTreeprocessor . name , priority = 1 , # Close to the end. ) md . treeprocessors . register ( ParagraphStrippingTreeprocessor ( md ), ParagraphStrippingTreeprocessor . name , priority = 0.99 , # Close to the end. )","title":"extendMarkdown()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.ParagraphStrippingTreeprocessor","text":"Unwraps the element around the whole output. Source code in mkdocstrings/handlers/rendering.py 212 213 214 215 216 217 218 219 220 221 222 class ParagraphStrippingTreeprocessor ( Treeprocessor ): \"\"\"Unwraps the <p> element around the whole output.\"\"\" name = \"mkdocstrings_strip_paragraph\" strip = False def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if self . strip and len ( root ) == 1 and root [ 0 ] . tag == \"p\" : # Turn the single <p> element into the root element and inherit its tag name (it's significant!) root [ 0 ] . tag = root . tag return root [ 0 ]","title":"ParagraphStrippingTreeprocessor"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering._HeadingReportingTreeprocessor","text":"Records the heading elements encountered in the document. Source code in mkdocstrings/handlers/rendering.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class _HeadingReportingTreeprocessor ( Treeprocessor ): \"\"\"Records the heading elements encountered in the document.\"\"\" name = \"mkdocstrings_headings_list\" regex = re . compile ( r \"[Hh][1-6]\" ) headings : List [ Element ] \"\"\"The list (the one passed in the initializer) that is used to record the heading elements (by appending to it).\"\"\" def __init__ ( self , md : Markdown , headings : List [ Element ]): super () . __init__ ( md ) self . headings = headings def run ( self , root : Element ): for el in root . iter (): if self . regex . fullmatch ( el . tag ): el = copy . copy ( el ) # 'toc' extension's first pass (which we require to build heading stubs/ids) also edits the HTML. # Undo the permalink edit so we can pass this heading to the outer pass of the 'toc' extension. if len ( el ) > 0 and el [ - 1 ] . get ( \"class\" ) == self . md . treeprocessors [ \"toc\" ] . permalink_class : # noqa: WPS507 del el [ - 1 ] self . headings . append ( el )","title":"_HeadingReportingTreeprocessor"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}