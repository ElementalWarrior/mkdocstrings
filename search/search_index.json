{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings \u00a4 Automatic documentation from sources, for MkDocs . Features Python handler features Requirements Installation Quick usage Features \u00a4 Language-agnostic: just like MkDocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it with any programming language, as long as there is a handler for it. The Python handler is built-in. Others are external. Maybe you'd like to add another one to the list? Multiple themes support: each handler can offer multiple themes. Currently, we offer the Material theme as well as basic support for the ReadTheDocs theme for the Python handler. Cross-links across pages: mkdocstrings makes it possible to reference headings in other Markdown files with the classic Markdown linking syntax: [identifier][] or [title][identifier] -- and you don't need to remember which exact page this object was on. This works for any heading that's produced by a mkdocstrings language handler, and you can opt to include any Markdown heading into the global referencing scheme. Note : in versions prior to 0.15 all Markdown headers were included, but now you need to opt in . Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by MkDocs when serving the documentation, for auto-reload. Reasonable defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Python handler features \u00a4 Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. reStructuredText-style sections support in docstrings: pytkdocs understands all the reStructuredText fields , and returns structured data for mkdocstrings to render them. Note: only RST style is supported, not the whole markup. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Support for reStructuredText in docstrings: pytkdocs can parse simple RST. Every object has a TOC entry: we render a heading for each object, meaning MkDocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF: Roadmap \u00a4 See the Feature Roadmap issue on the bugtracker. Requirements \u00a4 mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material Installation \u00a4 With pip : python3.6 -m pip install mkdocstrings With conda : conda install -c conda-forge mkdocstrings Quick usage \u00a4 # mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference ::: my_library.my_module.my_class See the Usage section of the docs for more examples!","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from sources, for MkDocs . Features Python handler features Requirements Installation Quick usage","title":"mkdocstrings"},{"location":"#features","text":"Language-agnostic: just like MkDocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it with any programming language, as long as there is a handler for it. The Python handler is built-in. Others are external. Maybe you'd like to add another one to the list? Multiple themes support: each handler can offer multiple themes. Currently, we offer the Material theme as well as basic support for the ReadTheDocs theme for the Python handler. Cross-links across pages: mkdocstrings makes it possible to reference headings in other Markdown files with the classic Markdown linking syntax: [identifier][] or [title][identifier] -- and you don't need to remember which exact page this object was on. This works for any heading that's produced by a mkdocstrings language handler, and you can opt to include any Markdown heading into the global referencing scheme. Note : in versions prior to 0.15 all Markdown headers were included, but now you need to opt in . Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by MkDocs when serving the documentation, for auto-reload. Reasonable defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs.","title":"Features"},{"location":"#python-handler-features","text":"Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. reStructuredText-style sections support in docstrings: pytkdocs understands all the reStructuredText fields , and returns structured data for mkdocstrings to render them. Note: only RST style is supported, not the whole markup. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Support for reStructuredText in docstrings: pytkdocs can parse simple RST. Every object has a TOC entry: we render a heading for each object, meaning MkDocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF:","title":"Python handler features"},{"location":"#roadmap","text":"See the Feature Roadmap issue on the bugtracker.","title":"Roadmap"},{"location":"#requirements","text":"mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install mkdocstrings With conda : conda install -c conda-forge mkdocstrings","title":"Installation"},{"location":"#quick-usage","text":"# mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference ::: my_library.my_module.my_class See the Usage section of the docs for more examples!","title":"Quick usage"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.15.0 - 2021-02-28 \u00a4 Compare with 0.14.0 Breaking Changes \u00a4 The following two items are possible breaking changes: Cross-linking to arbitrary headings now requires to opt-in to the autorefs plugin, which is installed as a dependency of mkdocstrings . See Cross-references to any Markdown heading . mkdocstrings now respects your configured code highlighting method, so if you are using the CodeHilite extension, the .highlight CSS class in the rendered HTML will become .codehilite . So make sure to adapt your extra CSS accordingly. Or just switch to using pymdownx.highlight , it's better supported by mkdocstrings anyway. See Syntax highlighting . Most of the CSS rules that mkdocstrings used to recommend for manual addition, now become mandatory (auto-injected into the site). This shouldn't break any of your styles, but you are welcome to remove the now-redundant lines that you had copied into extra_css , similarly to this diff . Features \u00a4 Nicer-looking error outputs - no tracebacks from mkdocstrings ( 6baf720 by Oleh Prypin). PR #230 Let handlers add CSS to the pages, do so for Python handler ( 05c7a3f by Oleh Prypin). Issue #189 , PR #218 Allow linking to an object heading not only by its canonical identifier, but also by its possible aliases ( 4789950 by Oleh Prypin). PR #217 Bug Fixes \u00a4 Propagate the CSS class to inline highlighting as well ( c7d80e6 by Oleh Prypin). PR #245 Don't double-escape characters in highlighted headings ( 6357144 by Oleh Prypin). Issue #228 , PR #241 Code Refactoring \u00a4 Use the autorefs plugin from its new external location ( e2d74ef by Oleh Prypin). PR #235 Split out Markdown extensions from handlers to handlers.rendering ( 7533852 by Oleh Prypin). PR #233 Theme-agnostic code highlighting, respecting configs ( f9ea009 by Oleh Prypin). PR #202 Split out autorefs plugin, make it optional ( fc67656 by Oleh Prypin). PR #220 Remove the extra wrapper div from the final doc ( 7fe438c by Oleh Prypin). PR #209 Don't re-parse the whole subdoc, expose only headings ( 15f84f9 by Oleh Prypin). PR #209 Actually exclude hidden headings from the doc ( 0fdb082 by Oleh Prypin). PR #209 0.14.0 - 2021-01-06 \u00a4 Compare with 0.13.6 Special thanks to Oleh @oprypin Prypin who did an amazing job (this is a euphemism) at improving mkdocstrings , fixing hard-to-fix bugs with clever solutions, implementing great new features and refactoring the code for better performance and readability! Thanks Oleh! Bug Fixes \u00a4 Fix double code tags ( e84d401 by Timoth\u00e9e Mazzucotelli). Don't mutate the original Markdown config for permalinks ( 8f6b163 by Oleh Prypin). Preserve text immediately before an autodoc ( 07466fa by Oleh Prypin). PR #207 Remove href attributes from headings in templates ( d5602ff by Oleh Prypin). PR #204 Don't let toc extension append its permalink twice ( a154f5c by Oleh Prypin). PR #203 Fix undefined entity for &para; ( 2c29211 by Timoth\u00e9e Mazzucotelli). Make ids of Markdown sub-documents prefixed with the parent item id ( d493d33 by Oleh Prypin). Issue #186 and #193 , PR #199 More lenient regex for data-mkdocstrings-identifier ( dcfec8e by Oleh Prypin). Shift Markdown headings according to the current heading_level ( 13f41ae by Oleh Prypin). Issue #192 , PR #195 Fix footnotes appearing in all following objects ( af24bc2 by Oleh Prypin). Issue #186 , PR #195 Fix cross-references from the root index page ( 9c9f2a0 by Oleh Prypin). Issue #184 , PR #185 Fix incorrect argument name passed to Markdown ( 10ce502 by Timoth\u00e9e Mazzucotelli). Fix error when a digit immediately follows a code tag ( 9b92341 by Oleh Prypin). Issue #169 , PR #175 Detecting paths relative to template directory in logging ( a50046b by Oleh Prypin). Issue #166 Code Refactoring \u00a4 BlockProcessor already receives strings, use them as such ( bcf7da9 by Oleh Prypin). Remove some unused code ( 8504084 by Oleh Prypin). PR #206 Improve XML parsing error handling ( ad86410 by Timoth\u00e9e Mazzucotelli). Explicitly use MarkupSafe ( 6b9ebe7 by Oleh Prypin). Split out the handler cache, expose it through the plugin ( 6453026 by Oleh Prypin). Issue #179 , PR #191 Use ChainMap instead of copying dicts ( c634d2c by Oleh Prypin). PR #171 Rename logging to loggers to avoid confusion ( 7a119cc by Timoth\u00e9e Mazzucotelli). Simplify logging ( 409f93e by Timoth\u00e9e Mazzucotelli). Features \u00a4 Allow specifying heading_level as a Markdown heading ( 10efc28 by Oleh Prypin). PR #170 Allow any characters in identifiers ( 7ede68a by Oleh Prypin). PR #174 Allow namespace packages for handlers ( 39b0465 by Timoth\u00e9e Mazzucotelli). Add template debugging/logging ( 33b32c1 by Timoth\u00e9e Mazzucotelli). Add initial support for the ReadTheDocs theme ( 1028115 by Timoth\u00e9e Mazzucotelli). Issue #107 , PR #159 Add option to show type annotations in signatures ( f94ce9b by Timoth\u00e9e Mazzucotelli). Issue #106 Packaging \u00a4 Accept verions of pytkdocs up to 0.10.x (see changelog ). Performance Improvements \u00a4 Call update_env only once per Markdown instance ( b198c74 by Oleh Prypin). PR #201 Disable Jinja's auto_reload to reduce disk reads ( 3b28c58 by Oleh Prypin). PR #200 Rework autorefs replacement to not re-parse the final HTML ( 22a9e4b by Oleh Prypin). Issue #187 , PR #188 0.13.6 - 2020-09-28 \u00a4 Compare with 0.13.5 Bug Fixes \u00a4 Fix rendering when clicking on hidden toc entries ( 2af4d31 by Timoth\u00e9e Mazzucotelli). Issue #60 . 0.13.5 - 2020-09-28 \u00a4 Compare with 0.13.4 Packaging \u00a4 Accept pytkdocs version up to 0.9.x ( changelog ). 0.13.4 - 2020-09-25 \u00a4 Compare with 0.13.3 Bug Fixes \u00a4 Bring back arbitrary **config to Python handler ( fca7d4c by Florimond Manca). Issue #154 , PR #155 0.13.3 - 2020-09-25 \u00a4 Compare with 0.13.2 Packaging \u00a4 Accept pytkdocs version up to 0.8.x ( changelog ). 0.13.2 - 2020-09-08 \u00a4 Compare with 0.13.1 Bug Fixes \u00a4 Fix relative URLs when use_directory_urls is false ( 421d189 by Timoth\u00e9e Mazzucotelli). References: #149 0.13.1 - 2020-09-03 \u00a4 Compare with 0.13.0 Bug Fixes \u00a4 Use relative links for cross-references ( 9c77f1f by Timoth\u00e9e Mazzucotelli). References: #144 , #147 0.13.0 - 2020-08-21 \u00a4 Compare with 0.12.2 Bug Fixes \u00a4 Accept dashes in module names ( fcf79d0 by Timoth\u00e9e Mazzucotelli). References: #140 Features \u00a4 Add option to show full path of direct members only ( d1b9401 by Aaron Dunmore). References: #134 , #136 Packaging \u00a4 Accept pymdown-extensions versions up to 0.8.x ( see release notes ) ( 178d48d by Hugo van Kemenade). PR #146 0.12.2 - 2020-07-24 \u00a4 Compare with 0.12.1 Packaging \u00a4 Accept pytkdocs version up to 0.7.x ( changelog ). 0.12.1 - 2020-07-07 \u00a4 Compare with 0.12.0 Bug Fixes \u00a4 Fix HTML-escaped sequence parsing as XML ( db297f1 by Timoth\u00e9e Mazzucotelli). Allow running mkdocs from non-default interpreter ( 283dd7b by Jared Khan). 0.12.0 - 2020-06-14 \u00a4 Compare with 0.11.4 Features \u00a4 Support attributes section in Google-style docstrings ( 8300253 by Timoth\u00e9e Mazzucotelli). References: #88 Support examples section in Google-style docstrings ( 650c754 by Iago Gonz\u00e1lez). References: #112 Packaging \u00a4 Accept pytkdocs version up to 0.6.x ( changelog ). 0.11.4 - 2020-06-08 \u00a4 Compare with 0.11.3 Packaging \u00a4 Accept pytkdocs version up to 0.5.x ( changelog ). If it breaks your docs, please open issues on pytkdocs ' bug-tracker , or pin pytkdocs version to while waiting for bug fixes <0.5.0 . 0.11.3 - 2020-06-07 \u00a4 Compare with 0.11.2 Bug Fixes \u00a4 Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121 0.11.2 - 2020-05-20 \u00a4 Compare with 0.11.1 Packaging \u00a4 Increase pytkdocs version range to accept 0.4.0 ( changelog ). 0.11.1 - 2020-05-14 \u00a4 Compare with 0.11.0 Bug Fixes \u00a4 Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103 0.11.0 - 2020-04-23 \u00a4 Compare with 0.10.3 Bug Fixes \u00a4 Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Features \u00a4 Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82 0.10.3 - 2020-04-10 \u00a4 Compare with 0.10.2 Bug Fixes \u00a4 Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77 Packaging \u00a4 This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs 0.10.2 - 2020-04-07 \u00a4 Compare with 0.10.1 Packaging \u00a4 This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 . 0.10.1 - 2020-04-03 \u00a4 Compare with 0.10.0 Bug Fixes \u00a4 Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68 0.10.0 - 2020-03-27 \u00a4 Compare with 0.9.1 Features \u00a4 Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector . 0.9.1 - 2020-03-21 \u00a4 Compare with 0.9.0 Bug fixes \u00a4 Fix cross-references when deploying to GitHub pages ( 36f804b ). 0.9.0 - 2020-03-21 \u00a4 Compare with 0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users. Features \u00a4 Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting. Bug fixes \u00a4 Various fixes and better error handling. 0.8.0 - 2020-03-04 \u00a4 Compare with 0.7.2 Breaking Changes \u00a4 Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2. 0.7.2 - 2020-03-04 \u00a4 Compare with 0.7.1 Bug Fixes \u00a4 Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ). 0.7.1 - 2020-02-18 \u00a4 Compare with 0.7.0 Bug Fixes \u00a4 Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ). 0.7.0 - 2020-01-13 \u00a4 Compare with 0.6.1 Bug Fixes \u00a4 Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ). Code Refactoring \u00a4 Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ). Features \u00a4 Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ). 0.6.1 - 2020-01-02 \u00a4 Compare with 0.6.0 Bug Fixes \u00a4 Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ). Code Refactoring \u00a4 Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ). 0.6.0 - 2019-12-28 \u00a4 Compare with 0.5.0 Bug Fixes \u00a4 Fix GenericMeta import error on Python 3.7+ ( febf2b9 ). Code Refactoring \u00a4 More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ). 0.5.0 - 2019-12-22 \u00a4 Compare with 0.4.0 Features \u00a4 Use divs in HTML contents to ease styling ( 2a36a0e ). 0.4.0 - 2019-12-22 \u00a4 Compare with 0.3.0 Features \u00a4 Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ). 0.3.0 - 2019-12-21 \u00a4 Compare with 0.2.0 Features \u00a4 Allow object referencing in docstrings ( 2dd50c0 ). 0.2.0 - 2019-12-15 \u00a4 Compare with 0.1.0 Misc \u00a4 Refactor, features, etc. ( 111fa85 ). 0.1.0 - 2019-12-12 \u00a4 Compare with first commit Misc \u00a4 Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#0150-2021-02-28","text":"Compare with 0.14.0","title":"0.15.0 - 2021-02-28"},{"location":"changelog/#breaking-changes","text":"The following two items are possible breaking changes: Cross-linking to arbitrary headings now requires to opt-in to the autorefs plugin, which is installed as a dependency of mkdocstrings . See Cross-references to any Markdown heading . mkdocstrings now respects your configured code highlighting method, so if you are using the CodeHilite extension, the .highlight CSS class in the rendered HTML will become .codehilite . So make sure to adapt your extra CSS accordingly. Or just switch to using pymdownx.highlight , it's better supported by mkdocstrings anyway. See Syntax highlighting . Most of the CSS rules that mkdocstrings used to recommend for manual addition, now become mandatory (auto-injected into the site). This shouldn't break any of your styles, but you are welcome to remove the now-redundant lines that you had copied into extra_css , similarly to this diff .","title":"Breaking Changes"},{"location":"changelog/#features","text":"Nicer-looking error outputs - no tracebacks from mkdocstrings ( 6baf720 by Oleh Prypin). PR #230 Let handlers add CSS to the pages, do so for Python handler ( 05c7a3f by Oleh Prypin). Issue #189 , PR #218 Allow linking to an object heading not only by its canonical identifier, but also by its possible aliases ( 4789950 by Oleh Prypin). PR #217","title":"Features"},{"location":"changelog/#bug-fixes","text":"Propagate the CSS class to inline highlighting as well ( c7d80e6 by Oleh Prypin). PR #245 Don't double-escape characters in highlighted headings ( 6357144 by Oleh Prypin). Issue #228 , PR #241","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Use the autorefs plugin from its new external location ( e2d74ef by Oleh Prypin). PR #235 Split out Markdown extensions from handlers to handlers.rendering ( 7533852 by Oleh Prypin). PR #233 Theme-agnostic code highlighting, respecting configs ( f9ea009 by Oleh Prypin). PR #202 Split out autorefs plugin, make it optional ( fc67656 by Oleh Prypin). PR #220 Remove the extra wrapper div from the final doc ( 7fe438c by Oleh Prypin). PR #209 Don't re-parse the whole subdoc, expose only headings ( 15f84f9 by Oleh Prypin). PR #209 Actually exclude hidden headings from the doc ( 0fdb082 by Oleh Prypin). PR #209","title":"Code Refactoring"},{"location":"changelog/#0140-2021-01-06","text":"Compare with 0.13.6 Special thanks to Oleh @oprypin Prypin who did an amazing job (this is a euphemism) at improving mkdocstrings , fixing hard-to-fix bugs with clever solutions, implementing great new features and refactoring the code for better performance and readability! Thanks Oleh!","title":"0.14.0 - 2021-01-06"},{"location":"changelog/#bug-fixes_1","text":"Fix double code tags ( e84d401 by Timoth\u00e9e Mazzucotelli). Don't mutate the original Markdown config for permalinks ( 8f6b163 by Oleh Prypin). Preserve text immediately before an autodoc ( 07466fa by Oleh Prypin). PR #207 Remove href attributes from headings in templates ( d5602ff by Oleh Prypin). PR #204 Don't let toc extension append its permalink twice ( a154f5c by Oleh Prypin). PR #203 Fix undefined entity for &para; ( 2c29211 by Timoth\u00e9e Mazzucotelli). Make ids of Markdown sub-documents prefixed with the parent item id ( d493d33 by Oleh Prypin). Issue #186 and #193 , PR #199 More lenient regex for data-mkdocstrings-identifier ( dcfec8e by Oleh Prypin). Shift Markdown headings according to the current heading_level ( 13f41ae by Oleh Prypin). Issue #192 , PR #195 Fix footnotes appearing in all following objects ( af24bc2 by Oleh Prypin). Issue #186 , PR #195 Fix cross-references from the root index page ( 9c9f2a0 by Oleh Prypin). Issue #184 , PR #185 Fix incorrect argument name passed to Markdown ( 10ce502 by Timoth\u00e9e Mazzucotelli). Fix error when a digit immediately follows a code tag ( 9b92341 by Oleh Prypin). Issue #169 , PR #175 Detecting paths relative to template directory in logging ( a50046b by Oleh Prypin). Issue #166","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"BlockProcessor already receives strings, use them as such ( bcf7da9 by Oleh Prypin). Remove some unused code ( 8504084 by Oleh Prypin). PR #206 Improve XML parsing error handling ( ad86410 by Timoth\u00e9e Mazzucotelli). Explicitly use MarkupSafe ( 6b9ebe7 by Oleh Prypin). Split out the handler cache, expose it through the plugin ( 6453026 by Oleh Prypin). Issue #179 , PR #191 Use ChainMap instead of copying dicts ( c634d2c by Oleh Prypin). PR #171 Rename logging to loggers to avoid confusion ( 7a119cc by Timoth\u00e9e Mazzucotelli). Simplify logging ( 409f93e by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features_1","text":"Allow specifying heading_level as a Markdown heading ( 10efc28 by Oleh Prypin). PR #170 Allow any characters in identifiers ( 7ede68a by Oleh Prypin). PR #174 Allow namespace packages for handlers ( 39b0465 by Timoth\u00e9e Mazzucotelli). Add template debugging/logging ( 33b32c1 by Timoth\u00e9e Mazzucotelli). Add initial support for the ReadTheDocs theme ( 1028115 by Timoth\u00e9e Mazzucotelli). Issue #107 , PR #159 Add option to show type annotations in signatures ( f94ce9b by Timoth\u00e9e Mazzucotelli). Issue #106","title":"Features"},{"location":"changelog/#packaging","text":"Accept verions of pytkdocs up to 0.10.x (see changelog ).","title":"Packaging"},{"location":"changelog/#performance-improvements","text":"Call update_env only once per Markdown instance ( b198c74 by Oleh Prypin). PR #201 Disable Jinja's auto_reload to reduce disk reads ( 3b28c58 by Oleh Prypin). PR #200 Rework autorefs replacement to not re-parse the final HTML ( 22a9e4b by Oleh Prypin). Issue #187 , PR #188","title":"Performance Improvements"},{"location":"changelog/#0136-2020-09-28","text":"Compare with 0.13.5","title":"0.13.6 - 2020-09-28"},{"location":"changelog/#bug-fixes_2","text":"Fix rendering when clicking on hidden toc entries ( 2af4d31 by Timoth\u00e9e Mazzucotelli). Issue #60 .","title":"Bug Fixes"},{"location":"changelog/#0135-2020-09-28","text":"Compare with 0.13.4","title":"0.13.5 - 2020-09-28"},{"location":"changelog/#packaging_1","text":"Accept pytkdocs version up to 0.9.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0134-2020-09-25","text":"Compare with 0.13.3","title":"0.13.4 - 2020-09-25"},{"location":"changelog/#bug-fixes_3","text":"Bring back arbitrary **config to Python handler ( fca7d4c by Florimond Manca). Issue #154 , PR #155","title":"Bug Fixes"},{"location":"changelog/#0133-2020-09-25","text":"Compare with 0.13.2","title":"0.13.3 - 2020-09-25"},{"location":"changelog/#packaging_2","text":"Accept pytkdocs version up to 0.8.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0132-2020-09-08","text":"Compare with 0.13.1","title":"0.13.2 - 2020-09-08"},{"location":"changelog/#bug-fixes_4","text":"Fix relative URLs when use_directory_urls is false ( 421d189 by Timoth\u00e9e Mazzucotelli). References: #149","title":"Bug Fixes"},{"location":"changelog/#0131-2020-09-03","text":"Compare with 0.13.0","title":"0.13.1 - 2020-09-03"},{"location":"changelog/#bug-fixes_5","text":"Use relative links for cross-references ( 9c77f1f by Timoth\u00e9e Mazzucotelli). References: #144 , #147","title":"Bug Fixes"},{"location":"changelog/#0130-2020-08-21","text":"Compare with 0.12.2","title":"0.13.0 - 2020-08-21"},{"location":"changelog/#bug-fixes_6","text":"Accept dashes in module names ( fcf79d0 by Timoth\u00e9e Mazzucotelli). References: #140","title":"Bug Fixes"},{"location":"changelog/#features_2","text":"Add option to show full path of direct members only ( d1b9401 by Aaron Dunmore). References: #134 , #136","title":"Features"},{"location":"changelog/#packaging_3","text":"Accept pymdown-extensions versions up to 0.8.x ( see release notes ) ( 178d48d by Hugo van Kemenade). PR #146","title":"Packaging"},{"location":"changelog/#0122-2020-07-24","text":"Compare with 0.12.1","title":"0.12.2 - 2020-07-24"},{"location":"changelog/#packaging_4","text":"Accept pytkdocs version up to 0.7.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0121-2020-07-07","text":"Compare with 0.12.0","title":"0.12.1 - 2020-07-07"},{"location":"changelog/#bug-fixes_7","text":"Fix HTML-escaped sequence parsing as XML ( db297f1 by Timoth\u00e9e Mazzucotelli). Allow running mkdocs from non-default interpreter ( 283dd7b by Jared Khan).","title":"Bug Fixes"},{"location":"changelog/#0120-2020-06-14","text":"Compare with 0.11.4","title":"0.12.0 - 2020-06-14"},{"location":"changelog/#features_3","text":"Support attributes section in Google-style docstrings ( 8300253 by Timoth\u00e9e Mazzucotelli). References: #88 Support examples section in Google-style docstrings ( 650c754 by Iago Gonz\u00e1lez). References: #112","title":"Features"},{"location":"changelog/#packaging_5","text":"Accept pytkdocs version up to 0.6.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0114-2020-06-08","text":"Compare with 0.11.3","title":"0.11.4 - 2020-06-08"},{"location":"changelog/#packaging_6","text":"Accept pytkdocs version up to 0.5.x ( changelog ). If it breaks your docs, please open issues on pytkdocs ' bug-tracker , or pin pytkdocs version to while waiting for bug fixes <0.5.0 .","title":"Packaging"},{"location":"changelog/#0113-2020-06-07","text":"Compare with 0.11.2","title":"0.11.3 - 2020-06-07"},{"location":"changelog/#bug-fixes_8","text":"Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121","title":"Bug Fixes"},{"location":"changelog/#0112-2020-05-20","text":"Compare with 0.11.1","title":"0.11.2 - 2020-05-20"},{"location":"changelog/#packaging_7","text":"Increase pytkdocs version range to accept 0.4.0 ( changelog ).","title":"Packaging"},{"location":"changelog/#0111-2020-05-14","text":"Compare with 0.11.0","title":"0.11.1 - 2020-05-14"},{"location":"changelog/#bug-fixes_9","text":"Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103","title":"Bug Fixes"},{"location":"changelog/#0110-2020-04-23","text":"Compare with 0.10.3","title":"0.11.0 - 2020-04-23"},{"location":"changelog/#bug-fixes_10","text":"Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86","title":"Bug Fixes"},{"location":"changelog/#features_4","text":"Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82","title":"Features"},{"location":"changelog/#0103-2020-04-10","text":"Compare with 0.10.2","title":"0.10.3 - 2020-04-10"},{"location":"changelog/#bug-fixes_11","text":"Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77","title":"Bug Fixes"},{"location":"changelog/#packaging_8","text":"This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs","title":"Packaging"},{"location":"changelog/#0102-2020-04-07","text":"Compare with 0.10.1","title":"0.10.2 - 2020-04-07"},{"location":"changelog/#packaging_9","text":"This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 .","title":"Packaging"},{"location":"changelog/#0101-2020-04-03","text":"Compare with 0.10.0","title":"0.10.1 - 2020-04-03"},{"location":"changelog/#bug-fixes_12","text":"Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68","title":"Bug Fixes"},{"location":"changelog/#0100-2020-03-27","text":"Compare with 0.9.1","title":"0.10.0 - 2020-03-27"},{"location":"changelog/#features_5","text":"Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector .","title":"Features"},{"location":"changelog/#091-2020-03-21","text":"Compare with 0.9.0","title":"0.9.1 - 2020-03-21"},{"location":"changelog/#bug-fixes_13","text":"Fix cross-references when deploying to GitHub pages ( 36f804b ).","title":"Bug fixes"},{"location":"changelog/#090-2020-03-21","text":"Compare with 0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users.","title":"0.9.0 - 2020-03-21"},{"location":"changelog/#features_6","text":"Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting.","title":"Features"},{"location":"changelog/#bug-fixes_14","text":"Various fixes and better error handling.","title":"Bug fixes"},{"location":"changelog/#080-2020-03-04","text":"Compare with 0.7.2","title":"0.8.0 - 2020-03-04"},{"location":"changelog/#breaking-changes_1","text":"Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2.","title":"Breaking Changes"},{"location":"changelog/#072-2020-03-04","text":"Compare with 0.7.1","title":"0.7.2 - 2020-03-04"},{"location":"changelog/#bug-fixes_15","text":"Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ).","title":"Bug Fixes"},{"location":"changelog/#071-2020-02-18","text":"Compare with 0.7.0","title":"0.7.1 - 2020-02-18"},{"location":"changelog/#bug-fixes_16","text":"Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ).","title":"Bug Fixes"},{"location":"changelog/#070-2020-01-13","text":"Compare with 0.6.1","title":"0.7.0 - 2020-01-13"},{"location":"changelog/#bug-fixes_17","text":"Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ).","title":"Code Refactoring"},{"location":"changelog/#features_7","text":"Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ).","title":"Features"},{"location":"changelog/#061-2020-01-02","text":"Compare with 0.6.0","title":"0.6.1 - 2020-01-02"},{"location":"changelog/#bug-fixes_18","text":"Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_3","text":"Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ).","title":"Code Refactoring"},{"location":"changelog/#060-2019-12-28","text":"Compare with 0.5.0","title":"0.6.0 - 2019-12-28"},{"location":"changelog/#bug-fixes_19","text":"Fix GenericMeta import error on Python 3.7+ ( febf2b9 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_4","text":"More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ).","title":"Code Refactoring"},{"location":"changelog/#050-2019-12-22","text":"Compare with 0.4.0","title":"0.5.0 - 2019-12-22"},{"location":"changelog/#features_8","text":"Use divs in HTML contents to ease styling ( 2a36a0e ).","title":"Features"},{"location":"changelog/#040-2019-12-22","text":"Compare with 0.3.0","title":"0.4.0 - 2019-12-22"},{"location":"changelog/#features_9","text":"Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ).","title":"Features"},{"location":"changelog/#030-2019-12-21","text":"Compare with 0.2.0","title":"0.3.0 - 2019-12-21"},{"location":"changelog/#features_10","text":"Allow object referencing in docstrings ( 2dd50c0 ).","title":"Features"},{"location":"changelog/#020-2019-12-15","text":"Compare with 0.1.0","title":"0.2.0 - 2019-12-15"},{"location":"changelog/#misc","text":"Refactor, features, etc. ( 111fa85 ).","title":"Misc"},{"location":"changelog/#010-2019-12-12","text":"Compare with first commit","title":"0.1.0 - 2019-12-12"},{"location":"changelog/#misc_1","text":"Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Misc"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup Note If it fails for some reason, you'll need to install Poetry manually. You can install it with: python3 -m pip install --user pipx pipx install poetry Now you can try running make setup again, or simply poetry install . You now have the dependencies installed. Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with poetry run duty TASK , or duty TASK if the environment was already activated through poetry shell The Makefile detects if the Poetry environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup Note If it fails for some reason, you'll need to install Poetry manually. You can install it with: python3 -m pip install --user pipx pipx install poetry Now you can try running make setup again, or simply poetry install . You now have the dependencies installed. Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with poetry run duty TASK , or duty TASK if the environment was already activated through poetry shell The Makefile detects if the Poetry environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build mkdocstrings . Thank you! python | poetry | copier-poetry Direct dependencies \u00a4 autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | flakehell | git-changelog | httpx | isort | Jinja2 | jinja2-cli | Markdown | MarkupSafe | mkdocs | mkdocs-autorefs | mkdocs-coverage | mkdocs-gen-files | mkdocs-material | mkdocs-section-index | mypy | pep8-naming | pymdown-extensions | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | pytkdocs | toml Indirect dependencies \u00a4 ansimarkup | apipkg | appdirs | atomicwrites | attrs | bandit | cached-property | certifi | click | colorama | contextvars | coverage | dataclasses | entrypoints | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | future | gitdb | GitPython | h11 | httpcore | idna | immutables | importlib-metadata | iniconfig | joblib | livereload | lunr | mccabe | mkdocs-material-extensions | mypy-extensions | nltk | packaging | pathspec | pbr | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pyparsing | pytest-forked | PyYAML | regex | rfc3986 | six | smmap | sniffio | snowballstemmer | stevedore | termcolor | tornado | tqdm | typed-ast | typing-extensions | urllib3 | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"autoflake | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | flakehell | git-changelog | httpx | isort | Jinja2 | jinja2-cli | Markdown | MarkupSafe | mkdocs | mkdocs-autorefs | mkdocs-coverage | mkdocs-gen-files | mkdocs-material | mkdocs-section-index | mypy | pep8-naming | pymdown-extensions | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | pytkdocs | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | apipkg | appdirs | atomicwrites | attrs | bandit | cached-property | certifi | click | colorama | contextvars | coverage | dataclasses | entrypoints | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | future | gitdb | GitPython | h11 | httpcore | idna | immutables | importlib-metadata | iniconfig | joblib | livereload | lunr | mccabe | mkdocs-material-extensions | mypy-extensions | nltk | packaging | pathspec | pbr | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pyparsing | pytest-forked | PyYAML | regex | rfc3986 | six | smmap | sniffio | snowballstemmer | stevedore | termcolor | tornado | tqdm | typed-ast | typing-extensions | urllib3 | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2019, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"theming/","text":"Themes \u00a4 mkdocstrings can support multiple MkDocs themes. It currently supports supports the Material for MkDocs theme and, partially, the built-in ReadTheDocs theme. Each renderer can fallback to a particular theme when the user selected theme is not supported. For example, the Python renderer will fallback to the Material for MkDocs templates. Customization \u00a4 There is some degree of customization possible in mkdocstrings . First, you can write custom templates to override the theme templates. Second, the provided templates make use of CSS classes, so you can tweak the look and feel with extra CSS rules. Templates \u00a4 To use custom templates and override the theme ones, specify the relative path to your templates directory with the custom_templates global configuration option: mkdocs.yml plugins : - mkdocstrings : custom_templates : templates You directory structure must be identical to the provided templates one: templates \u251c\u2500\u2574<HANDLER 1> \u2502 \u251c\u2500\u2500 <THEME 1> \u2502 \u2514\u2500\u2500 <THEME 2> \u2514\u2500\u2500 <HANDLER 2> \u251c\u2500\u2500 <THEME 1> \u2514\u2500\u2500 <THEME 2> ( Check out the template tree on GitHub ) You don't have to replicate the whole tree, only the handlers, themes or templates you want to override. For example, to override some templates of the Material theme for Python: templates \u2514\u2500\u2500 python \u2514\u2500\u2500 material \u251c\u2500\u2500 parameters.html \u2514\u2500\u2500 exceptions.html In the HTML files, replace the original contents with your modified version. In the future, the templates will use Jinja blocks, so it will be easier to modify a small part of the template without copy-pasting the whole file. The Material theme provides the following template structure: children.html : where the recursion happen, to render all children of an object attribute.html : to render attributes (class-attributes, etc.) class.html : to render classes function.html : to render functions method.html : to render methods module.html : to render modules docstring.html : to render docstrings attributes.html : to render attributes sections of docstrings examples.html : to render examples sections of docstrings exceptions.html : to render exceptions/\"raises\" sections of docstrings parameters.html : to render parameters/arguments sections of docstrings return.html : to render \"return\" sections of docstrings properties.html : to render the properties of an object ( staticmethod , read-only , etc.) signature.html : to render functions and methods signatures Debugging \u00a4 Every template has access to a log function, allowing to log messages as usual: {{ log.debug ( \"A DEBUG message.\" ) }} {{ log.info ( \"An INFO message.\" ) }} {{ log.warning ( \"A WARNING message.\" ) }} {{ log.error ( \"An ERROR message.\" ) }} {{ log.critical ( \"A CRITICAL message.\" ) }} CSS classes \u00a4 The Material theme uses the following CSS classes in the HTML: doc : on all the following elements doc-children : on div s containing the children of an object doc-object : on div s containing an object doc-attribute : on div s containing an attribute doc-class : on div s containing a class doc-function : on div s containing a function doc-method : on div s containing a method doc-module : on div s containing a module doc-heading : on objects headings doc-contents : on div s wrapping the docstring then the children (if any) first : same, but only on the root object's contents div doc-properties : on span s wrapping the object's properties doc-property : on small elements containing a property doc-property-PROPERTY : same, where PROPERTY is replaced by the actual property Example with colorful properties CSS . doc-property { border-radius : 15 px ; padding : 0 5 px ; } . doc-property-special { background-color : blue ; color : white ; } . doc-property-private { background-color : red ; color : white ; } . doc-property-property { background-color : green ; color : white ; } . doc-property-read-only { background-color : yellow ; color : black ; } Result .prop { border-radius: 15px; padding: 0 5px; } special private property read-only As you can see, CSS is not my field of predilection... Syntax highlighting \u00a4 Code blocks that occur in the docstring of an item inserted with mkdocstrings , as well as code blocks (such as Source code ) that mkdocstrings inserts itself, are syntax-highlighted according to the same rules as other normal code blocks in your document. See more details in mkdocstrings.handlers.rendering.Highlighter . As for the CSS class used for code blocks -- it will also match the \"normal\" config, so the default ( .codehilite or .highlight ) will match your chosen Markdown extension for highlighting. Changed in version 0.15 The CSS class used to always be .highlight , but now it depends on the configuration. Long story short, you probably should add pymdownx.highlight to your markdown_extensions , and then use .doc-contents .highlight as the CSS selector in case you want to change something about mkdocstrings' code blocks specifically.","title":"Theming"},{"location":"theming/#themes","text":"mkdocstrings can support multiple MkDocs themes. It currently supports supports the Material for MkDocs theme and, partially, the built-in ReadTheDocs theme. Each renderer can fallback to a particular theme when the user selected theme is not supported. For example, the Python renderer will fallback to the Material for MkDocs templates.","title":"Themes"},{"location":"theming/#customization","text":"There is some degree of customization possible in mkdocstrings . First, you can write custom templates to override the theme templates. Second, the provided templates make use of CSS classes, so you can tweak the look and feel with extra CSS rules.","title":"Customization"},{"location":"theming/#templates","text":"To use custom templates and override the theme ones, specify the relative path to your templates directory with the custom_templates global configuration option: mkdocs.yml plugins : - mkdocstrings : custom_templates : templates You directory structure must be identical to the provided templates one: templates \u251c\u2500\u2574<HANDLER 1> \u2502 \u251c\u2500\u2500 <THEME 1> \u2502 \u2514\u2500\u2500 <THEME 2> \u2514\u2500\u2500 <HANDLER 2> \u251c\u2500\u2500 <THEME 1> \u2514\u2500\u2500 <THEME 2> ( Check out the template tree on GitHub ) You don't have to replicate the whole tree, only the handlers, themes or templates you want to override. For example, to override some templates of the Material theme for Python: templates \u2514\u2500\u2500 python \u2514\u2500\u2500 material \u251c\u2500\u2500 parameters.html \u2514\u2500\u2500 exceptions.html In the HTML files, replace the original contents with your modified version. In the future, the templates will use Jinja blocks, so it will be easier to modify a small part of the template without copy-pasting the whole file. The Material theme provides the following template structure: children.html : where the recursion happen, to render all children of an object attribute.html : to render attributes (class-attributes, etc.) class.html : to render classes function.html : to render functions method.html : to render methods module.html : to render modules docstring.html : to render docstrings attributes.html : to render attributes sections of docstrings examples.html : to render examples sections of docstrings exceptions.html : to render exceptions/\"raises\" sections of docstrings parameters.html : to render parameters/arguments sections of docstrings return.html : to render \"return\" sections of docstrings properties.html : to render the properties of an object ( staticmethod , read-only , etc.) signature.html : to render functions and methods signatures","title":"Templates"},{"location":"theming/#debugging","text":"Every template has access to a log function, allowing to log messages as usual: {{ log.debug ( \"A DEBUG message.\" ) }} {{ log.info ( \"An INFO message.\" ) }} {{ log.warning ( \"A WARNING message.\" ) }} {{ log.error ( \"An ERROR message.\" ) }} {{ log.critical ( \"A CRITICAL message.\" ) }}","title":"Debugging"},{"location":"theming/#css-classes","text":"The Material theme uses the following CSS classes in the HTML: doc : on all the following elements doc-children : on div s containing the children of an object doc-object : on div s containing an object doc-attribute : on div s containing an attribute doc-class : on div s containing a class doc-function : on div s containing a function doc-method : on div s containing a method doc-module : on div s containing a module doc-heading : on objects headings doc-contents : on div s wrapping the docstring then the children (if any) first : same, but only on the root object's contents div doc-properties : on span s wrapping the object's properties doc-property : on small elements containing a property doc-property-PROPERTY : same, where PROPERTY is replaced by the actual property Example with colorful properties CSS . doc-property { border-radius : 15 px ; padding : 0 5 px ; } . doc-property-special { background-color : blue ; color : white ; } . doc-property-private { background-color : red ; color : white ; } . doc-property-property { background-color : green ; color : white ; } . doc-property-read-only { background-color : yellow ; color : black ; } Result .prop { border-radius: 15px; padding: 0 5px; }","title":"CSS classes"},{"location":"theming/#syntax-highlighting","text":"Code blocks that occur in the docstring of an item inserted with mkdocstrings , as well as code blocks (such as Source code ) that mkdocstrings inserts itself, are syntax-highlighted according to the same rules as other normal code blocks in your document. See more details in mkdocstrings.handlers.rendering.Highlighter . As for the CSS class used for code blocks -- it will also match the \"normal\" config, so the default ( .codehilite or .highlight ) will match your chosen Markdown extension for highlighting. Changed in version 0.15 The CSS class used to always be .highlight , but now it depends on the configuration. Long story short, you probably should add pymdownx.highlight to your markdown_extensions , and then use .doc-contents .highlight as the CSS selector in case you want to change something about mkdocstrings' code blocks specifically.","title":"Syntax highlighting"},{"location":"troubleshooting/","text":"Troubleshooting \u00a4 Code blocks in admonitions (in docstrings or else) are not rendered correctly \u00a4 To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences Footnotes are duplicated or overridden \u00a4 Before version 0.14, footnotes could be duplicated over a page. Please upgrade to version 0.14 or higher. See also: Issue #186 Tabs in docstrings (from pymdownx.tabbed ) are not working properly . MkDocs warns me about links to unfound documentation files \u00a4 A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] . Some objects are not rendered (they do not appear in the generated docs) \u00a4 Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the supported docstring styles page. Re-run the Mkdocs command with -v , and carefully read any traceback. Tabs in docstrings (from pymdownx.tabbed ) are not working properly \u00a4 Before version 0.14, multiple tab blocks injected on the same page would result in broken links: clicking on a tab would bring the user to the wrong one. Please upgrade to version 0.14 or higher. See also: Issue #193 Footnotes are duplicated or overridden . If you are stuck on a version before 0.14, and want to use multiple tab blocks in one page, use this workaround. ??? example \"JavaScript workaround\" Put the following code in a .js file, and list it in MkDocs' `extra_javascript`: ```javascript // Credits to Nikolaos Zioulis (@zuru on GitHub) function setID(){ var tabs = document.getElementsByClassName(\"tabbed-set\"); for (var i = 0; i < tabs.length; i++) { children = tabs[i].children; var counter = 0; var iscontent = 0; for(var j = 0; j < children.length;j++){ if(typeof children[j].htmlFor === 'undefined'){ if((iscontent + 1) % 2 == 0){ // check if it is content if(iscontent == 1){ btn = children[j].childNodes[1].getElementsByTagName(\"button\"); } } else{ // if not change the id children[j].id = \"__tabbed_\" + String(i + 1) + \"_\" + String(counter + 1); children[j].name = \"__tabbed_\" + String(i + 1); // make default tab open if(j == 0) children[j].click(); } iscontent++; } else{ // link to the correct tab children[j].htmlFor = \"__tabbed_\" + String(i+1) + \"_\" + String(counter + 1); counter ++; } } } } setID(); ``` This code will correctly reset the IDs for tabs on a same page. The generated documentation does not look good \u00a4 Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Note that you can always customize the look of mkdocstrings blocks -- through both HTML and CSS. Warning: could not find cross-reference target \u00a4 New in version 0.15 Cross-linking used to include any Markdown heading, but now it's only for mkdocstrings identifiers by default. See Cross-references to any Markdown heading to opt back in. Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it. WindowsPath object is not iterable \u00a4 If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine. Python specifics \u00a4 Nothing is rendered at all \u00a4 Is your package available in the Python path? See Python handler: Finding modules . LaTeX in docstrings is not rendered correctly \u00a4 If you are using a Markdown extension like Arithmatex Mathjax or markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\" My docstrings in comments ( #: ) are not picked up \u00a4 It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. You can use: import enum class MyEnum ( enum . Enum ): \"\"\"My enum. Attributes: v1: The first choice. v2: The second choice. \"\"\" v1 = 1 v2 = 2 Or: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" My wrapped function shows documentation/code for its wrapper instead of its own \u00a4 Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#code-blocks-in-admonitions-in-docstrings-or-else-are-not-rendered-correctly","text":"To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences","title":"Code blocks in admonitions (in docstrings or else) are not rendered correctly"},{"location":"troubleshooting/#footnotes-are-duplicated-or-overridden","text":"Before version 0.14, footnotes could be duplicated over a page. Please upgrade to version 0.14 or higher. See also: Issue #186 Tabs in docstrings (from pymdownx.tabbed ) are not working properly .","title":"Footnotes are duplicated or overridden"},{"location":"troubleshooting/#mkdocs-warns-me-about-links-to-unfound-documentation-files","text":"A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] .","title":"MkDocs warns me about links to unfound documentation files"},{"location":"troubleshooting/#some-objects-are-not-rendered-they-do-not-appear-in-the-generated-docs","text":"Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the supported docstring styles page. Re-run the Mkdocs command with -v , and carefully read any traceback.","title":"Some objects are not rendered (they do not appear in the generated docs)"},{"location":"troubleshooting/#tabs-in-docstrings-from-pymdownxtabbed-are-not-working-properly","text":"Before version 0.14, multiple tab blocks injected on the same page would result in broken links: clicking on a tab would bring the user to the wrong one. Please upgrade to version 0.14 or higher. See also: Issue #193 Footnotes are duplicated or overridden . If you are stuck on a version before 0.14, and want to use multiple tab blocks in one page, use this workaround. ??? example \"JavaScript workaround\" Put the following code in a .js file, and list it in MkDocs' `extra_javascript`: ```javascript // Credits to Nikolaos Zioulis (@zuru on GitHub) function setID(){ var tabs = document.getElementsByClassName(\"tabbed-set\"); for (var i = 0; i < tabs.length; i++) { children = tabs[i].children; var counter = 0; var iscontent = 0; for(var j = 0; j < children.length;j++){ if(typeof children[j].htmlFor === 'undefined'){ if((iscontent + 1) % 2 == 0){ // check if it is content if(iscontent == 1){ btn = children[j].childNodes[1].getElementsByTagName(\"button\"); } } else{ // if not change the id children[j].id = \"__tabbed_\" + String(i + 1) + \"_\" + String(counter + 1); children[j].name = \"__tabbed_\" + String(i + 1); // make default tab open if(j == 0) children[j].click(); } iscontent++; } else{ // link to the correct tab children[j].htmlFor = \"__tabbed_\" + String(i+1) + \"_\" + String(counter + 1); counter ++; } } } } setID(); ``` This code will correctly reset the IDs for tabs on a same page.","title":"Tabs in docstrings (from pymdownx.tabbed) are not working properly"},{"location":"troubleshooting/#the-generated-documentation-does-not-look-good","text":"Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Note that you can always customize the look of mkdocstrings blocks -- through both HTML and CSS.","title":"The generated documentation does not look good"},{"location":"troubleshooting/#warning-could-not-find-cross-reference-target","text":"New in version 0.15 Cross-linking used to include any Markdown heading, but now it's only for mkdocstrings identifiers by default. See Cross-references to any Markdown heading to opt back in. Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it.","title":"Warning: could not find cross-reference target"},{"location":"troubleshooting/#windowspath-object-is-not-iterable","text":"If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine.","title":"WindowsPath object is not iterable"},{"location":"troubleshooting/#python-specifics","text":"","title":"Python specifics"},{"location":"troubleshooting/#nothing-is-rendered-at-all","text":"Is your package available in the Python path? See Python handler: Finding modules .","title":"Nothing is rendered at all"},{"location":"troubleshooting/#latex-in-docstrings-is-not-rendered-correctly","text":"If you are using a Markdown extension like Arithmatex Mathjax or markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\"","title":"LaTeX in docstrings is not rendered correctly"},{"location":"troubleshooting/#my-docstrings-in-comments-are-not-picked-up","text":"It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. You can use: import enum class MyEnum ( enum . Enum ): \"\"\"My enum. Attributes: v1: The first choice. v2: The second choice. \"\"\" v1 = 1 v2 = 2 Or: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\"","title":"My docstrings in comments (#:) are not picked up"},{"location":"troubleshooting/#my-wrapped-function-shows-documentationcode-for-its-wrapper-instead-of-its-own","text":"Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"My wrapped function shows documentation/code for its wrapper instead of its own"},{"location":"usage/","text":"Usage \u00a4 Autodoc syntax \u00a4 mkdocstrings works by processing special expressions in your Markdown files. The syntax is as follows: ::: identifier YAML block The identifier is a string identifying the object you want to document. The format of an identifier can vary from one handler to another. For example, the Python handler expects the full dotted-path to a Python object: my_package.my_module.MyClass.my_method . The YAML block is optional, and contains some configuration options: handler : the name of the handler to use to collect and render this object. By default, it will use the value defined in the Global options 's default_handler key, or \"python\" . selection : a dictionary of options passed to the handler's collector. The collector is responsible for collecting the documentation from the source code. Therefore, selection options change how the documentation is collected from the source code. rendering : a dictionary of options passed to the handler's renderer. The renderer is responsible for rendering the documentation with Jinja2 templates. Therefore, rendering options affect how the selected object's documentation is rendered. Every handler accepts at least these two keys, selection and rendering , and some handlers accept additional keys. Check the documentation for your handler of interest in Handlers . Example with the Python handler docs/my_page.md # Documentation for `MyClass` ::: my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false mkdocs.yml nav : - \"My page\" : my_page.md src/my_package/my_module.py class MyClass : \"\"\"Print print print!\"\"\" def method_a ( self ): \"\"\"Print A!\"\"\" print ( \"A!\" ) def method_b ( self ): \"\"\"Print B!\"\"\" print ( \"B!\" ) def method_c ( self ): \"\"\"Print C!\"\"\" print ( \"C!\" ) Result Documentation for MyClass Print print print! method_a ( self ) Print A! method_b ( self ) Print B! It is also possible to integrate a mkdocstrings identifier into a Markdown header: ## ::: my_package.my_module.MyClass rendering: show_source: false The above is equivalent to: ::: my_package.my_module.MyClass rendering: show_source: false heading_level: 2 Global options \u00a4 mkdocstrings accepts a few top-level configuration options in mkdocs.yml : watch : a list of directories to watch while serving the documentation. See Watch directories . default_handler : the handler that is used by default when no handler is specified. custom_templates : the path to a directory containing custom templates. The path is relative to the docs directory. See Theming . handlers : the handlers global configuration. Example: mkdocs.yml plugins : - mkdocstrings : default_handler : python handlers : python : rendering : show_source : false custom_templates : templates watch : - src/my_package The handlers global configuration can then be overridden by local configurations: :: : my_package.my_module.MyClass rendering : show_source : true Cross-references \u00a4 Cross-references are written as Markdown reference-style links: Markdown With a custom title: [ `Object 1` ][full.path.object1] With the identifier as title: [ full.path.object2 ][] HTML Result < p > With a custom title: < a href = \"https://example.com/page1#full.path.object1\" >< code > Object 1 </ code ></ a >< p > < p > With the identifier as title: < a href = \"https://example.com/page2#full.path.object2\" > full.path.object2 </ a ></ p > Any item that was inserted using the autodoc syntax (e.g. ::: full.path.object1 ) is possible to link to by using the same identifier with the cross-reference syntax ( [example][full.path.object1] ). But the cross-references are also applicable to the items' children that get pulled in. Finding out the anchor \u00a4 If you're not sure which exact identifier a doc item uses, you can look at its \"anchor\", which your Web browser will show in the URL bar when clicking an item's entry in the table of contents. If the URL is https://example.com/some/page.html#full.path.object1 then you know that this item is possible to link to with [example][full.path.object1] , regardless of the current page. Cross-references to any Markdown heading \u00a4 Changed in version 0.15 Linking to any Markdown heading used to be the default, but now opt-in is required. If you want to link to any Markdown heading, not just mkdocstrings -inserted items, please enable the autorefs plugin for MkDocs by adding autorefs to plugins : mkdocs.yml plugins : - admonition - search - autorefs - mkdocstrings : [ ... ] Note that you don't need to ( pip ) install anything more; this plugin is guaranteed to be pulled in with mkdocstrings . Example doc1.md ## Hello, world! Testing doc2.md ## Something else Please see the [ Hello, World! ][ hello-world ] section. Result HTML for doc2 < p > Please see the < a href = \"doc1.html#hello-world\" > Hello, World! </ a > section. </ p > Cross-references to a sub-heading in a docstring \u00a4 New in version 0.14 If you have a Markdown heading inside your docstring, you can also link directly to it. In the example below you see the identifier to be linked is foo.bar--tips , because it's the \"Tips\" heading that's part of the foo.bar object, joined with \" -- \". Example foo.py def bar (): \"\"\"Hello, world! # Tips - Stay hydrated. \"\"\" doc1.md ::: foo.bar doc2.md Check out the [ tips ][ foo.bar--tips ] Result HTML for doc2 < p > Check out the < a href = \"doc1.html#foo.bar--tips\" > tips </ a ></ p > The above tip about Finding out the anchor also applies the same way here. You may also notice that such a heading does not get rendered as a <h1> element directly, but rather the level gets shifted to fit the encompassing document structure. If you're curious about the implementation, check out mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor and others. Watch directories \u00a4 You can add directories to watch with the watch key. It accepts a list of paths. mkdocs.yml plugins : - mkdocstrings : watch : - src/my_package_1 - src/my_package_2 When serving your documentation and a change occur in one of the listed path, MkDocs will rebuild the site and reload the current page. The watch feature doesn't have special effects. Adding directories to the watch list doesn't have any other effect than watching for changes. For example, it will not tell the Python handler to look for packages in these paths (the paths are not added to the PYTHONPATH variable). If you want to tell Python where to look for packages and modules, see Python Handler: Finding modules .","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#autodoc-syntax","text":"mkdocstrings works by processing special expressions in your Markdown files. The syntax is as follows: ::: identifier YAML block The identifier is a string identifying the object you want to document. The format of an identifier can vary from one handler to another. For example, the Python handler expects the full dotted-path to a Python object: my_package.my_module.MyClass.my_method . The YAML block is optional, and contains some configuration options: handler : the name of the handler to use to collect and render this object. By default, it will use the value defined in the Global options 's default_handler key, or \"python\" . selection : a dictionary of options passed to the handler's collector. The collector is responsible for collecting the documentation from the source code. Therefore, selection options change how the documentation is collected from the source code. rendering : a dictionary of options passed to the handler's renderer. The renderer is responsible for rendering the documentation with Jinja2 templates. Therefore, rendering options affect how the selected object's documentation is rendered. Every handler accepts at least these two keys, selection and rendering , and some handlers accept additional keys. Check the documentation for your handler of interest in Handlers . Example with the Python handler docs/my_page.md # Documentation for `MyClass` ::: my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false mkdocs.yml nav : - \"My page\" : my_page.md src/my_package/my_module.py class MyClass : \"\"\"Print print print!\"\"\" def method_a ( self ): \"\"\"Print A!\"\"\" print ( \"A!\" ) def method_b ( self ): \"\"\"Print B!\"\"\" print ( \"B!\" ) def method_c ( self ): \"\"\"Print C!\"\"\" print ( \"C!\" ) Result","title":"Autodoc syntax"},{"location":"usage/#global-options","text":"mkdocstrings accepts a few top-level configuration options in mkdocs.yml : watch : a list of directories to watch while serving the documentation. See Watch directories . default_handler : the handler that is used by default when no handler is specified. custom_templates : the path to a directory containing custom templates. The path is relative to the docs directory. See Theming . handlers : the handlers global configuration. Example: mkdocs.yml plugins : - mkdocstrings : default_handler : python handlers : python : rendering : show_source : false custom_templates : templates watch : - src/my_package The handlers global configuration can then be overridden by local configurations: :: : my_package.my_module.MyClass rendering : show_source : true","title":"Global options"},{"location":"usage/#cross-references","text":"Cross-references are written as Markdown reference-style links: Markdown With a custom title: [ `Object 1` ][full.path.object1] With the identifier as title: [ full.path.object2 ][] HTML Result < p > With a custom title: < a href = \"https://example.com/page1#full.path.object1\" >< code > Object 1 </ code ></ a >< p > < p > With the identifier as title: < a href = \"https://example.com/page2#full.path.object2\" > full.path.object2 </ a ></ p > Any item that was inserted using the autodoc syntax (e.g. ::: full.path.object1 ) is possible to link to by using the same identifier with the cross-reference syntax ( [example][full.path.object1] ). But the cross-references are also applicable to the items' children that get pulled in.","title":"Cross-references"},{"location":"usage/#finding-out-the-anchor","text":"If you're not sure which exact identifier a doc item uses, you can look at its \"anchor\", which your Web browser will show in the URL bar when clicking an item's entry in the table of contents. If the URL is https://example.com/some/page.html#full.path.object1 then you know that this item is possible to link to with [example][full.path.object1] , regardless of the current page.","title":"Finding out the anchor"},{"location":"usage/#cross-references-to-any-markdown-heading","text":"Changed in version 0.15 Linking to any Markdown heading used to be the default, but now opt-in is required. If you want to link to any Markdown heading, not just mkdocstrings -inserted items, please enable the autorefs plugin for MkDocs by adding autorefs to plugins : mkdocs.yml plugins : - admonition - search - autorefs - mkdocstrings : [ ... ] Note that you don't need to ( pip ) install anything more; this plugin is guaranteed to be pulled in with mkdocstrings . Example doc1.md ## Hello, world! Testing doc2.md ## Something else Please see the [ Hello, World! ][ hello-world ] section. Result HTML for doc2 < p > Please see the < a href = \"doc1.html#hello-world\" > Hello, World! </ a > section. </ p >","title":"Cross-references to any Markdown heading"},{"location":"usage/#cross-references-to-a-sub-heading-in-a-docstring","text":"New in version 0.14 If you have a Markdown heading inside your docstring, you can also link directly to it. In the example below you see the identifier to be linked is foo.bar--tips , because it's the \"Tips\" heading that's part of the foo.bar object, joined with \" -- \". Example foo.py def bar (): \"\"\"Hello, world! # Tips - Stay hydrated. \"\"\" doc1.md ::: foo.bar doc2.md Check out the [ tips ][ foo.bar--tips ] Result HTML for doc2 < p > Check out the < a href = \"doc1.html#foo.bar--tips\" > tips </ a ></ p > The above tip about Finding out the anchor also applies the same way here. You may also notice that such a heading does not get rendered as a <h1> element directly, but rather the level gets shifted to fit the encompassing document structure. If you're curious about the implementation, check out mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor and others.","title":"Cross-references to a sub-heading in a docstring"},{"location":"usage/#watch-directories","text":"You can add directories to watch with the watch key. It accepts a list of paths. mkdocs.yml plugins : - mkdocstrings : watch : - src/my_package_1 - src/my_package_2 When serving your documentation and a change occur in one of the listed path, MkDocs will rebuild the site and reload the current page. The watch feature doesn't have special effects. Adding directories to the watch list doesn't have any other effect than watching for changes. For example, it will not tell the Python handler to look for packages in these paths (the paths are not added to the PYTHONPATH variable). If you want to tell Python where to look for packages and modules, see Python Handler: Finding modules .","title":"Watch directories"},{"location":"handlers/overview/","text":"Handlers \u00a4 A handler is what makes it possible to collect and render documentation for a particular language. Available handlers \u00a4 Python Crystal Custom handlers \u00a4 Since version 0.14, you can create and use custom handlers thanks to namespace packages. For more information about namespace packages, see their documentation . Packaging \u00a4 For mkdocstrings , a custom handler package would have the following structure: \ud83d\udcc1 your_repository \u2514\u2500\u2574\ud83d\udcc1 mkdocstrings \u2514\u2500\u2574\ud83d\udcc1 handlers \u2514\u2500\u2574\ud83d\udcc4 custom_handler.py Note the absence of __init__.py modules! If you name you handler after an existing handler, it will overwrite it! For example, it means you can overwrite the Python handler to change how it works or to add functionality, by naming your handler module python.py . Code \u00a4 A handler is composed of a Collector and a Renderer. See the documentation for BaseHandler , BaseCollector and BaseRenderer . Check out how the Python handler is written for inspiration. You must implement a get_handler method at the module level. This function takes the theme (string, theme name) and custom_templates (optional string, path to custom templates directory) arguments, and you can add any other keyword argument you'd like. The global configuration items (other than selection and rendering ) will be passed to this function when getting your handler. Templates \u00a4 You renderer's implementation should normally be backed by templates, which go to the directory mkdocstrings/handlers/custom_handler/some_theme . ( custom_handler here should be replaced with the actual name of your handler, and some_theme should be the name of an actual MkDocs theme that you support, e.g. material ). With that structure, you can use self.env.get_template(\"foo.html\") inside your render implementation. This already chooses the subdirectory based on the current MkDocs theme. If you wish to support any MkDocs theme, rather than a few specifically selected ones, you can pick one theme's subdirectory to be the fallback for when an unknown theme is encountered. Then you just need to set the fallback_theme variable on your renderer subclass. The fallback directory can be used even for themes you explicitly support: you can omit some template from one of the other theme directories in case they're exactly the same as in the fallback theme. If your theme's HTML requires CSS to go along with it, put it into a file named mkdocstrings/handlers/custom_handler/some_theme/style.css , then this will be included into the final site automatically if this handler is ever used. Alternatively, you can put the CSS as a string into the extra_css variable of your renderer. Usage \u00a4 When a custom handler is installed, it is then available to mkdocstrings . You can configure it as usual: mkdocs.yml plugins : - mkdocstrings : handlers : custom_handler : selection : some_config_option : \"a\" rendering : other_config_option : 0 handler_config_option : yes ...and use it in your autodoc instructions: # Documentation for an object ::: some.objects.path handler: custom_handler selection: some_config_option: \"b\" rendering: other_config_option: 1","title":"Handlers"},{"location":"handlers/overview/#handlers","text":"A handler is what makes it possible to collect and render documentation for a particular language.","title":"Handlers"},{"location":"handlers/overview/#available-handlers","text":"Python Crystal","title":"Available handlers"},{"location":"handlers/overview/#custom-handlers","text":"Since version 0.14, you can create and use custom handlers thanks to namespace packages. For more information about namespace packages, see their documentation .","title":"Custom handlers"},{"location":"handlers/overview/#packaging","text":"For mkdocstrings , a custom handler package would have the following structure: \ud83d\udcc1 your_repository \u2514\u2500\u2574\ud83d\udcc1 mkdocstrings \u2514\u2500\u2574\ud83d\udcc1 handlers \u2514\u2500\u2574\ud83d\udcc4 custom_handler.py Note the absence of __init__.py modules! If you name you handler after an existing handler, it will overwrite it! For example, it means you can overwrite the Python handler to change how it works or to add functionality, by naming your handler module python.py .","title":"Packaging"},{"location":"handlers/overview/#code","text":"A handler is composed of a Collector and a Renderer. See the documentation for BaseHandler , BaseCollector and BaseRenderer . Check out how the Python handler is written for inspiration. You must implement a get_handler method at the module level. This function takes the theme (string, theme name) and custom_templates (optional string, path to custom templates directory) arguments, and you can add any other keyword argument you'd like. The global configuration items (other than selection and rendering ) will be passed to this function when getting your handler.","title":"Code"},{"location":"handlers/overview/#templates","text":"You renderer's implementation should normally be backed by templates, which go to the directory mkdocstrings/handlers/custom_handler/some_theme . ( custom_handler here should be replaced with the actual name of your handler, and some_theme should be the name of an actual MkDocs theme that you support, e.g. material ). With that structure, you can use self.env.get_template(\"foo.html\") inside your render implementation. This already chooses the subdirectory based on the current MkDocs theme. If you wish to support any MkDocs theme, rather than a few specifically selected ones, you can pick one theme's subdirectory to be the fallback for when an unknown theme is encountered. Then you just need to set the fallback_theme variable on your renderer subclass. The fallback directory can be used even for themes you explicitly support: you can omit some template from one of the other theme directories in case they're exactly the same as in the fallback theme. If your theme's HTML requires CSS to go along with it, put it into a file named mkdocstrings/handlers/custom_handler/some_theme/style.css , then this will be included into the final site automatically if this handler is ever used. Alternatively, you can put the CSS as a string into the extra_css variable of your renderer.","title":"Templates"},{"location":"handlers/overview/#usage","text":"When a custom handler is installed, it is then available to mkdocstrings . You can configure it as usual: mkdocs.yml plugins : - mkdocstrings : handlers : custom_handler : selection : some_config_option : \"a\" rendering : other_config_option : 0 handler_config_option : yes ...and use it in your autodoc instructions: # Documentation for an object ::: some.objects.path handler: custom_handler selection: some_config_option: \"b\" rendering: other_config_option: 1","title":"Usage"},{"location":"handlers/python/","text":"Python handler \u00a4 Handler options \u00a4 Like every handler, the Python handler accepts the common selection and rendering options, both as global and local options. The selection options gives you control over the selection of Python objects, while the rendering options lets you change how the documentation is rendered. It also accepts these additional global-only options: Option Type Description Default setup_commands list of str Run these commands before starting the documentation collection. [] Example: setup Django before collecting documentation # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import os - import django - os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"my_django_app.settings\") - django.setup() Important Additional options like setup_commands are used only once, when instantiating the handler the first time it is requested. This is why they are considered global-only options, as they will have no effect if used as local options. Selection \u00a4 The following options are directly passed to the handler's collector. See Collector: pytkdocs to learn more about pytkdocs . Option Type Description Default filters list of str List of filtering regular expressions. Prefix with ! to exclude objects whose name match. The default means exclude private members . [\"!^_[^_]\"] members bool , or list of str Explicitly select members. True means all , false means none . True inherited_members bool Also select members inherited from parent classes. False docstring_style str Docstring style to parse. pytkdocs supports google and restructured-text . \"google\" docstring_options dict Options to pass to the docstring parser. See Collector: pytkdocs {} new_path_syntax bool Whether to use the new \"colon\" path syntax when importing objects. False Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : selection : filters : - \"!^_\" # exlude all members starting with _ - \"^__init__$\" # but always include __init__ modules and methods Local :: : my_package selection : filters : [] # pick up everything Rendering \u00a4 The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_root_members_full_path bool Show the full Python path of objects that are children of the root object (for example, classes in a module). When False, show_object_full_path overrides. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_signature_annotations bool Show the type annotations in methods and functions signatures. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 These options affect how the documentation is rendered. Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : rendering : show_root_heading : yes Local ## `ClassA` ::: my_package.my_module.ClassA rendering: show_root_heading: no heading_level: 3 Collector: pytkdocs \u00a4 The tool used by the Python handler to collect documentation from Python source code is pytkdocs . It stands for (Python) Take Docs , and is supposed to be a pun on MkDocs ( Make Docs ?). Supported docstrings styles \u00a4 Right now, pytkdocs supports the Google-style and reStructuredText-style docstring formats. Google-style \u00a4 You can see examples of Google-style docstrings in Napoleon's documentation . Sections \u00a4 Docstrings sections are parsed by pytkdocs and rendered by mkdocstrings . Supported sections are: Arguments (or Args , Parameters , Params ) Attributes Examples (or Example ) Raises (or Raise , Except , Exceptions ) Returns (or Return ) Admonitions \u00a4 Additionally, any section that is not recognized will be transformed into its admonition equivalent. For example: Original \"\"\" Note: You can disable this behavior with the `replace_admonitions` option. To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Modified \"\"\" !!! note \"You can disable this behavior with the `replace_admonitions` option.\" To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Result You can disable this behavior with the replace_admonitions parser option. To prevent pytkdocs from converting sections to admonitions, use the replace_admonitions parser option: ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no So meta! As shown in the above example, this can be disabled with the replace_admonitions option of the Google-style parser: :: : my_package.my_module selection : docstring_style : google # this is the default docstring_options : replace_admonitions : no Annotations \u00a4 Type annotations are read both in the code and in the docstrings. Example with a function Expand the source at the end to see the original code! A short description of this function. Parameters: Name Type Description Default param1 int An integer? required param2 Optional[str] A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! None Source code in snippets/function_annotations_google.py def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\"A short description of this function. Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! \"\"\" return f \" { param2 }{ param1 } \" reStructuredText-style \u00a4 Partial support Only RST- style is supported, not the whole RST markup specification. Docstrings will still be converted as Markdown. You can see examples of reStructuredText-style docstrings in Sphinx's documentation . Sections \u00a4 Docstrings directives are parsed by pytkdocs and rendered by mkdocstrings . Supported directives are: param (or parameter , arg , argument , key , keyword ) type raises (or raise , except , exception ) var (or ivar , cvar ) vartype returns (or return1 ) rtype Details about how to use each directive can be found in the Sphinx domain documentation Annotations \u00a4 Type annotations are read both in the code and in the docstrings. Example with a function Expand the source at the end to see the original code! A short description of this function. Complex markup is supported in the main description section. I'm a code block! Parameters: Name Type Description Default param1 int An integer? required param2 Optional[str] A string? If you have a long description, you can split it on multiple lines. None Source code in snippets/function_annotations_rst.py def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\"A short description of this function. Complex markup is supported in the main description section. I'm a code block! :param param1: An integer? :param param2: A string? If you have a long description, you can split it on multiple lines. \"\"\" return f \" { param2 }{ param1 } \" Finding modules \u00a4 In order for pytkdocs to find your packages and modules, you should take advantage of the usual Python loading mechanisms: install your package in the current virtualenv: . venv/bin/activate pip install -e . poetry install ...etc. or add your package(s) parent directory in the PYTHONPATH . ( The following instructions assume your Python package is in the src directory. ) In Bash and other shells, you can run your command like this (note the prepended PYTHONPATH=... ): PYTHONPATH = src poetry run mkdocs serve You could also export that variable, but this is not recommended as it could affect other Python processes: export PYTHONPATH = src # Linux/Bash and similar setx PYTHONPATH src # Windows, USE AT YOUR OWN RISKS You can also use the Python handler setup_commands : # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - sys.path.append(\"src\") # or sys.path.insert(0, \"src\") Mocking libraries \u00a4 You may want to to generate documentation for a package while its dependencies are not available. The Python handler provides itself no builtin way to mock libraries, but you can use the setup_commands to mock them manually: mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - from unittest.mock import MagicMock as mock - sys.modules[\"lib1\"] = mock() - sys.modules[\"lib2\"] = mock() - sys.modules[\"lib2.module1\"] = mock() - sys.modules[\"lib2.module1.moduleB\"] = mock() # etc Recommended style (Material) \u00a4 Here are some CSS rules for the Material for MkDocs theme: /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } Recommended style (ReadTheDocs) \u00a4 Here are some CSS rules for the built-in ReadTheDocs theme: /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 60 px ; }","title":"Python"},{"location":"handlers/python/#python-handler","text":"","title":"Python handler"},{"location":"handlers/python/#handler-options","text":"Like every handler, the Python handler accepts the common selection and rendering options, both as global and local options. The selection options gives you control over the selection of Python objects, while the rendering options lets you change how the documentation is rendered. It also accepts these additional global-only options: Option Type Description Default setup_commands list of str Run these commands before starting the documentation collection. [] Example: setup Django before collecting documentation # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import os - import django - os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"my_django_app.settings\") - django.setup() Important Additional options like setup_commands are used only once, when instantiating the handler the first time it is requested. This is why they are considered global-only options, as they will have no effect if used as local options.","title":"Handler options"},{"location":"handlers/python/#selection","text":"The following options are directly passed to the handler's collector. See Collector: pytkdocs to learn more about pytkdocs . Option Type Description Default filters list of str List of filtering regular expressions. Prefix with ! to exclude objects whose name match. The default means exclude private members . [\"!^_[^_]\"] members bool , or list of str Explicitly select members. True means all , false means none . True inherited_members bool Also select members inherited from parent classes. False docstring_style str Docstring style to parse. pytkdocs supports google and restructured-text . \"google\" docstring_options dict Options to pass to the docstring parser. See Collector: pytkdocs {} new_path_syntax bool Whether to use the new \"colon\" path syntax when importing objects. False Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : selection : filters : - \"!^_\" # exlude all members starting with _ - \"^__init__$\" # but always include __init__ modules and methods Local :: : my_package selection : filters : [] # pick up everything","title":"Selection"},{"location":"handlers/python/#rendering","text":"The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_root_members_full_path bool Show the full Python path of objects that are children of the root object (for example, classes in a module). When False, show_object_full_path overrides. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_signature_annotations bool Show the type annotations in methods and functions signatures. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 These options affect how the documentation is rendered. Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : rendering : show_root_heading : yes Local ## `ClassA` ::: my_package.my_module.ClassA rendering: show_root_heading: no heading_level: 3","title":"Rendering"},{"location":"handlers/python/#collector-pytkdocs","text":"The tool used by the Python handler to collect documentation from Python source code is pytkdocs . It stands for (Python) Take Docs , and is supposed to be a pun on MkDocs ( Make Docs ?).","title":"Collector: pytkdocs"},{"location":"handlers/python/#supported-docstrings-styles","text":"Right now, pytkdocs supports the Google-style and reStructuredText-style docstring formats.","title":"Supported docstrings styles"},{"location":"handlers/python/#google-style","text":"You can see examples of Google-style docstrings in Napoleon's documentation .","title":"Google-style"},{"location":"handlers/python/#sections","text":"Docstrings sections are parsed by pytkdocs and rendered by mkdocstrings . Supported sections are: Arguments (or Args , Parameters , Params ) Attributes Examples (or Example ) Raises (or Raise , Except , Exceptions ) Returns (or Return )","title":"Sections"},{"location":"handlers/python/#admonitions","text":"Additionally, any section that is not recognized will be transformed into its admonition equivalent. For example: Original \"\"\" Note: You can disable this behavior with the `replace_admonitions` option. To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Modified \"\"\" !!! note \"You can disable this behavior with the `replace_admonitions` option.\" To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Result You can disable this behavior with the replace_admonitions parser option. To prevent pytkdocs from converting sections to admonitions, use the replace_admonitions parser option: ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no So meta! As shown in the above example, this can be disabled with the replace_admonitions option of the Google-style parser: :: : my_package.my_module selection : docstring_style : google # this is the default docstring_options : replace_admonitions : no","title":"Admonitions"},{"location":"handlers/python/#annotations","text":"Type annotations are read both in the code and in the docstrings. Example with a function Expand the source at the end to see the original code! A short description of this function. Parameters: Name Type Description Default param1 int An integer? required param2 Optional[str] A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! None Source code in snippets/function_annotations_google.py def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\"A short description of this function. Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! \"\"\" return f \" { param2 }{ param1 } \"","title":"Annotations"},{"location":"handlers/python/#restructuredtext-style","text":"Partial support Only RST- style is supported, not the whole RST markup specification. Docstrings will still be converted as Markdown. You can see examples of reStructuredText-style docstrings in Sphinx's documentation .","title":"reStructuredText-style"},{"location":"handlers/python/#sections_1","text":"Docstrings directives are parsed by pytkdocs and rendered by mkdocstrings . Supported directives are: param (or parameter , arg , argument , key , keyword ) type raises (or raise , except , exception ) var (or ivar , cvar ) vartype returns (or return1 ) rtype Details about how to use each directive can be found in the Sphinx domain documentation","title":"Sections"},{"location":"handlers/python/#annotations_1","text":"Type annotations are read both in the code and in the docstrings. Example with a function Expand the source at the end to see the original code! A short description of this function. Complex markup is supported in the main description section. I'm a code block! Parameters: Name Type Description Default param1 int An integer? required param2 Optional[str] A string? If you have a long description, you can split it on multiple lines. None Source code in snippets/function_annotations_rst.py def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\"A short description of this function. Complex markup is supported in the main description section. I'm a code block! :param param1: An integer? :param param2: A string? If you have a long description, you can split it on multiple lines. \"\"\" return f \" { param2 }{ param1 } \"","title":"Annotations"},{"location":"handlers/python/#finding-modules","text":"In order for pytkdocs to find your packages and modules, you should take advantage of the usual Python loading mechanisms: install your package in the current virtualenv: . venv/bin/activate pip install -e . poetry install ...etc. or add your package(s) parent directory in the PYTHONPATH . ( The following instructions assume your Python package is in the src directory. ) In Bash and other shells, you can run your command like this (note the prepended PYTHONPATH=... ): PYTHONPATH = src poetry run mkdocs serve You could also export that variable, but this is not recommended as it could affect other Python processes: export PYTHONPATH = src # Linux/Bash and similar setx PYTHONPATH src # Windows, USE AT YOUR OWN RISKS You can also use the Python handler setup_commands : # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - sys.path.append(\"src\") # or sys.path.insert(0, \"src\")","title":"Finding modules"},{"location":"handlers/python/#mocking-libraries","text":"You may want to to generate documentation for a package while its dependencies are not available. The Python handler provides itself no builtin way to mock libraries, but you can use the setup_commands to mock them manually: mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - from unittest.mock import MagicMock as mock - sys.modules[\"lib1\"] = mock() - sys.modules[\"lib2\"] = mock() - sys.modules[\"lib2.module1\"] = mock() - sys.modules[\"lib2.module1.moduleB\"] = mock() # etc","title":"Mocking libraries"},{"location":"handlers/python/#recommended-style-material","text":"Here are some CSS rules for the Material for MkDocs theme: /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; }","title":"Recommended style (Material)"},{"location":"handlers/python/#recommended-style-readthedocs","text":"Here are some CSS rules for the built-in ReadTheDocs theme: /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 60 px ; }","title":"Recommended style (ReadTheDocs)"},{"location":"reference/extension/","text":"This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a handler to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc AutoDocProcessor \u00a4 Our \"autodoc\" Markdown block processor. It has a test method that tells if a block matches a criterion, and a run method that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. __init__ ( self , parser , md , config , handlers , autorefs ) special \u00a4 Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The configuration of the mkdocstrings plugin. required handlers Handlers A mkdocstrings.handlers.base.Handlers instance. required autorefs AutorefsPlugin A mkdocs_autorefs.plugin.AutorefsPlugin instance. required Source code in mkdocstrings/extension.py def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: A [mkdocstrings.handlers.base.Handlers][] instance. autorefs: A [mkdocs_autorefs.plugin.AutorefsPlugin][] instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_env = False run ( self , parent , blocks ) \u00a4 Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks MutableSequence[str] The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] # type: ignore block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , headings = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. el . extend ( headings ) for heading in headings : self . _autorefs . register_anchor ( self . _autorefs . current_page , heading . attrib [ \"id\" ]) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) test ( self , parent , block ) \u00a4 Match our autodoc instructions. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required block str The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in mkdocstrings/extension.py def test ( self , parent : Element , block : str ) -> bool : \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) MkdocstringsExtension \u00a4 Our Markdown extension. It cannot work outside of mkdocstrings . __init__ ( self , config , handlers , autorefs , ** kwargs ) special \u00a4 Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in extendMarkdown . required handlers Handlers A mkdocstrings.handlers.base.Handlers instance. required autorefs AutorefsPlugin A mkdocs_autorefs.plugin.AutorefsPlugin instance. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: A [mkdocstrings.handlers.base.Handlers][] instance. autorefs: A [mkdocs_autorefs.plugin.AutorefsPlugin][] instance. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our AutoDocProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md . parser ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. ) get_item_configs ( handler_config , config ) \u00a4 Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[Mapping, Mapping] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ Mapping , Mapping ]: \"\"\"Get the selection and rendering configuration merged into the global configuration of the given handler. Arguments: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = ChainMap ( config . get ( \"selection\" , {}), handler_config . get ( \"selection\" , {})) item_rendering_config = ChainMap ( config . get ( \"rendering\" , {}), handler_config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"extension.py"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor","text":"Our \"autodoc\" Markdown block processor. It has a test method that tells if a block matches a criterion, and a run method that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block.","title":"AutoDocProcessor"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The configuration of the mkdocstrings plugin. required handlers Handlers A mkdocstrings.handlers.base.Handlers instance. required autorefs AutorefsPlugin A mkdocs_autorefs.plugin.AutorefsPlugin instance. required Source code in mkdocstrings/extension.py def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: A [mkdocstrings.handlers.base.Handlers][] instance. autorefs: A [mkdocs_autorefs.plugin.AutorefsPlugin][] instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_env = False","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.run","text":"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks MutableSequence[str] The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] # type: ignore block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , headings = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. el . extend ( headings ) for heading in headings : self . _autorefs . register_anchor ( self . _autorefs . current_page , heading . attrib [ \"id\" ]) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest )","title":"run()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.test","text":"Match our autodoc instructions. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required block str The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in mkdocstrings/extension.py def test ( self , parent : Element , block : str ) -> bool : \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block ))","title":"test()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension","text":"Our Markdown extension. It cannot work outside of mkdocstrings .","title":"MkdocstringsExtension"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in extendMarkdown . required handlers Handlers A mkdocstrings.handlers.base.Handlers instance. required autorefs AutorefsPlugin A mkdocs_autorefs.plugin.AutorefsPlugin instance. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: A [mkdocstrings.handlers.base.Handlers][] instance. autorefs: A [mkdocs_autorefs.plugin.AutorefsPlugin][] instance. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","text":"Register the extension. Add an instance of our AutoDocProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md . parser ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. )","title":"extendMarkdown()"},{"location":"reference/extension/#mkdocstrings.extension.get_item_configs","text":"Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[Mapping, Mapping] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ Mapping , Mapping ]: \"\"\"Get the selection and rendering configuration merged into the global configuration of the given handler. Arguments: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = ChainMap ( config . get ( \"selection\" , {}), handler_config . get ( \"selection\" , {})) item_rendering_config = ChainMap ( config . get ( \"rendering\" , {}), handler_config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"get_item_configs()"},{"location":"reference/loggers/","text":"Logging functions. LoggerAdapter \u00a4 A logger adapter to prefix messages. __init__ ( self , prefix , logger ) special \u00a4 Initialize the object. Parameters: Name Type Description Default prefix str The string to insert in front of every message. required logger The logger instance. required Source code in mkdocstrings/loggers.py def __init__ ( self , prefix : str , logger ): \"\"\"Initialize the object. Arguments: prefix: The string to insert in front of every message. logger: The logger instance. \"\"\" super () . __init__ ( logger , {}) self . prefix = prefix process ( self , msg , kwargs ) \u00a4 Process the message. Parameters: Name Type Description Default msg str The message: required kwargs Remaining arguments. required Returns: Type Description Tuple[str, Any] The processed message. Source code in mkdocstrings/loggers.py def process ( self , msg : str , kwargs ) -> Tuple [ str , Any ]: \"\"\"Process the message. Arguments: msg: The message: kwargs: Remaining arguments. Returns: The processed message. \"\"\" return f \" { self . prefix } : { msg } \" , kwargs TemplateLogger \u00a4 A wrapper class to allow logging in templates. Attributes: Name Type Description debug Function to log a DEBUG message. info Function to log an INFO message. warning Function to log a WARNING message. error Function to log an ERROR message. critical Function to log a CRITICAL message. __init__ ( self , logger ) special \u00a4 Initialize the object. Parameters: Name Type Description Default logger LoggerAdapter A logger adapter. required Source code in mkdocstrings/loggers.py def __init__ ( self , logger : LoggerAdapter ): \"\"\"Initialize the object. Arguments: logger: A logger adapter. \"\"\" self . debug = get_template_logger_function ( logger . debug ) self . info = get_template_logger_function ( logger . info ) self . warning = get_template_logger_function ( logger . warning ) self . error = get_template_logger_function ( logger . error ) self . critical = get_template_logger_function ( logger . critical ) get_logger ( name ) \u00a4 Return a pre-configured logger. Parameters: Name Type Description Default name str The name to use with logging.getLogger . required Returns: Type Description LoggerAdapter A logger configured to work well in MkDocs. Source code in mkdocstrings/loggers.py def get_logger ( name : str ) -> LoggerAdapter : \"\"\"Return a pre-configured logger. Arguments: name: The name to use with `logging.getLogger`. Returns: A logger configured to work well in MkDocs. \"\"\" logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) logger . addFilter ( warning_filter ) return LoggerAdapter ( name , logger ) get_template_logger () \u00a4 Return a logger usable in templates. Returns: Type Description TemplateLogger A template logger. Source code in mkdocstrings/loggers.py def get_template_logger () -> TemplateLogger : \"\"\"Return a logger usable in templates. Returns: A template logger. \"\"\" return TemplateLogger ( get_logger ( \"mkdocstrings.templates\" )) get_template_logger_function ( logger_func ) \u00a4 Create a wrapper function that automatically receives the Jinja template context. Parameters: Name Type Description Default logger_func Callable The logger function to use within the wrapper. required Returns: Type Description Callable A function. Source code in mkdocstrings/loggers.py def get_template_logger_function ( logger_func : Callable ) -> Callable : \"\"\"Create a wrapper function that automatically receives the Jinja template context. Arguments: logger_func: The logger function to use within the wrapper. Returns: A function. \"\"\" @contextfunction def wrapper ( context : Context , msg : Optional [ str ] = None ) -> str : \"\"\"Log a message. Arguments: context: The template context, automatically provided by Jinja. msg: The message to log. Returns: An empty string. \"\"\" template_path = get_template_path ( context ) logger_func ( f \" { template_path } : { msg or 'Rendering' } \" ) return \"\" return wrapper get_template_path ( context ) \u00a4 Return the path to the template currently using the given context. Parameters: Name Type Description Default context Context The template context. required Returns: Type Description str The relative path to the template. Source code in mkdocstrings/loggers.py def get_template_path ( context : Context ) -> str : \"\"\"Return the path to the template currently using the given context. Arguments: context: The template context. Returns: The relative path to the template. \"\"\" filename = context . environment . get_template ( context . name ) . filename if filename : try : return str ( Path ( filename ) . relative_to ( TEMPLATES_DIR )) except ValueError : return filename return context . name","title":"loggers.py"},{"location":"reference/loggers/#mkdocstrings.loggers.LoggerAdapter","text":"A logger adapter to prefix messages.","title":"LoggerAdapter"},{"location":"reference/loggers/#mkdocstrings.loggers.LoggerAdapter.__init__","text":"Initialize the object. Parameters: Name Type Description Default prefix str The string to insert in front of every message. required logger The logger instance. required Source code in mkdocstrings/loggers.py def __init__ ( self , prefix : str , logger ): \"\"\"Initialize the object. Arguments: prefix: The string to insert in front of every message. logger: The logger instance. \"\"\" super () . __init__ ( logger , {}) self . prefix = prefix","title":"__init__()"},{"location":"reference/loggers/#mkdocstrings.loggers.LoggerAdapter.process","text":"Process the message. Parameters: Name Type Description Default msg str The message: required kwargs Remaining arguments. required Returns: Type Description Tuple[str, Any] The processed message. Source code in mkdocstrings/loggers.py def process ( self , msg : str , kwargs ) -> Tuple [ str , Any ]: \"\"\"Process the message. Arguments: msg: The message: kwargs: Remaining arguments. Returns: The processed message. \"\"\" return f \" { self . prefix } : { msg } \" , kwargs","title":"process()"},{"location":"reference/loggers/#mkdocstrings.loggers.TemplateLogger","text":"A wrapper class to allow logging in templates. Attributes: Name Type Description debug Function to log a DEBUG message. info Function to log an INFO message. warning Function to log a WARNING message. error Function to log an ERROR message. critical Function to log a CRITICAL message.","title":"TemplateLogger"},{"location":"reference/loggers/#mkdocstrings.loggers.TemplateLogger.__init__","text":"Initialize the object. Parameters: Name Type Description Default logger LoggerAdapter A logger adapter. required Source code in mkdocstrings/loggers.py def __init__ ( self , logger : LoggerAdapter ): \"\"\"Initialize the object. Arguments: logger: A logger adapter. \"\"\" self . debug = get_template_logger_function ( logger . debug ) self . info = get_template_logger_function ( logger . info ) self . warning = get_template_logger_function ( logger . warning ) self . error = get_template_logger_function ( logger . error ) self . critical = get_template_logger_function ( logger . critical )","title":"__init__()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_logger","text":"Return a pre-configured logger. Parameters: Name Type Description Default name str The name to use with logging.getLogger . required Returns: Type Description LoggerAdapter A logger configured to work well in MkDocs. Source code in mkdocstrings/loggers.py def get_logger ( name : str ) -> LoggerAdapter : \"\"\"Return a pre-configured logger. Arguments: name: The name to use with `logging.getLogger`. Returns: A logger configured to work well in MkDocs. \"\"\" logger = logging . getLogger ( f \"mkdocs.plugins. { name } \" ) logger . addFilter ( warning_filter ) return LoggerAdapter ( name , logger )","title":"get_logger()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_template_logger","text":"Return a logger usable in templates. Returns: Type Description TemplateLogger A template logger. Source code in mkdocstrings/loggers.py def get_template_logger () -> TemplateLogger : \"\"\"Return a logger usable in templates. Returns: A template logger. \"\"\" return TemplateLogger ( get_logger ( \"mkdocstrings.templates\" ))","title":"get_template_logger()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_template_logger_function","text":"Create a wrapper function that automatically receives the Jinja template context. Parameters: Name Type Description Default logger_func Callable The logger function to use within the wrapper. required Returns: Type Description Callable A function. Source code in mkdocstrings/loggers.py def get_template_logger_function ( logger_func : Callable ) -> Callable : \"\"\"Create a wrapper function that automatically receives the Jinja template context. Arguments: logger_func: The logger function to use within the wrapper. Returns: A function. \"\"\" @contextfunction def wrapper ( context : Context , msg : Optional [ str ] = None ) -> str : \"\"\"Log a message. Arguments: context: The template context, automatically provided by Jinja. msg: The message to log. Returns: An empty string. \"\"\" template_path = get_template_path ( context ) logger_func ( f \" { template_path } : { msg or 'Rendering' } \" ) return \"\" return wrapper","title":"get_template_logger_function()"},{"location":"reference/loggers/#mkdocstrings.loggers.get_template_path","text":"Return the path to the template currently using the given context. Parameters: Name Type Description Default context Context The template context. required Returns: Type Description str The relative path to the template. Source code in mkdocstrings/loggers.py def get_template_path ( context : Context ) -> str : \"\"\"Return the path to the template currently using the given context. Arguments: context: The template context. Returns: The relative path to the template. \"\"\" filename = context . environment . get_template ( context . name ) . filename if filename : try : return str ( Path ( filename ) . relative_to ( TEMPLATES_DIR )) except ValueError : return filename return context . name","title":"get_template_path()"},{"location":"reference/plugin/","text":"This module contains the \"mkdocstrings\" plugin for MkDocs. The plugin instantiates a Markdown extension ( MkdocstringsExtension ), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . Once the documentation is built, the on_post_build event hook is triggered and calls the handlers.teardown() method . This method is used to teardown the handlers that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook . RENDERING_OPTS_KEY : str \u00a4 The name of the rendering parameter in YAML configuration blocks. SELECTION_OPTS_KEY : str \u00a4 The name of the selection parameter in YAML configuration blocks. MkdocstringsPlugin \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system. config_scheme : Tuple [ Tuple [ str , mkdocs . config . config_options . Type ]] \u00a4 The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2 handlers : Handlers property readonly \u00a4 Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build. Exceptions: Type Description RuntimeError If the plugin hasn't been initialized with a config. Returns: Type Description Handlers An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build). __init__ ( self ) special \u00a4 Initialize the object. Source code in mkdocstrings/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Optional [ Handlers ] = None get_handler ( self , handler_name ) \u00a4 Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler . Parameters: Name Type Description Default handler_name str The name of the handler. required Returns: Type Description BaseHandler An instance of a subclass of BaseHandler . Source code in mkdocstrings/plugin.py def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) on_config ( self , config , ** kwargs ) \u00a4 Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our MkdocstringsExtension and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocstrings/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613 (unused arguments) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . _handlers = Handlers ( extension_config ) try : # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . _handlers . get_anchor mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . _handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. return config on_post_build ( self , config , ** kwargs ) \u00a4 Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the Python handler's collector opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its teardown() method which is indirectly called by this hook. Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py def on_post_build ( self , config : Config , ** kwargs ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. \"\"\" if self . _handlers : css_content = \" \\n \" . join ( handler . renderer . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) log . debug ( \"Tearing handlers down\" ) self . _handlers . teardown () on_serve ( self , server , builder = None , ** kwargs ) \u00a4 Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server Server The livereload server instance. required builder Callable The function to build the site. None kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Server The server instance. Source code in mkdocstrings/plugin.py def on_serve ( self , server : Server , builder : Callable = None , ** kwargs ) -> Server : # noqa: W0613 (unused arguments) \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. kwargs: Additional arguments passed by MkDocs. Returns: The server instance. \"\"\" if builder is None : # The builder parameter was added in mkdocs v1.1.1. # See issue https://github.com/mkdocs/mkdocs/issues/1952. builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] # noqa: W0212 (protected member) for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin.RENDERING_OPTS_KEY","text":"The name of the rendering parameter in YAML configuration blocks.","title":"RENDERING_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.SELECTION_OPTS_KEY","text":"The name of the selection parameter in YAML configuration blocks.","title":"SELECTION_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system.","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","text":"The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2","title":"config_scheme"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.handlers","text":"Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build. Exceptions: Type Description RuntimeError If the plugin hasn't been initialized with a config. Returns: Type Description Handlers An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build).","title":"handlers"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","text":"Initialize the object. Source code in mkdocstrings/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Optional [ Handlers ] = None","title":"__init__()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.get_handler","text":"Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler . Parameters: Name Type Description Default handler_name str The name of the handler. required Returns: Type Description BaseHandler An instance of a subclass of BaseHandler . Source code in mkdocstrings/plugin.py def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name )","title":"get_handler()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our MkdocstringsExtension and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocstrings/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613 (unused arguments) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . _handlers = Handlers ( extension_config ) try : # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . _handlers . get_anchor mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . _handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. return config","title":"on_config()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","text":"Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the Python handler's collector opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its teardown() method which is indirectly called by this hook. Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py def on_post_build ( self , config : Config , ** kwargs ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. \"\"\" if self . _handlers : css_content = \" \\n \" . join ( handler . renderer . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) log . debug ( \"Tearing handlers down\" ) self . _handlers . teardown ()","title":"on_post_build()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","text":"Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server Server The livereload server instance. required builder Callable The function to build the site. None kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Server The server instance. Source code in mkdocstrings/plugin.py def on_serve ( self , server : Server , builder : Callable = None , ** kwargs ) -> Server : # noqa: W0613 (unused arguments) \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. kwargs: Additional arguments passed by MkDocs. Returns: The server instance. \"\"\" if builder is None : # The builder parameter was added in mkdocs v1.1.1. # See issue https://github.com/mkdocs/mkdocs/issues/1952. builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] # noqa: W0212 (protected member) for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server","title":"on_serve()"},{"location":"reference/autorefs/plugin/","text":"This module contains the \"mkdocs-autorefs\" plugin. After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_content event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. AutorefsPlugin \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_content on_post_page Check the Developing Plugins page of mkdocs for more information about its plugin system. __init__ ( self ) special \u00a4 Initialize the object. Source code in mkdocs_autorefs/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Callable [[ str ], Optional [ str ]] = lambda identifier : None get_item_url ( self , anchor ) \u00a4 Return a site-relative URL with anchor to the identifier, if it's present anywhere. Parameters: Name Type Description Default anchor str The anchor (without '#'). required Returns: Type Description str A site-relative URL. Exceptions: Type Description KeyError If there isn't an item by this identifier anywhere on the site. Source code in mkdocs_autorefs/plugin.py def get_item_url ( self , anchor : str ) -> str : \"\"\" Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: anchor: The anchor (without '#'). Returns: A site-relative URL. Raises: KeyError: If there isn't an item by this identifier anywhere on the site. \"\"\" try : return self . _url_map [ anchor ] except KeyError : new_anchor = self . get_fallback_anchor ( anchor ) if new_anchor and new_anchor in self . _url_map : return self . _url_map [ new_anchor ] raise map_urls ( self , base_url , anchor ) \u00a4 Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocs_autorefs/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) on_config ( self , config , ** kwargs ) \u00a4 Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our AutorefsExtension and add it to the list of Markdown extensions used by mkdocs . Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocs_autorefs/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\" Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config on_page_content ( self , html , page , ** kwargs ) \u00a4 Map anchors to URLs. Hook for the on_page_content event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html on_page_markdown ( self , markdown , page , ** kwargs ) \u00a4 Remember which page is the current one. Parameters: Name Type Description Default markdown str Input Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same Markdown. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url return markdown on_post_page ( self , output , page , ** kwargs ) \u00a4 Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our AUTO_REF_RE regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocs_autorefs/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) fixed_output , unmapped = fix_refs ( output , page . url , self . get_item_url ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output register_anchor ( self , page , anchor ) \u00a4 Register that an anchor corresponding to an identifier was encountered when rendering the page. Parameters: Name Type Description Default page str The relative URL of the current page. Examples: 'foo/bar/' , 'foo/index.html' required anchor str The HTML anchor (without '#') as a string. required Source code in mkdocs_autorefs/plugin.py def register_anchor ( self , page : str , anchor : str ): \"\"\" Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` anchor: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ anchor ] = f \" { page } # { anchor } \"","title":"plugin.py"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_content on_post_page Check the Developing Plugins page of mkdocs for more information about its plugin system.","title":"AutorefsPlugin"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.__init__","text":"Initialize the object. Source code in mkdocs_autorefs/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Callable [[ str ], Optional [ str ]] = lambda identifier : None","title":"__init__()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url","text":"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Parameters: Name Type Description Default anchor str The anchor (without '#'). required Returns: Type Description str A site-relative URL. Exceptions: Type Description KeyError If there isn't an item by this identifier anywhere on the site. Source code in mkdocs_autorefs/plugin.py def get_item_url ( self , anchor : str ) -> str : \"\"\" Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: anchor: The anchor (without '#'). Returns: A site-relative URL. Raises: KeyError: If there isn't an item by this identifier anywhere on the site. \"\"\" try : return self . _url_map [ anchor ] except KeyError : new_anchor = self . get_fallback_anchor ( anchor ) if new_anchor and new_anchor in self . _url_map : return self . _url_map [ new_anchor ] raise","title":"get_item_url()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.map_urls","text":"Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocs_autorefs/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child )","title":"map_urls()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our AutorefsExtension and add it to the list of Markdown extensions used by mkdocs . Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocs_autorefs/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\" Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config","title":"on_config()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_page_content","text":"Map anchors to URLs. Hook for the on_page_content event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html","title":"on_page_content()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_page_markdown","text":"Remember which page is the current one. Parameters: Name Type Description Default markdown str Input Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same Markdown. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url return markdown","title":"on_page_markdown()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_post_page","text":"Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our AUTO_REF_RE regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocs_autorefs/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) fixed_output , unmapped = fix_refs ( output , page . url , self . get_item_url ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output","title":"on_post_page()"},{"location":"reference/autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.register_anchor","text":"Register that an anchor corresponding to an identifier was encountered when rendering the page. Parameters: Name Type Description Default page str The relative URL of the current page. Examples: 'foo/bar/' , 'foo/index.html' required anchor str The HTML anchor (without '#') as a string. required Source code in mkdocs_autorefs/plugin.py def register_anchor ( self , page : str , anchor : str ): \"\"\" Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` anchor: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ anchor ] = f \" { page } # { anchor } \"","title":"register_anchor()"},{"location":"reference/autorefs/references/","text":"Cross-references module. AUTO_REF_RE \u00a4 A regular expression to match mkdocs-autorefs' special reference markers in the on_post_page hook . AutoRefInlineProcessor \u00a4 A Markdown extension. evalId ( self , data , index , text ) \u00a4 Evaluate the id portion of [ref][id] . If [ref][] use [ref] . Parameters: Name Type Description Default data str The data to evaluate. required index int The starting position. required text str The text to use when no identifier. required Returns: Type Description Tuple[Any, Any, Any] A tuple containing the identifier, its end position, and whether it matched. Source code in mkdocs_autorefs/references.py def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\" Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) if not m : return None , index , False identifier = m . group ( 1 ) or text end = m . end ( 0 ) return identifier , end , True handleMatch ( self , m , data ) \u00a4 Handle an element that matched. Parameters: Name Type Description Default m The match object. required data The matched data. required Returns: Type Description Union[xml.etree.ElementTree.Element, Tuple[Any, Any, Any]] A new element or a tuple. Source code in mkdocs_autorefs/references.py def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # noqa: N802 (parent's casing) \"\"\" Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # type: ignore # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end makeTag ( self , identifier , text ) \u00a4 Create a tag that can be matched by AUTO_REF_RE . Parameters: Name Type Description Default identifier str The identifier to use in the HTML property. required text str The text to use in the HTML tag. required Returns: Type Description Element A new element. Source code in mkdocs_autorefs/references.py def makeTag ( self , identifier : str , text : str ) -> Element : # noqa: N802,W0221 (parent's casing, different params) \"\"\" Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-mkdocstrings-identifier\" , identifier ) el . text = text return el AutorefsExtension \u00a4 Extension that inserts auto-references in Markdown. extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our AutoRefInlineProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocs_autorefs/references.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\" Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # Right after markdown.inlinepatterns.ReferenceInlineProcessor ) fix_ref ( url_mapper , from_url , unmapped ) \u00a4 Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required from_url str The URL of the base page, from which we link towards the targeted pages. required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocs_autorefs/references.py def fix_ref ( url_mapper : Callable [[ str ], str ], from_url : str , unmapped : List [ str ]) -> Callable : \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. from_url: The URL of the base page, from which we link towards the targeted pages. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): identifier = match [ \"identifier\" ] title = match [ \"title\" ] try : url = relative_url ( from_url , url_mapper ( unescape ( identifier ))) except KeyError : unmapped . append ( identifier ) if title == identifier : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" return f '<a href=\" { escape ( url ) } \"> { title } </a>' return inner fix_refs ( html , from_url , url_mapper ) \u00a4 Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required from_url str The URL at which this HTML is served. required url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocs_autorefs/references.py def fix_refs ( html : str , from_url : str , url_mapper : Callable [[ str ], str ], ) -> Tuple [ str , List [ str ]]: \"\"\" Fix all references in the given HTML text. Arguments: html: The text to fix. from_url: The URL at which this HTML is served. url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore html = AUTO_REF_RE . sub ( fix_ref ( url_mapper , from_url , unmapped ), html ) return html , unmapped relative_url ( url_a , url_b ) \u00a4 Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocs_autorefs/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\" Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) - 1 parts_relative = [ \"..\" ] * levels + parts_b relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"references.py"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AUTO_REF_RE","text":"A regular expression to match mkdocs-autorefs' special reference markers in the on_post_page hook .","title":"AUTO_REF_RE"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor","text":"A Markdown extension.","title":"AutoRefInlineProcessor"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor.evalId","text":"Evaluate the id portion of [ref][id] . If [ref][] use [ref] . Parameters: Name Type Description Default data str The data to evaluate. required index int The starting position. required text str The text to use when no identifier. required Returns: Type Description Tuple[Any, Any, Any] A tuple containing the identifier, its end position, and whether it matched. Source code in mkdocs_autorefs/references.py def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\" Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) if not m : return None , index , False identifier = m . group ( 1 ) or text end = m . end ( 0 ) return identifier , end , True","title":"evalId()"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor.handleMatch","text":"Handle an element that matched. Parameters: Name Type Description Default m The match object. required data The matched data. required Returns: Type Description Union[xml.etree.ElementTree.Element, Tuple[Any, Any, Any]] A new element or a tuple. Source code in mkdocs_autorefs/references.py def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # noqa: N802 (parent's casing) \"\"\" Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # type: ignore # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end","title":"handleMatch()"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor.makeTag","text":"Create a tag that can be matched by AUTO_REF_RE . Parameters: Name Type Description Default identifier str The identifier to use in the HTML property. required text str The text to use in the HTML tag. required Returns: Type Description Element A new element. Source code in mkdocs_autorefs/references.py def makeTag ( self , identifier : str , text : str ) -> Element : # noqa: N802,W0221 (parent's casing, different params) \"\"\" Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-mkdocstrings-identifier\" , identifier ) el . text = text return el","title":"makeTag()"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AutorefsExtension","text":"Extension that inserts auto-references in Markdown.","title":"AutorefsExtension"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.AutorefsExtension.extendMarkdown","text":"Register the extension. Add an instance of our AutoRefInlineProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocs_autorefs/references.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\" Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # Right after markdown.inlinepatterns.ReferenceInlineProcessor )","title":"extendMarkdown()"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.fix_ref","text":"Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required from_url str The URL of the base page, from which we link towards the targeted pages. required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocs_autorefs/references.py def fix_ref ( url_mapper : Callable [[ str ], str ], from_url : str , unmapped : List [ str ]) -> Callable : \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. from_url: The URL of the base page, from which we link towards the targeted pages. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): identifier = match [ \"identifier\" ] title = match [ \"title\" ] try : url = relative_url ( from_url , url_mapper ( unescape ( identifier ))) except KeyError : unmapped . append ( identifier ) if title == identifier : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" return f '<a href=\" { escape ( url ) } \"> { title } </a>' return inner","title":"fix_ref()"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.fix_refs","text":"Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required from_url str The URL at which this HTML is served. required url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocs_autorefs/references.py def fix_refs ( html : str , from_url : str , url_mapper : Callable [[ str ], str ], ) -> Tuple [ str , List [ str ]]: \"\"\" Fix all references in the given HTML text. Arguments: html: The text to fix. from_url: The URL at which this HTML is served. url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore html = AUTO_REF_RE . sub ( fix_ref ( url_mapper , from_url , unmapped ), html ) return html , unmapped","title":"fix_refs()"},{"location":"reference/autorefs/references/#mkdocs_autorefs.references.relative_url","text":"Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocs_autorefs/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\" Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) - 1 parts_relative = [ \"..\" ] * levels + parts_b relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"relative_url()"},{"location":"reference/handlers/base/","text":"Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache. BaseCollector \u00a4 The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. collect ( self , identifier , config ) \u00a4 Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Any Anything you want, as long as you can feed it to the renderer's render method. Source code in handlers/base.py @abstractmethod def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section) teardown ( self ) \u00a4 Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in handlers/base.py def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\" BaseHandler \u00a4 The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. __init__ ( self , collector , renderer ) special \u00a4 Initialize the object. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in handlers/base.py def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer BaseRenderer \u00a4 The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a fallback_theme class-variable. To add custom CSS, add an extra_css variable or create an 'style.css' file beside the templates. __init__ ( self , directory , theme , custom_templates = None ) special \u00a4 Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required custom_templates Optional[str] Directory containing custom templates. None Source code in handlers/base.py def __init__ ( self , directory : str , theme : str , custom_templates : Optional [ str ] = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] themes_dir = TEMPLATES_DIR / directory paths . append ( themes_dir / theme ) if self . fallback_theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / directory / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) # type: ignore self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings = [] self . _md = None # To be populated in `update_env`. do_convert_markdown ( self , text , heading_level , html_id = '' ) \u00a4 Render Markdown text; for use inside templates. Parameters: Name Type Description Default text str The text to convert. required heading_level int The base heading level to start all Markdown headings from. required html_id str The HTML id of the element that's considered the parent of this element. '' Returns: Type Description Markup An HTML string. Source code in handlers/base.py def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" self . _md . reset () do_heading ( self , content , heading_level , * , hidden = False , toc_label = None , ** attributes ) \u00a4 Render an HTML heading and register it for the table of contents. For use inside templates. Parameters: Name Type Description Default content str The HTML within the heading. required heading_level int The level of heading (e.g. 3 -> h3 ). required hidden bool If True, only register it for the table of contents, don't render anything. False toc_label Optional[str] The title to use in the table of contents ('data-toc-label' attribute). None attributes str Any extra HTML attributes of the heading. {} Returns: Type Description Markup An HTML string. Source code in handlers/base.py def do_heading ( self , content : str , heading_level : int , * , hidden : bool = False , toc_label : Optional [ str ] = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( el , Markup ) else content el . set ( \"data-toc-label\" , toc_label ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) get_anchor ( self , data ) \u00a4 Return the canonical identifier (HTML anchor) for a collected item. This must match what the renderer would've actually rendered, e.g. if rendering the item contains <h2 id=\"foo\">... then the return value should be \"foo\". Parameters: Name Type Description Default data Any The collected data. required Returns: Type Description Optional[str] The HTML anchor (without '#') as a string, or None if this item doesn't have an anchor. Source code in handlers/base.py def get_anchor ( self , data : CollectorItem ) -> Optional [ str ]: \"\"\"Return the canonical identifier (HTML anchor) for a collected item. This must match what the renderer would've actually rendered, e.g. if rendering the item contains `<h2 id=\"foo\">...` then the return value should be \"foo\". Arguments: data: The collected data. Returns: The HTML anchor (without '#') as a string, or None if this item doesn't have an anchor. \"\"\" # noqa: DAR202 (excess return section) get_headings ( self ) \u00a4 Return and clear the headings gathered so far. Returns: Type Description Sequence[xml.etree.ElementTree.Element] A list of HTML elements. Source code in handlers/base.py def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in handlers/base.py @abstractmethod def render ( self , data : CollectorItem , config : dict ) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section) update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in handlers/base.py def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: W0613 (unused argument 'config') \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading CollectionError \u00a4 An exception raised when some collection of data failed. Handlers \u00a4 A collection of handlers. Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access. seen_handlers : Iterable [ mkdocstrings . handlers . base . BaseHandler ] property readonly \u00a4 Get the handlers that were encountered so far throughout the build. Returns: Type Description Iterable[mkdocstrings.handlers.base.BaseHandler] An iterable of instances of BaseHandler (usable only to loop through it). __init__ ( self , config ) special \u00a4 Initialize the object. Parameters: Name Type Description Default config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in handlers/base.py def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : Dict [ str , BaseHandler ] = {} get_anchor ( self , identifier ) \u00a4 Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Parameters: Name Type Description Default identifier str The identifier (one that collect can accept). required Returns: Type Description Optional[str] A string - anchor without '#', or None if there isn't any identifier familiar with it. Source code in handlers/base.py def get_anchor ( self , identifier : str ) -> Optional [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A string - anchor without '#', or None if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): try : anchor = handler . renderer . get_anchor ( handler . collector . collect ( identifier , {})) except CollectionError : continue else : if anchor is not None : return anchor return None get_handler ( self , name , handler_config = None ) \u00a4 Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required handler_config Optional[dict] Configuration passed to the handler. None Returns: Type Description BaseHandler An instance of a subclass of BaseHandler , as instantiated by the get_handler method of the handler's module. Source code in handlers/base.py def get_handler ( self , name : str , handler_config : Optional [ dict ] = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) self . _handlers [ name ] = module . get_handler ( self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) # type: ignore return self . _handlers [ name ] get_handler_config ( self , name ) \u00a4 Return the global configuration of the given handler. Parameters: Name Type Description Default name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in handlers/base.py def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} get_handler_name ( self , config ) \u00a4 Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in handlers/base.py def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return config [ \"default_handler\" ] teardown ( self ) \u00a4 Teardown all cached handlers and clear the cache. Source code in handlers/base.py def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . collector . teardown () self . _handlers . clear () ThemeNotSupported \u00a4 An exception raised to tell a theme is not supported. do_any ( seq , attribute = None ) \u00a4 Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in handlers/base.py def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\"Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"base.py"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseCollector","text":"The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method.","title":"BaseCollector"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseCollector.collect","text":"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Any Anything you want, as long as you can feed it to the renderer's render method. Source code in handlers/base.py @abstractmethod def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section)","title":"collect()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseCollector.teardown","text":"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in handlers/base.py def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\"","title":"teardown()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseHandler","text":"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need.","title":"BaseHandler"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseHandler.__init__","text":"Initialize the object. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in handlers/base.py def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer","title":"__init__()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer","text":"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a fallback_theme class-variable. To add custom CSS, add an extra_css variable or create an 'style.css' file beside the templates.","title":"BaseRenderer"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.__init__","text":"Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required custom_templates Optional[str] Directory containing custom templates. None Source code in handlers/base.py def __init__ ( self , directory : str , theme : str , custom_templates : Optional [ str ] = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] themes_dir = TEMPLATES_DIR / directory paths . append ( themes_dir / theme ) if self . fallback_theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / directory / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) # type: ignore self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings = [] self . _md = None # To be populated in `update_env`.","title":"__init__()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.do_convert_markdown","text":"Render Markdown text; for use inside templates. Parameters: Name Type Description Default text str The text to convert. required heading_level int The base heading level to start all Markdown headings from. required html_id str The HTML id of the element that's considered the parent of this element. '' Returns: Type Description Markup An HTML string. Source code in handlers/base.py def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" self . _md . reset ()","title":"do_convert_markdown()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.do_heading","text":"Render an HTML heading and register it for the table of contents. For use inside templates. Parameters: Name Type Description Default content str The HTML within the heading. required heading_level int The level of heading (e.g. 3 -> h3 ). required hidden bool If True, only register it for the table of contents, don't render anything. False toc_label Optional[str] The title to use in the table of contents ('data-toc-label' attribute). None attributes str Any extra HTML attributes of the heading. {} Returns: Type Description Markup An HTML string. Source code in handlers/base.py def do_heading ( self , content : str , heading_level : int , * , hidden : bool = False , toc_label : Optional [ str ] = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( el , Markup ) else content el . set ( \"data-toc-label\" , toc_label ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html )","title":"do_heading()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.get_anchor","text":"Return the canonical identifier (HTML anchor) for a collected item. This must match what the renderer would've actually rendered, e.g. if rendering the item contains <h2 id=\"foo\">... then the return value should be \"foo\". Parameters: Name Type Description Default data Any The collected data. required Returns: Type Description Optional[str] The HTML anchor (without '#') as a string, or None if this item doesn't have an anchor. Source code in handlers/base.py def get_anchor ( self , data : CollectorItem ) -> Optional [ str ]: \"\"\"Return the canonical identifier (HTML anchor) for a collected item. This must match what the renderer would've actually rendered, e.g. if rendering the item contains `<h2 id=\"foo\">...` then the return value should be \"foo\". Arguments: data: The collected data. Returns: The HTML anchor (without '#') as a string, or None if this item doesn't have an anchor. \"\"\" # noqa: DAR202 (excess return section)","title":"get_anchor()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.get_headings","text":"Return and clear the headings gathered so far. Returns: Type Description Sequence[xml.etree.ElementTree.Element] A list of HTML elements. Source code in handlers/base.py def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result","title":"get_headings()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in handlers/base.py @abstractmethod def render ( self , data : CollectorItem , config : dict ) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section)","title":"render()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.BaseRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in handlers/base.py def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: W0613 (unused argument 'config') \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading","title":"update_env()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.CollectionError","text":"An exception raised when some collection of data failed.","title":"CollectionError"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers","text":"A collection of handlers. Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access.","title":"Handlers"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.seen_handlers","text":"Get the handlers that were encountered so far throughout the build. Returns: Type Description Iterable[mkdocstrings.handlers.base.BaseHandler] An iterable of instances of BaseHandler (usable only to loop through it).","title":"seen_handlers"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in handlers/base.py def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : Dict [ str , BaseHandler ] = {}","title":"__init__()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_anchor","text":"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Parameters: Name Type Description Default identifier str The identifier (one that collect can accept). required Returns: Type Description Optional[str] A string - anchor without '#', or None if there isn't any identifier familiar with it. Source code in handlers/base.py def get_anchor ( self , identifier : str ) -> Optional [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A string - anchor without '#', or None if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): try : anchor = handler . renderer . get_anchor ( handler . collector . collect ( identifier , {})) except CollectionError : continue else : if anchor is not None : return anchor return None","title":"get_anchor()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_handler","text":"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required handler_config Optional[dict] Configuration passed to the handler. None Returns: Type Description BaseHandler An instance of a subclass of BaseHandler , as instantiated by the get_handler method of the handler's module. Source code in handlers/base.py def get_handler ( self , name : str , handler_config : Optional [ dict ] = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) self . _handlers [ name ] = module . get_handler ( self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) # type: ignore return self . _handlers [ name ]","title":"get_handler()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_handler_config","text":"Return the global configuration of the given handler. Parameters: Name Type Description Default name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in handlers/base.py def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {}","title":"get_handler_config()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.get_handler_name","text":"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in handlers/base.py def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return config [ \"default_handler\" ]","title":"get_handler_name()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.Handlers.teardown","text":"Teardown all cached handlers and clear the cache. Source code in handlers/base.py def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . collector . teardown () self . _handlers . clear ()","title":"teardown()"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.ThemeNotSupported","text":"An exception raised to tell a theme is not supported.","title":"ThemeNotSupported"},{"location":"reference/handlers/base/#mkdocstrings.handlers.base.do_any","text":"Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in handlers/base.py def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\"Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"do_any()"},{"location":"reference/handlers/python/","text":"This module implements a handler for the Python language. The handler collects data with pytkdocs . PythonCollector \u00a4 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the BaseRenderer class . default_config : dict \u00a4 The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore \"^__\" : but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default. __init__ ( self , setup_commands = None ) special \u00a4 Initialize the object. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Parameters: Name Type Description Default setup_commands Optional[List[str]] A list of python commands as strings to be executed in the subprocess before pytkdocs . None Source code in handlers/python.py def __init__ ( self , setup_commands : Optional [ List [ str ]] = None ) -> None : \"\"\"Initialize the object. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. Arguments: setup_commands: A list of python commands as strings to be executed in the subprocess before `pytkdocs`. \"\"\" log . debug ( \"Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" if setup_commands : # prevent the Python interpreter or the setup commands # from writing to stdout as it would break pytkdocs output commands = [ \"import sys\" , \"from io import StringIO\" , \"from pytkdocs.cli import main as pytkdocs\" , \"sys.stdout = StringIO()\" , # redirect stdout to memory buffer * setup_commands , \"sys.stdout.flush()\" , \"sys.stdout = sys.__stdout__\" , # restore stdout \"pytkdocs(['--line-by-line'])\" , ] cmd = [ sys . executable , \"-c\" , \"; \" . join ( commands )] else : cmd = [ sys . executable , \"-m\" , \"pytkdocs\" , \"--line-by-line\" ] self . process = Popen ( # noqa: S603,S607 (we trust the input, and we don't want to use the absolute path) cmd , universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , ) collect ( self , identifier , config ) \u00a4 Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see rebuild_category_lists() ), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Exceptions: Type Description CollectionError When there was a problem collecting the object documentation. Returns: Type Description Any The collected object-tree. Source code in handlers/python.py def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Raises: CollectionError: When there was a problem collecting the object documentation. Returns: The collected object-tree. \"\"\" final_config = ChainMap ( config , self . default_config ) log . debug ( \"Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"Writing to process' stdin\" ) self . process . stdin . write ( json_input + \" \\n \" ) # type: ignore self . process . stdin . flush () # type: ignore log . debug ( \"Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as exception : error = \" \\n \" . join (( \"Error while loading JSON:\" , stdout , traceback . format_exc ())) raise CollectionError ( error ) from exception error = result . get ( \"error\" ) if error : if \"traceback\" in result : error += f \" \\n { result [ 'traceback' ] } \" raise CollectionError ( error ) for loading_error in result [ \"loading_errors\" ]: log . warning ( loading_error ) for errors in result [ \"parsing_errors\" ] . values (): for parsing_error in errors : log . warning ( parsing_error ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result teardown ( self ) \u00a4 Terminate the opened subprocess, set it to None . Source code in handlers/python.py def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to `None`.\"\"\" log . debug ( \"Tearing process down\" ) self . process . terminate () PythonHandler \u00a4 The Python handler class, nothing specific here. PythonRenderer \u00a4 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the BaseRenderer class . Attributes: Name Type Description fallback_theme str The theme to fallback to. default_config dict The default rendering options, see default_config . default_config : dict \u00a4 The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_root_members_full_path bool Show the full Python path of objects that are children of the root object (for example, classes in a module). When False, show_object_full_path overrides. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_signature_annotations bool Show the type annotations in methods and functions signatures. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 get_anchor ( self , data ) \u00a4 Return the canonical identifier (HTML anchor) for a collected item. This must match what the renderer would've actually rendered, e.g. if rendering the item contains <h2 id=\"foo\">... then the return value should be \"foo\". Parameters: Name Type Description Default data Any The collected data. required Returns: Type Description str The HTML anchor (without '#') as a string, or None if this item doesn't have an anchor. Source code in handlers/python.py def get_anchor ( self , data : CollectorItem ) -> str : # noqa: D102 (ignore missing docstring) return data . get ( \"path\" ) render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in handlers/python.py def render ( self , data : CollectorItem , config : dict ) -> str : # noqa: D102 (ignore missing docstring) final_config = ChainMap ( config , self . default_config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # than as an item in a dictionary. heading_level = final_config [ \"heading_level\" ] return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True }, ) update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in handlers/python.py def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: D102 (ignore missing docstring) super () . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False get_handler ( theme , custom_templates = None , setup_commands = None , ** config ) \u00a4 Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required custom_templates Optional[str] Directory containing custom templates. None setup_commands Optional[List[str]] A list of commands as strings to be executed in the subprocess before pytkdocs . None config Any Configuration passed to the handler. {} Returns: Type Description PythonHandler An instance of PythonHandler . Source code in handlers/python.py def get_handler ( theme : str , # noqa: W0613 (unused argument config) custom_templates : Optional [ str ] = None , setup_commands : Optional [ List [ str ]] = None , ** config : Any , ) -> PythonHandler : \"\"\"Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. custom_templates: Directory containing custom templates. setup_commands: A list of commands as strings to be executed in the subprocess before `pytkdocs`. config: Configuration passed to the handler. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector ( setup_commands = setup_commands ), renderer = PythonRenderer ( \"python\" , theme , custom_templates ), ) rebuild_category_lists ( obj ) \u00a4 Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in handlers/python.py def rebuild_category_lists ( obj : dict ) -> None : \"\"\"Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Arguments: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" for category in ( \"attributes\" , \"classes\" , \"functions\" , \"methods\" , \"modules\" ): obj [ category ] = [ obj [ \"children\" ][ path ] for path in obj [ category ]] obj [ \"children\" ] = [ child for _ , child in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"python.py"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the BaseRenderer class .","title":"PythonCollector"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.default_config","text":"The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore \"^__\" : but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default.","title":"default_config"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.__init__","text":"Initialize the object. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Parameters: Name Type Description Default setup_commands Optional[List[str]] A list of python commands as strings to be executed in the subprocess before pytkdocs . None Source code in handlers/python.py def __init__ ( self , setup_commands : Optional [ List [ str ]] = None ) -> None : \"\"\"Initialize the object. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. Arguments: setup_commands: A list of python commands as strings to be executed in the subprocess before `pytkdocs`. \"\"\" log . debug ( \"Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" if setup_commands : # prevent the Python interpreter or the setup commands # from writing to stdout as it would break pytkdocs output commands = [ \"import sys\" , \"from io import StringIO\" , \"from pytkdocs.cli import main as pytkdocs\" , \"sys.stdout = StringIO()\" , # redirect stdout to memory buffer * setup_commands , \"sys.stdout.flush()\" , \"sys.stdout = sys.__stdout__\" , # restore stdout \"pytkdocs(['--line-by-line'])\" , ] cmd = [ sys . executable , \"-c\" , \"; \" . join ( commands )] else : cmd = [ sys . executable , \"-m\" , \"pytkdocs\" , \"--line-by-line\" ] self . process = Popen ( # noqa: S603,S607 (we trust the input, and we don't want to use the absolute path) cmd , universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , )","title":"__init__()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.collect","text":"Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see rebuild_category_lists() ), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Exceptions: Type Description CollectionError When there was a problem collecting the object documentation. Returns: Type Description Any The collected object-tree. Source code in handlers/python.py def collect ( self , identifier : str , config : dict ) -> CollectorItem : \"\"\"Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Raises: CollectionError: When there was a problem collecting the object documentation. Returns: The collected object-tree. \"\"\" final_config = ChainMap ( config , self . default_config ) log . debug ( \"Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"Writing to process' stdin\" ) self . process . stdin . write ( json_input + \" \\n \" ) # type: ignore self . process . stdin . flush () # type: ignore log . debug ( \"Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as exception : error = \" \\n \" . join (( \"Error while loading JSON:\" , stdout , traceback . format_exc ())) raise CollectionError ( error ) from exception error = result . get ( \"error\" ) if error : if \"traceback\" in result : error += f \" \\n { result [ 'traceback' ] } \" raise CollectionError ( error ) for loading_error in result [ \"loading_errors\" ]: log . warning ( loading_error ) for errors in result [ \"parsing_errors\" ] . values (): for parsing_error in errors : log . warning ( parsing_error ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result","title":"collect()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.teardown","text":"Terminate the opened subprocess, set it to None . Source code in handlers/python.py def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to `None`.\"\"\" log . debug ( \"Tearing process down\" ) self . process . terminate ()","title":"teardown()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonHandler","text":"The Python handler class, nothing specific here.","title":"PythonHandler"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the BaseRenderer class . Attributes: Name Type Description fallback_theme str The theme to fallback to. default_config dict The default rendering options, see default_config .","title":"PythonRenderer"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.default_config","text":"The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_root_members_full_path bool Show the full Python path of objects that are children of the root object (for example, classes in a module). When False, show_object_full_path overrides. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_signature_annotations bool Show the type annotations in methods and functions signatures. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2","title":"default_config"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.get_anchor","text":"Return the canonical identifier (HTML anchor) for a collected item. This must match what the renderer would've actually rendered, e.g. if rendering the item contains <h2 id=\"foo\">... then the return value should be \"foo\". Parameters: Name Type Description Default data Any The collected data. required Returns: Type Description str The HTML anchor (without '#') as a string, or None if this item doesn't have an anchor. Source code in handlers/python.py def get_anchor ( self , data : CollectorItem ) -> str : # noqa: D102 (ignore missing docstring) return data . get ( \"path\" )","title":"get_anchor()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in handlers/python.py def render ( self , data : CollectorItem , config : dict ) -> str : # noqa: D102 (ignore missing docstring) final_config = ChainMap ( config , self . default_config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # than as an item in a dictionary. heading_level = final_config [ \"heading_level\" ] return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True }, )","title":"render()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in handlers/python.py def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: D102 (ignore missing docstring) super () . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False","title":"update_env()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.get_handler","text":"Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required custom_templates Optional[str] Directory containing custom templates. None setup_commands Optional[List[str]] A list of commands as strings to be executed in the subprocess before pytkdocs . None config Any Configuration passed to the handler. {} Returns: Type Description PythonHandler An instance of PythonHandler . Source code in handlers/python.py def get_handler ( theme : str , # noqa: W0613 (unused argument config) custom_templates : Optional [ str ] = None , setup_commands : Optional [ List [ str ]] = None , ** config : Any , ) -> PythonHandler : \"\"\"Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. custom_templates: Directory containing custom templates. setup_commands: A list of commands as strings to be executed in the subprocess before `pytkdocs`. config: Configuration passed to the handler. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector ( setup_commands = setup_commands ), renderer = PythonRenderer ( \"python\" , theme , custom_templates ), )","title":"get_handler()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.rebuild_category_lists","text":"Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in handlers/python.py def rebuild_category_lists ( obj : dict ) -> None : \"\"\"Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Arguments: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" for category in ( \"attributes\" , \"classes\" , \"functions\" , \"methods\" , \"modules\" ): obj [ category ] = [ obj [ \"children\" ][ path ] for path in obj [ category ]] obj [ \"children\" ] = [ child for _ , child in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"rebuild_category_lists()"},{"location":"reference/handlers/rendering/","text":"This module holds helpers responsible for augmentations to the Markdown sub-documents produced by handlers. HeadingShiftingTreeprocessor \u00a4 Shift levels of all Markdown headings according to the configured base level. __init__ ( self , md , shift_by ) special \u00a4 Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required shift_by int The number of heading \"levels\" to add to every heading. required Source code in handlers/rendering.py def __init__ ( self , md : Markdown , shift_by : int ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. shift_by: The number of heading \"levels\" to add to every heading. \"\"\" super () . __init__ ( md ) self . shift_by = shift_by run ( self , root ) \u00a4 Subclasses of Treeprocessor should implement a run method, which takes a root ElementTree. This method can return another ElementTree object, and the existing root ElementTree will be replaced, or it can modify the current tree and return None. Source code in handlers/rendering.py def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . shift_by : return for el in root . iter (): match = self . regex . fullmatch ( el . tag ) if match : level = int ( match [ 2 ]) + self . shift_by level = max ( 1 , min ( level , 6 )) el . tag = f \" { match [ 1 ] }{ level } \" Highlighter \u00a4 Code highlighter that tries to match the Markdown configuration. Picking up the global config and defaults works only if you use the codehilite or pymdownx.highlight (recommended) Markdown extension. If you use pymdownx.highlight , highlighting settings are picked up from it, and the default CSS class is .highlight . This also means the default of guess_lang: false . Otherwise, if you use the codehilite extension, settings are picked up from it, and the default CSS class is .codehilite . Also consider setting guess_lang: false . If neither are added to markdown_extensions , highlighting is enabled anyway. This is for backwards compatibility. If you really want to disable highlighting even in mkdocstrings , add one of these extensions anyway and set use_pygments: false . The underlying implementation is pymdownx.highlight regardless. __init__ ( self , md ) special \u00a4 Configure to match a markdown.Markdown instance. Parameters: Name Type Description Default md Markdown The Markdown instance to read configs from. required Source code in handlers/rendering.py def __init__ ( self , md : Markdown ): \"\"\"Configure to match a `markdown.Markdown` instance. Arguments: md: The Markdown instance to read configs from. \"\"\" config = {} for ext in md . registeredExtensions : if isinstance ( ext , HighlightExtension ) and ( ext . enabled or not config ): config = ext . getConfigs () break # This one takes priority, no need to continue looking if isinstance ( ext , CodeHiliteExtension ) and not config : config = ext . getConfigs () config [ \"language_prefix\" ] = config [ \"lang_prefix\" ] self . _css_class = config . pop ( \"css_class\" , \"highlight\" ) super () . __init__ ( ** { k : v for k , v in config . items () if k in self . _highlight_config_keys }) highlight ( self , src , language = None , * , inline = False , dedent = True , linenums = None , ** kwargs ) \u00a4 Highlight a code-snippet. Parameters: Name Type Description Default src str The code to highlight. required language Optional[str] Explicitly tell what language to use for highlighting. None inline bool Whether to highlight as inline. False dedent bool Whether to dedent the code before highlighting it or not. True linenums Optional[bool] Whether to add line numbers in the result. None **kwargs Pass on to pymdownx.highlight.Highlight.highlight . {} Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in handlers/rendering.py def highlight ( # noqa: W0221 (intentionally different params, we're extending the functionality) self , src : str , language : Optional [ str ] = None , * , inline : bool = False , dedent : bool = True , linenums : Optional [ bool ] = None , ** kwargs , ) -> str : \"\"\"Highlight a code-snippet. Arguments: src: The code to highlight. language: Explicitly tell what language to use for highlighting. inline: Whether to highlight as inline. dedent: Whether to dedent the code before highlighting it or not. linenums: Whether to add line numbers in the result. **kwargs: Pass on to `pymdownx.highlight.Highlight.highlight`. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if isinstance ( src , Markup ): src = src . unescape () if dedent : src = textwrap . dedent ( src ) kwargs . setdefault ( \"css_class\" , self . _css_class ) old_linenums = self . linenums if linenums is not None : self . linenums = linenums try : result = super () . highlight ( src , language , inline = inline , ** kwargs ) finally : self . linenums = old_linenums if inline : return Markup ( f '<code class=\" { kwargs [ \"css_class\" ] } language- { language } \"> { result . text } </code>' ) return Markup ( result ) IdPrependingTreeprocessor \u00a4 Prepend the configured prefix to IDs of all HTML elements. __init__ ( self , md , id_prefix ) special \u00a4 Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required id_prefix str The prefix to add to every ID. It is prepended without any separator. required Source code in handlers/rendering.py def __init__ ( self , md : Markdown , id_prefix : str ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. id_prefix: The prefix to add to every ID. It is prepended without any separator. \"\"\" super () . __init__ ( md ) self . id_prefix = id_prefix run ( self , root ) \u00a4 Subclasses of Treeprocessor should implement a run method, which takes a root ElementTree. This method can return another ElementTree object, and the existing root ElementTree will be replaced, or it can modify the current tree and return None. Source code in handlers/rendering.py def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . id_prefix : return for el in root . iter (): id_attr = el . get ( \"id\" ) if id_attr : el . set ( \"id\" , self . id_prefix + id_attr ) href_attr = el . get ( \"href\" ) if href_attr and href_attr . startswith ( \"#\" ): el . set ( \"href\" , \"#\" + self . id_prefix + href_attr [ 1 :]) name_attr = el . get ( \"name\" ) if name_attr : el . set ( \"name\" , self . id_prefix + name_attr ) if el . tag == \"label\" : for_attr = el . get ( \"for\" ) if for_attr : el . set ( \"for\" , self . id_prefix + for_attr ) MkdocstringsInnerExtension \u00a4 Extension that should always be added to Markdown sub-documents that handlers request (and only them). __init__ ( self , headings ) special \u00a4 Initialize the object. Parameters: Name Type Description Default headings List[xml.etree.ElementTree.Element] A list that will be populated with all HTML heading elements encountered in the document. required Source code in handlers/rendering.py def __init__ ( self , headings : List [ Element ]): \"\"\"Initialize the object. Arguments: headings: A list that will be populated with all HTML heading elements encountered in the document. \"\"\" super () . __init__ () self . headings = headings extendMarkdown ( self , md ) \u00a4 Register the extension. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in handlers/rendering.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) md . treeprocessors . register ( HeadingShiftingTreeprocessor ( md , 0 ), HeadingShiftingTreeprocessor . name , priority = 12 , ) md . treeprocessors . register ( IdPrependingTreeprocessor ( md , \"\" ), IdPrependingTreeprocessor . name , priority = 4 , # Right after 'toc' (needed because that extension adds ids to headers). ) md . treeprocessors . register ( _HeadingReportingTreeprocessor ( md , self . headings ), _HeadingReportingTreeprocessor . name , priority = 1 , # Close to the end. )","title":"rendering.py"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor","text":"Shift levels of all Markdown headings according to the configured base level.","title":"HeadingShiftingTreeprocessor"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required shift_by int The number of heading \"levels\" to add to every heading. required Source code in handlers/rendering.py def __init__ ( self , md : Markdown , shift_by : int ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. shift_by: The number of heading \"levels\" to add to every heading. \"\"\" super () . __init__ ( md ) self . shift_by = shift_by","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.HeadingShiftingTreeprocessor.run","text":"Subclasses of Treeprocessor should implement a run method, which takes a root ElementTree. This method can return another ElementTree object, and the existing root ElementTree will be replaced, or it can modify the current tree and return None. Source code in handlers/rendering.py def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . shift_by : return for el in root . iter (): match = self . regex . fullmatch ( el . tag ) if match : level = int ( match [ 2 ]) + self . shift_by level = max ( 1 , min ( level , 6 )) el . tag = f \" { match [ 1 ] }{ level } \"","title":"run()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.Highlighter","text":"Code highlighter that tries to match the Markdown configuration. Picking up the global config and defaults works only if you use the codehilite or pymdownx.highlight (recommended) Markdown extension. If you use pymdownx.highlight , highlighting settings are picked up from it, and the default CSS class is .highlight . This also means the default of guess_lang: false . Otherwise, if you use the codehilite extension, settings are picked up from it, and the default CSS class is .codehilite . Also consider setting guess_lang: false . If neither are added to markdown_extensions , highlighting is enabled anyway. This is for backwards compatibility. If you really want to disable highlighting even in mkdocstrings , add one of these extensions anyway and set use_pygments: false . The underlying implementation is pymdownx.highlight regardless.","title":"Highlighter"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.Highlighter.__init__","text":"Configure to match a markdown.Markdown instance. Parameters: Name Type Description Default md Markdown The Markdown instance to read configs from. required Source code in handlers/rendering.py def __init__ ( self , md : Markdown ): \"\"\"Configure to match a `markdown.Markdown` instance. Arguments: md: The Markdown instance to read configs from. \"\"\" config = {} for ext in md . registeredExtensions : if isinstance ( ext , HighlightExtension ) and ( ext . enabled or not config ): config = ext . getConfigs () break # This one takes priority, no need to continue looking if isinstance ( ext , CodeHiliteExtension ) and not config : config = ext . getConfigs () config [ \"language_prefix\" ] = config [ \"lang_prefix\" ] self . _css_class = config . pop ( \"css_class\" , \"highlight\" ) super () . __init__ ( ** { k : v for k , v in config . items () if k in self . _highlight_config_keys })","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.Highlighter.highlight","text":"Highlight a code-snippet. Parameters: Name Type Description Default src str The code to highlight. required language Optional[str] Explicitly tell what language to use for highlighting. None inline bool Whether to highlight as inline. False dedent bool Whether to dedent the code before highlighting it or not. True linenums Optional[bool] Whether to add line numbers in the result. None **kwargs Pass on to pymdownx.highlight.Highlight.highlight . {} Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in handlers/rendering.py def highlight ( # noqa: W0221 (intentionally different params, we're extending the functionality) self , src : str , language : Optional [ str ] = None , * , inline : bool = False , dedent : bool = True , linenums : Optional [ bool ] = None , ** kwargs , ) -> str : \"\"\"Highlight a code-snippet. Arguments: src: The code to highlight. language: Explicitly tell what language to use for highlighting. inline: Whether to highlight as inline. dedent: Whether to dedent the code before highlighting it or not. linenums: Whether to add line numbers in the result. **kwargs: Pass on to `pymdownx.highlight.Highlight.highlight`. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if isinstance ( src , Markup ): src = src . unescape () if dedent : src = textwrap . dedent ( src ) kwargs . setdefault ( \"css_class\" , self . _css_class ) old_linenums = self . linenums if linenums is not None : self . linenums = linenums try : result = super () . highlight ( src , language , inline = inline , ** kwargs ) finally : self . linenums = old_linenums if inline : return Markup ( f '<code class=\" { kwargs [ \"css_class\" ] } language- { language } \"> { result . text } </code>' ) return Markup ( result )","title":"highlight()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.IdPrependingTreeprocessor","text":"Prepend the configured prefix to IDs of all HTML elements.","title":"IdPrependingTreeprocessor"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.IdPrependingTreeprocessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required id_prefix str The prefix to add to every ID. It is prepended without any separator. required Source code in handlers/rendering.py def __init__ ( self , md : Markdown , id_prefix : str ): \"\"\"Initialize the object. Arguments: md: A `markdown.Markdown` instance. id_prefix: The prefix to add to every ID. It is prepended without any separator. \"\"\" super () . __init__ ( md ) self . id_prefix = id_prefix","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.IdPrependingTreeprocessor.run","text":"Subclasses of Treeprocessor should implement a run method, which takes a root ElementTree. This method can return another ElementTree object, and the existing root ElementTree will be replaced, or it can modify the current tree and return None. Source code in handlers/rendering.py def run ( self , root : Element ): # noqa: D102 (ignore missing docstring) if not self . id_prefix : return for el in root . iter (): id_attr = el . get ( \"id\" ) if id_attr : el . set ( \"id\" , self . id_prefix + id_attr ) href_attr = el . get ( \"href\" ) if href_attr and href_attr . startswith ( \"#\" ): el . set ( \"href\" , \"#\" + self . id_prefix + href_attr [ 1 :]) name_attr = el . get ( \"name\" ) if name_attr : el . set ( \"name\" , self . id_prefix + name_attr ) if el . tag == \"label\" : for_attr = el . get ( \"for\" ) if for_attr : el . set ( \"for\" , self . id_prefix + for_attr )","title":"run()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.MkdocstringsInnerExtension","text":"Extension that should always be added to Markdown sub-documents that handlers request (and only them).","title":"MkdocstringsInnerExtension"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.MkdocstringsInnerExtension.__init__","text":"Initialize the object. Parameters: Name Type Description Default headings List[xml.etree.ElementTree.Element] A list that will be populated with all HTML heading elements encountered in the document. required Source code in handlers/rendering.py def __init__ ( self , headings : List [ Element ]): \"\"\"Initialize the object. Arguments: headings: A list that will be populated with all HTML heading elements encountered in the document. \"\"\" super () . __init__ () self . headings = headings","title":"__init__()"},{"location":"reference/handlers/rendering/#mkdocstrings.handlers.rendering.MkdocstringsInnerExtension.extendMarkdown","text":"Register the extension. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in handlers/rendering.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) md . treeprocessors . register ( HeadingShiftingTreeprocessor ( md , 0 ), HeadingShiftingTreeprocessor . name , priority = 12 , ) md . treeprocessors . register ( IdPrependingTreeprocessor ( md , \"\" ), IdPrependingTreeprocessor . name , priority = 4 , # Right after 'toc' (needed because that extension adds ids to headers). ) md . treeprocessors . register ( _HeadingReportingTreeprocessor ( md , self . headings ), _HeadingReportingTreeprocessor . name , priority = 1 , # Close to the end. )","title":"extendMarkdown()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } function resizeIframe(obj) { obj.style.height = obj.contentWindow.document.documentElement.scrollHeight + 'px'; }","title":"Coverage report"}]}